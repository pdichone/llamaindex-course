import { EngineResponse } from "@llamaindex/core/schema";
import { extractText } from "@llamaindex/core/utils";
import { llmFromSettingsOrContext } from "../../Settings.js";
import { PromptMixin } from "../../prompts/index.js";
import { LLMSingleSelector } from "../../selectors/index.js";
import { TreeSummarize } from "../../synthesizers/index.js";
async function combineResponses(summarizer, responses, queryType, verbose = false) {
    if (verbose) {
        console.log("Combining responses from multiple query engines.");
    }
    const responseStrs = [];
    const sourceNodes = [];
    for (const response of responses){
        if (response?.sourceNodes) {
            sourceNodes.push(...response.sourceNodes);
        }
        responseStrs.push(extractText(response.message.content));
    }
    const summary = await summarizer.getResponse({
        query: extractText(queryType),
        textChunks: responseStrs
    });
    return EngineResponse.fromResponse(summary, false, sourceNodes);
}
/**
 * A query engine that uses multiple query engines and selects the best one.
 */ export class RouterQueryEngine extends PromptMixin {
    selector;
    queryEngines;
    metadatas;
    summarizer;
    verbose;
    constructor(init){
        super();
        this.selector = init.selector;
        this.queryEngines = init.queryEngineTools.map((tool)=>tool.queryEngine);
        this.metadatas = init.queryEngineTools.map((tool)=>({
                description: tool.description
            }));
        this.summarizer = init.summarizer || new TreeSummarize(init.serviceContext);
        this.verbose = init.verbose ?? false;
    }
    _getPromptModules() {
        return {
            selector: this.selector,
            summarizer: this.summarizer
        };
    }
    static fromDefaults(init) {
        const serviceContext = init.serviceContext;
        return new RouterQueryEngine({
            selector: init.selector ?? new LLMSingleSelector({
                llm: llmFromSettingsOrContext(serviceContext)
            }),
            queryEngineTools: init.queryEngineTools,
            serviceContext,
            summarizer: init.summarizer,
            verbose: init.verbose
        });
    }
    async query(params) {
        const { query, stream } = params;
        const response = await this.queryRoute(query);
        if (stream) {
            throw new Error("Streaming is not supported yet.");
        }
        return response;
    }
    async queryRoute(query) {
        const result = await this.selector.select(this.metadatas, query);
        if (result.selections.length > 1) {
            const responses = [];
            for(let i = 0; i < result.selections.length; i++){
                const engineInd = result.selections[i];
                const logStr = `Selecting query engine ${engineInd.index}: ${result.selections[i].index}.`;
                if (this.verbose) {
                    console.log(logStr + "\n");
                }
                const selectedQueryEngine = this.queryEngines[engineInd.index];
                responses.push(await selectedQueryEngine.query({
                    query: extractText(query)
                }));
            }
            if (responses.length > 1) {
                const finalResponse = await combineResponses(this.summarizer, responses, query, this.verbose);
                return finalResponse;
            } else {
                return responses[0];
            }
        } else {
            let selectedQueryEngine;
            try {
                selectedQueryEngine = this.queryEngines[result.selections[0].index];
                const logStr = `Selecting query engine ${result.selections[0].index}: ${result.selections[0].reason}`;
                if (this.verbose) {
                    console.log(logStr + "\n");
                }
            } catch (e) {
                throw new Error("Failed to select query engine");
            }
            if (!selectedQueryEngine) {
                throw new Error("Selected query engine is null");
            }
            const finalResponse = await selectedQueryEngine.query({
                query: extractText(query)
            });
            // add selected result
            finalResponse.metadata = finalResponse.metadata || {};
            finalResponse.metadata["selectorResult"] = result;
            return finalResponse;
        }
    }
}
