import { type BaseEmbedding } from "@llamaindex/core/embeddings";
import type { MessageContent } from "@llamaindex/core/llms";
import { ModalityType, type BaseNode, type Document, type NodeWithScore } from "@llamaindex/core/schema";
import type { BaseRetriever, RetrieveParams } from "../../Retriever.js";
import type { ServiceContext } from "../../ServiceContext.js";
import { RetrieverQueryEngine } from "../../engines/query/RetrieverQueryEngine.js";
import { DocStoreStrategy } from "../../ingestion/strategies/index.js";
import type { BaseNodePostprocessor } from "../../postprocessors/types.js";
import type { StorageContext } from "../../storage/StorageContext.js";
import type { MetadataFilters, VectorStore, VectorStoreByType, VectorStoreQueryResult } from "../../storage/index.js";
import type { BaseIndexStore } from "../../storage/indexStore/types.js";
import type { BaseSynthesizer } from "../../synthesizers/types.js";
import type { QueryEngine } from "../../types.js";
import type { BaseIndexInit } from "../BaseIndex.js";
import { BaseIndex } from "../BaseIndex.js";
import { IndexDict } from "../json-to-index-struct.js";
interface IndexStructOptions {
    indexStruct?: IndexDict;
    indexId?: string;
}
export interface VectorIndexOptions extends IndexStructOptions {
    nodes?: BaseNode[];
    serviceContext?: ServiceContext;
    storageContext?: StorageContext;
    vectorStores?: VectorStoreByType;
    logProgress?: boolean;
}
export interface VectorIndexConstructorProps extends BaseIndexInit<IndexDict> {
    indexStore: BaseIndexStore;
    vectorStores?: VectorStoreByType;
}
/**
 * The VectorStoreIndex, an index that stores the nodes only according to their vector embeddings.
 */
export declare class VectorStoreIndex extends BaseIndex<IndexDict> {
    indexStore: BaseIndexStore;
    embedModel?: BaseEmbedding;
    vectorStores: VectorStoreByType;
    private constructor();
    /**
     * The async init function creates a new VectorStoreIndex.
     * @param options
     * @returns
     */
    static init(options: VectorIndexOptions): Promise<VectorStoreIndex>;
    private static setupIndexStructFromStorage;
    /**
     * Calculates the embeddings for the given nodes.
     *
     * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.
     * @param {Object} [options] - An optional object containing additional parameters.
     *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
     */
    getNodeEmbeddingResults(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<BaseNode[]>;
    /**
     * Get embeddings for nodes and place them into the index.
     * @param nodes
     * @returns
     */
    buildIndexFromNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<void>;
    /**
     * High level API: split documents, get embeddings, and build index.
     * @param documents
     * @param args
     * @returns
     */
    static fromDocuments(documents: Document[], args?: VectorIndexOptions & {
        docStoreStrategy?: DocStoreStrategy;
    }): Promise<VectorStoreIndex>;
    static fromVectorStores(vectorStores: VectorStoreByType, serviceContext?: ServiceContext): Promise<VectorStoreIndex>;
    static fromVectorStore(vectorStore: VectorStore, serviceContext?: ServiceContext): Promise<VectorStoreIndex>;
    asRetriever(options?: Omit<VectorIndexRetrieverOptions, "index">): VectorIndexRetriever;
    /**
     * Create a RetrieverQueryEngine.
     * similarityTopK is only used if no existing retriever is provided.
     */
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: MetadataFilters;
        nodePostprocessors?: BaseNodePostprocessor[];
        similarityTopK?: number;
    }): QueryEngine & RetrieverQueryEngine;
    protected insertNodesToStore(newIds: string[], nodes: BaseNode[], vectorStore: VectorStore): Promise<void>;
    insertNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    protected deleteRefDocFromStore(vectorStore: VectorStore, refDocId: string): Promise<void>;
}
/**
 * VectorIndexRetriever retrieves nodes from a VectorIndex.
 */
type TopKMap = {
    [P in ModalityType]: number;
};
export type VectorIndexRetrieverOptions = {
    index: VectorStoreIndex;
    similarityTopK?: number;
    topK?: TopKMap;
    filters?: MetadataFilters;
};
export declare class VectorIndexRetriever implements BaseRetriever {
    index: VectorStoreIndex;
    topK: TopKMap;
    serviceContext?: ServiceContext;
    filters?: MetadataFilters;
    constructor({ index, similarityTopK, topK, filters, }: VectorIndexRetrieverOptions);
    /**
     * @deprecated, pass similarityTopK or topK in constructor instead or directly modify topK
     */
    set similarityTopK(similarityTopK: number);
    retrieve({ query, preFilters, }: RetrieveParams): Promise<NodeWithScore[]>;
    protected retrieveQuery(query: MessageContent, type: ModalityType, vectorStore: VectorStore, filters?: MetadataFilters): Promise<NodeWithScore[]>;
    protected buildNodeListFromQueryResult(result: VectorStoreQueryResult): NodeWithScore<import("@llamaindex/core/schema").Metadata>[];
}
export {};
