class ApiError extends Error {
    constructor(request, response, message){
        super(message);
        this.name = "ApiError";
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

var _computedKey;
class CancelError extends Error {
    constructor(message){
        super(message);
        this.name = "CancelError";
    }
    get isCancelled() {
        return true;
    }
}
_computedKey = Symbol.toStringTag;
class CancelablePromise {
    constructor(executor){
        this._isResolved = false;
        this._isRejected = false;
        this._isCancelled = false;
        this.cancelHandlers = [];
        this.promise = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
            const onResolve = (value)=>{
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isResolved = true;
                if (this._resolve) this._resolve(value);
            };
            const onReject = (reason)=>{
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isRejected = true;
                if (this._reject) this._reject(reason);
            };
            const onCancel = (cancelHandler)=>{
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this.cancelHandlers.push(cancelHandler);
            };
            Object.defineProperty(onCancel, "isResolved", {
                get: ()=>this._isResolved
            });
            Object.defineProperty(onCancel, "isRejected", {
                get: ()=>this._isRejected
            });
            Object.defineProperty(onCancel, "isCancelled", {
                get: ()=>this._isCancelled
            });
            return executor(onResolve, onReject, onCancel);
        });
    }
    get [_computedKey]() {
        return "Cancellable Promise";
    }
    then(onFulfilled, onRejected) {
        return this.promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this.promise.catch(onRejected);
    }
    finally(onFinally) {
        return this.promise.finally(onFinally);
    }
    cancel() {
        if (this._isResolved || this._isRejected || this._isCancelled) {
            return;
        }
        this._isCancelled = true;
        if (this.cancelHandlers.length) {
            try {
                for (const cancelHandler of this.cancelHandlers){
                    cancelHandler();
                }
            } catch (error) {
                console.warn("Cancellation threw an error", error);
                return;
            }
        }
        this.cancelHandlers.length = 0;
        if (this._reject) this._reject(new CancelError("Request aborted"));
    }
    get isCancelled() {
        return this._isCancelled;
    }
}

class Interceptors {
    constructor(){
        this._fns = [];
    }
    eject(fn) {
        const index = this._fns.indexOf(fn);
        if (index !== -1) {
            this._fns = [
                ...this._fns.slice(0, index),
                ...this._fns.slice(index + 1)
            ];
        }
    }
    use(fn) {
        this._fns = [
            ...this._fns,
            fn
        ];
    }
}
const OpenAPI = {
    BASE: "https://api.cloud.llamaindex.ai",
    CREDENTIALS: "include",
    ENCODE_PATH: undefined,
    HEADERS: undefined,
    PASSWORD: undefined,
    TOKEN: undefined,
    USERNAME: undefined,
    VERSION: "0.1.0",
    WITH_CREDENTIALS: false,
    interceptors: {
        request: new Interceptors(),
        response: new Interceptors()
    }
};

// This file is auto-generated by @hey-api/openapi-ts
const $APIKey = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 0,
            title: "Name"
        },
        user_id: {
            type: "string",
            title: "User Id"
        },
        redacted_api_key: {
            type: "string",
            title: "Redacted Api Key"
        }
    },
    type: "object",
    required: [
        "id",
        "user_id",
        "redacted_api_key"
    ],
    title: "APIKey",
    description: "Schema for an API Key."
};
const $APIKeyCreate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 0,
            title: "Name"
        }
    },
    type: "object",
    title: "APIKeyCreate",
    description: "Schema for creating an API key."
};
const $APIKeyUpdate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 0,
            title: "Name"
        }
    },
    type: "object",
    title: "APIKeyUpdate",
    description: "Schema for updating an API key."
};
const $AutoTransformConfig = {
    properties: {
        chunk_size: {
            type: "integer",
            title: "Chunk Size",
            description: "Chunk size for the transformation.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            description: "Chunk overlap for the transformation.",
            default: 20
        }
    },
    type: "object",
    title: "AutoTransformConfig"
};
const $AzureOpenAIEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the embedding model.",
            default: "unknown"
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the OpenAI API."
        },
        api_key: {
            type: "string",
            title: "Api Key",
            description: "The OpenAI API key."
        },
        api_base: {
            type: "string",
            title: "Api Base",
            description: "The base URL for Azure deployment.",
            default: ""
        },
        api_version: {
            type: "string",
            title: "Api Version",
            description: "The version for Azure OpenAI API.",
            default: ""
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            description: "Maximum number of retries.",
            default: 10,
            gte: 0
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "Timeout for each request.",
            default: 60,
            gte: 0
        },
        default_headers: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Default Headers",
            description: "The default headers for API requests."
        },
        reuse_client: {
            type: "boolean",
            title: "Reuse Client",
            description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
            default: true
        },
        dimensions: {
            type: "integer",
            title: "Dimensions",
            description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models."
        },
        azure_endpoint: {
            type: "string",
            title: "Azure Endpoint",
            description: "The Azure endpoint to use."
        },
        azure_deployment: {
            type: "string",
            title: "Azure Deployment",
            description: "The Azure deployment to use."
        },
        use_azure_ad: {
            type: "boolean",
            title: "Use Azure Ad",
            description: "Indicates if Microsoft Entra ID (former Azure AD) is used for token authentication"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "AzureOpenAIEmbedding"
        }
    },
    type: "object",
    required: [
        "api_key",
        "use_azure_ad"
    ],
    title: "AzureOpenAIEmbedding",
    description: `OpenAI class for embeddings.

Args:
    mode (str): Mode for embedding.
        Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.
        Options are:

        - OpenAIEmbeddingMode.SIMILARITY_MODE
        - OpenAIEmbeddingMode.TEXT_SEARCH_MODE

    model (str): Model for embedding.
        Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.
        Options are:

        - OpenAIEmbeddingModelType.DAVINCI
        - OpenAIEmbeddingModelType.CURIE
        - OpenAIEmbeddingModelType.BABBAGE
        - OpenAIEmbeddingModelType.ADA
        - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002`
};
const $Base = {
    properties: {},
    type: "object",
    title: "Base"
};
const $BasePromptTemplate = {
    properties: {
        metadata: {
            type: "object",
            title: "Metadata"
        },
        template_vars: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Template Vars"
        },
        kwargs: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Kwargs"
        },
        output_parser: {
            type: "object",
            title: "Output Parser",
            default: {}
        },
        template_var_mappings: {
            type: "object",
            title: "Template Var Mappings",
            description: "Template variable mappings (Optional)."
        }
    },
    type: "object",
    required: [
        "metadata",
        "template_vars",
        "kwargs"
    ],
    title: "BasePromptTemplate",
    description: `Chainable mixin.

A module that can produce a \`QueryComponent\` from a set of inputs through
\`as_query_component\`.

If plugged in directly into a \`QueryPipeline\`, the \`ChainableMixin\` will be
converted into a \`QueryComponent\` with default parameters.`
};
const $BedrockEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The modelId of the Bedrock model to use."
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        profile_name: {
            type: "string",
            title: "Profile Name",
            description: "The name of aws profile to use. If not given, then the default profile is used."
        },
        aws_access_key_id: {
            type: "string",
            title: "Aws Access Key Id",
            description: "AWS Access Key ID to use"
        },
        aws_secret_access_key: {
            type: "string",
            title: "Aws Secret Access Key",
            description: "AWS Secret Access Key to use"
        },
        aws_session_token: {
            type: "string",
            title: "Aws Session Token",
            description: "AWS Session Token to use"
        },
        region_name: {
            type: "string",
            title: "Region Name",
            description: "AWS region name to use. Uses region configured in AWS CLI if not passed"
        },
        botocore_session: {
            title: "Botocore Session",
            description: "Use this Botocore session instead of creating a new default one."
        },
        botocore_config: {
            title: "Botocore Config",
            description: "Custom configuration object to use instead of the default generated one."
        },
        max_retries: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Max Retries",
            description: "The maximum number of API retries.",
            default: 10
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.",
            default: 60
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the bedrock client."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "BedrockEmbedding"
        }
    },
    type: "object",
    required: [
        "model_name"
    ],
    title: "BedrockEmbedding",
    description: "Base class for embeddings."
};
const $Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put = {
    properties: {
        upload_file: {
            type: "string",
            format: "binary",
            title: "Upload File"
        }
    },
    type: "object",
    required: [
        "upload_file"
    ],
    title: "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put"
};
const $Body_upload_file_api_parsing_upload_post = {
    properties: {
        language: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            default: [
                "en"
            ]
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            type: "string",
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "boolean",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name"
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        },
        file: {
            type: "string",
            format: "binary",
            title: "File"
        }
    },
    type: "object",
    required: [
        "file"
    ],
    title: "Body_upload_file_api_parsing_upload_post"
};
const $Body_upload_file_api_v1_files_post = {
    properties: {
        upload_file: {
            type: "string",
            format: "binary",
            title: "Upload File"
        }
    },
    type: "object",
    required: [
        "upload_file"
    ],
    title: "Body_upload_file_api_v1_files_post"
};
const $Body_upload_file_api_v1_parsing_upload_post = {
    properties: {
        language: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            default: [
                "en"
            ]
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            type: "string",
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "boolean",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name"
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        },
        file: {
            type: "string",
            format: "binary",
            title: "File"
        }
    },
    type: "object",
    required: [
        "file"
    ],
    title: "Body_upload_file_api_v1_parsing_upload_post"
};
const $ChatData = {
    properties: {
        retrieval_parameters: {
            $ref: "#/components/schemas/PresetRetrievalParams"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "retrieval_parameters"
    ],
    title: "ChatData",
    description: `Base schema model for BaseComponent classes used in the platform.
Comes with special serialization logic for types used commonly in platform codebase.`
};
const $ChatMessage = {
    properties: {
        role: {
            allOf: [
                {
                    $ref: "#/components/schemas/MessageRole"
                }
            ],
            default: "user"
        },
        content: {
            title: "Content",
            default: ""
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs"
        }
    },
    type: "object",
    title: "ChatMessage",
    description: "Chat message."
};
const $ChatParams = {
    properties: {
        messages: {
            items: {
                $ref: "#/components/schemas/ChatMessage"
            },
            type: "array",
            title: "Messages"
        },
        data: {
            $ref: "#/components/schemas/ChatData"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "messages",
        "data"
    ],
    title: "ChatParams",
    description: `Base schema model for BaseComponent classes used in the platform.
Comes with special serialization logic for types used commonly in platform codebase.`
};
const $CheckoutSessionCreatePayload = {
    properties: {
        success_url: {
            type: "string",
            maxLength: 65536,
            minLength: 1,
            format: "uri",
            title: "Success Url"
        },
        cancel_url: {
            type: "string",
            maxLength: 65536,
            minLength: 1,
            format: "uri",
            title: "Cancel Url"
        }
    },
    type: "object",
    required: [
        "success_url",
        "cancel_url"
    ],
    title: "CheckoutSessionCreatePayload"
};
const $CloudAzStorageBlobDataSource = {
    properties: {
        container_name: {
            type: "string",
            title: "Container Name",
            description: "The name of the Azure Storage Blob container to read from."
        },
        account_url: {
            type: "string",
            title: "Account Url",
            description: "The Azure Storage Blob account URL to use for authentication."
        },
        blob: {
            type: "string",
            title: "Blob",
            description: "The blob name to read from."
        },
        prefix: {
            type: "string",
            title: "Prefix",
            description: "The prefix of the Azure Storage Blob objects to read from.",
            default: ""
        },
        account_name: {
            type: "string",
            title: "Account Name",
            description: "The Azure Storage Blob account name to use for authentication."
        },
        account_key: {
            type: "string",
            title: "Account Key",
            description: "The Azure Storage Blob account key to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudAzStorageBlobDataSource"
        }
    },
    type: "object",
    required: [
        "container_name",
        "account_url",
        "account_name",
        "account_key"
    ],
    title: "CloudAzStorageBlobDataSource",
    description: "Base component object to capture class names."
};
const $CloudAzureAISearchVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        search_service_api_key: {
            type: "string",
            title: "Search Service Api Key"
        },
        search_service_endpoint: {
            type: "string",
            title: "Search Service Endpoint"
        },
        search_service_api_version: {
            type: "string",
            title: "Search Service Api Version"
        },
        index_name: {
            type: "string",
            title: "Index Name"
        },
        filterable_metadata_field_keys: {
            type: "object",
            title: "Filterable Metadata Field Keys"
        },
        embedding_dimension: {
            type: "integer",
            title: "Embedding Dimension"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudAzureAISearchVectorStore"
        }
    },
    type: "object",
    required: [
        "search_service_api_key",
        "search_service_endpoint"
    ],
    title: "CloudAzureAISearchVectorStore",
    description: "Cloud Azure AI Search Vector Store."
};
const $CloudChromaVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        collection_name: {
            type: "string",
            title: "Collection Name"
        },
        host: {
            type: "string",
            title: "Host"
        },
        port: {
            type: "string",
            title: "Port"
        },
        ssl: {
            type: "boolean",
            title: "Ssl"
        },
        headers: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Headers"
        },
        persist_dir: {
            type: "string",
            title: "Persist Dir"
        },
        collection_kwargs: {
            type: "object",
            title: "Collection Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudChromaVectorStore"
        }
    },
    type: "object",
    required: [
        "ssl"
    ],
    title: "CloudChromaVectorStore",
    description: "Base class for cloud vector stores."
};
const $CloudConfluenceDataSource = {
    properties: {
        server_url: {
            type: "string",
            title: "Server Url",
            description: "The server URL of the Confluence instance."
        },
        authentication_mechanism: {
            type: "string",
            title: "Authentication Mechanism",
            description: "Type of Authentication for connecting to Confluence APIs."
        },
        user_name: {
            type: "string",
            title: "User Name",
            description: "The username to use for authentication."
        },
        api_token: {
            type: "string",
            title: "Api Token",
            description: "The API token to use for authentication."
        },
        space_key: {
            type: "string",
            title: "Space Key",
            description: "The space key to read from."
        },
        page_ids: {
            type: "string",
            title: "Page Ids",
            description: "The page IDs of the Confluence to read from."
        },
        cql: {
            type: "string",
            title: "Cql",
            description: "The CQL query to use for fetching pages."
        },
        label: {
            type: "string",
            title: "Label",
            description: "The label to use for fetching pages."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudConfluenceDataSource"
        }
    },
    type: "object",
    required: [
        "server_url",
        "authentication_mechanism"
    ],
    title: "CloudConfluenceDataSource",
    description: "Base component object to capture class names."
};
const $CloudDocument = {
    properties: {
        text: {
            type: "string",
            title: "Text"
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            default: []
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            default: []
        },
        id: {
            type: "string",
            title: "Id"
        }
    },
    type: "object",
    required: [
        "text",
        "metadata",
        "id"
    ],
    title: "CloudDocument",
    description: "Cloud document stored in S3."
};
const $CloudDocumentCreate = {
    properties: {
        text: {
            type: "string",
            title: "Text"
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            default: []
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            default: []
        },
        id: {
            type: "string",
            title: "Id"
        }
    },
    type: "object",
    required: [
        "text",
        "metadata"
    ],
    title: "CloudDocumentCreate",
    description: "Create a new cloud document."
};
const $CloudJiraDataSource = {
    properties: {
        email: {
            type: "string",
            title: "Email",
            description: "The email address to use for authentication."
        },
        api_token: {
            type: "string",
            title: "Api Token",
            description: "The API/ Access Token used for Basic, PAT and OAuth2 authentication."
        },
        server_url: {
            type: "string",
            title: "Server Url",
            description: "The server url for Jira Cloud."
        },
        cloud_id: {
            type: "string",
            title: "Cloud Id",
            description: "The cloud ID, used in case of OAuth2."
        },
        authentication_mechanism: {
            type: "string",
            title: "Authentication Mechanism",
            description: "Type of Authentication for connecting to Jira APIs."
        },
        query: {
            type: "string",
            title: "Query",
            description: "JQL (Jira Query Language) query to search."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudJiraDataSource"
        }
    },
    type: "object",
    required: [
        "authentication_mechanism",
        "query"
    ],
    title: "CloudJiraDataSource",
    description: "Cloud Jira Data Source integrating JiraReader."
};
const $CloudNotionPageDataSource = {
    properties: {
        integration_token: {
            type: "string",
            title: "Integration Token",
            description: "The integration token to use for authentication."
        },
        database_ids: {
            type: "string",
            title: "Database Ids",
            description: "The Notion Database Id to read content from."
        },
        page_ids: {
            type: "string",
            title: "Page Ids",
            description: "The Page ID's of the Notion to read from."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudNotionPageDataSource"
        }
    },
    type: "object",
    required: [
        "integration_token"
    ],
    title: "CloudNotionPageDataSource",
    description: "Base component object to capture class names."
};
const $CloudOneDriveDataSource = {
    properties: {
        user_principal_name: {
            type: "string",
            title: "User Principal Name",
            description: "The user principal name to use for authentication."
        },
        folder_path: {
            type: "string",
            title: "Folder Path",
            description: "The path of the OneDrive folder to read from."
        },
        folder_id: {
            type: "string",
            title: "Folder Id",
            description: "The ID of the OneDrive folder to read from."
        },
        client_id: {
            type: "string",
            title: "Client Id",
            description: "The client ID to use for authentication."
        },
        client_secret: {
            type: "string",
            title: "Client Secret",
            description: "The client secret to use for authentication."
        },
        tenant_id: {
            type: "string",
            title: "Tenant Id",
            description: "The tenant ID to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudOneDriveDataSource"
        }
    },
    type: "object",
    required: [
        "user_principal_name",
        "client_id",
        "client_secret",
        "tenant_id"
    ],
    title: "CloudOneDriveDataSource",
    description: "Base component object to capture class names."
};
const $CloudPineconeVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        api_key: {
            type: "string",
            title: "Api Key"
        },
        index_name: {
            type: "string",
            title: "Index Name"
        },
        namespace: {
            type: "string",
            title: "Namespace"
        },
        insert_kwargs: {
            type: "object",
            title: "Insert Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudPineconeVectorStore"
        }
    },
    type: "object",
    required: [
        "api_key",
        "index_name"
    ],
    title: "CloudPineconeVectorStore",
    description: `Cloud Pinecone Vector Store.

This class is used to store the configuration for a Pinecone vector store, so that it can be
created and used in LlamaCloud.

Args:
    api_key (str): API key for authenticating with Pinecone
    index_name (str): name of the Pinecone index
    namespace (optional[str]): namespace to use in the Pinecone index
    insert_kwargs (optional[dict]): additional kwargs to pass during insertion`
};
const $CloudPostgresVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        connection_string: {
            type: "string",
            title: "Connection String"
        },
        async_connection_string: {
            type: "string",
            title: "Async Connection String"
        },
        table_name: {
            type: "string",
            title: "Table Name"
        },
        schema_name: {
            type: "string",
            title: "Schema Name"
        },
        embed_dim: {
            type: "integer",
            title: "Embed Dim"
        },
        hybrid_search: {
            type: "boolean",
            title: "Hybrid Search"
        },
        text_search_config: {
            type: "string",
            title: "Text Search Config"
        },
        cache_ok: {
            type: "boolean",
            title: "Cache Ok"
        },
        perform_setup: {
            type: "boolean",
            title: "Perform Setup"
        },
        debug: {
            type: "boolean",
            title: "Debug"
        },
        use_jsonb: {
            type: "boolean",
            title: "Use Jsonb"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudPostgresVectorStore"
        }
    },
    type: "object",
    required: [
        "connection_string",
        "async_connection_string",
        "table_name",
        "schema_name",
        "embed_dim",
        "hybrid_search",
        "text_search_config",
        "cache_ok",
        "perform_setup",
        "debug",
        "use_jsonb"
    ],
    title: "CloudPostgresVectorStore",
    description: "Base class for cloud vector stores."
};
const $CloudQdrantVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        collection_name: {
            type: "string",
            title: "Collection Name"
        },
        url: {
            type: "string",
            title: "Url"
        },
        api_key: {
            type: "string",
            title: "Api Key"
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            default: 3
        },
        client_kwargs: {
            type: "object",
            title: "Client Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudQdrantVectorStore"
        }
    },
    type: "object",
    required: [
        "collection_name",
        "url",
        "api_key"
    ],
    title: "CloudQdrantVectorStore",
    description: `Cloud Qdrant Vector Store.

This class is used to store the configuration for a Qdrant vector store, so that it can be
created and used in LlamaCloud.

Args:
    collection_name (str): name of the Qdrant collection
    url (str): url of the Qdrant instance
    api_key (str): API key for authenticating with Qdrant
    max_retries (int): maximum number of retries in case of a failure. Defaults to 3
    client_kwargs (dict): additional kwargs to pass to the Qdrant client`
};
const $CloudS3DataSource = {
    properties: {
        bucket: {
            type: "string",
            title: "Bucket",
            description: "The name of the S3 bucket to read from."
        },
        prefix: {
            type: "string",
            title: "Prefix",
            description: "The prefix of the S3 objects to read from."
        },
        aws_access_id: {
            type: "string",
            title: "Aws Access Id",
            description: "The AWS access ID to use for authentication."
        },
        aws_access_secret: {
            type: "string",
            title: "Aws Access Secret",
            description: "The AWS access secret to use for authentication."
        },
        s3_endpoint_url: {
            type: "string",
            title: "S3 Endpoint Url",
            description: "The S3 endpoint URL to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudS3DataSource"
        }
    },
    type: "object",
    required: [
        "bucket"
    ],
    title: "CloudS3DataSource",
    description: "Base component object to capture class names."
};
const $CloudSharepointDataSource = {
    properties: {
        site_name: {
            type: "string",
            title: "Site Name",
            description: "The name of the SharePoint site to download from."
        },
        folder_path: {
            type: "string",
            title: "Folder Path",
            description: "The path of the Sharepoint folder to read from."
        },
        folder_id: {
            type: "string",
            title: "Folder Id",
            description: "The ID of the Sharepoint folder to read from."
        },
        drive_name: {
            type: "string",
            title: "Drive Name",
            description: "The name of the Sharepoint drive to read from."
        },
        client_id: {
            type: "string",
            title: "Client Id",
            description: "The client ID to use for authentication."
        },
        client_secret: {
            type: "string",
            title: "Client Secret",
            description: "The client secret to use for authentication."
        },
        tenant_id: {
            type: "string",
            title: "Tenant Id",
            description: "The tenant ID to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudSharepointDataSource"
        }
    },
    type: "object",
    required: [
        "site_name",
        "client_id",
        "client_secret",
        "tenant_id"
    ],
    title: "CloudSharepointDataSource",
    description: "Base component object to capture class names."
};
const $CloudSlackDataSource = {
    properties: {
        slack_token: {
            type: "string",
            title: "Slack Token",
            description: "Slack Bot Token."
        },
        channel_ids: {
            type: "string",
            title: "Channel Ids",
            description: "Slack Channel."
        },
        latest_date: {
            type: "string",
            title: "Latest Date",
            description: "Latest date."
        },
        earliest_date: {
            type: "string",
            title: "Earliest Date",
            description: "Earliest date."
        },
        earliest_date_timestamp: {
            type: "number",
            title: "Earliest Date Timestamp",
            description: "Earliest date timestamp."
        },
        latest_date_timestamp: {
            type: "number",
            title: "Latest Date Timestamp",
            description: "Latest date timestamp."
        },
        channel_patterns: {
            type: "string",
            title: "Channel Patterns",
            description: "Slack Channel name pattern."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudSlackDataSource"
        }
    },
    type: "object",
    required: [
        "slack_token"
    ],
    title: "CloudSlackDataSource",
    description: "Base component object to capture class names."
};
const $CloudWeaviateVectorStore = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        index_name: {
            type: "string",
            title: "Index Name"
        },
        url: {
            type: "string",
            title: "Url"
        },
        text_key: {
            type: "string",
            title: "Text Key"
        },
        auth_config: {
            type: "object",
            title: "Auth Config"
        },
        client_kwargs: {
            type: "object",
            title: "Client Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudWeaviateVectorStore"
        }
    },
    type: "object",
    required: [
        "index_name",
        "text_key"
    ],
    title: "CloudWeaviateVectorStore",
    description: "Base class for cloud vector stores."
};
const $CodeSplitter = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        language: {
            type: "string",
            title: "Language",
            description: "The programming language of the code being split."
        },
        chunk_lines: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Lines",
            description: "The number of lines to include in each chunk.",
            default: 40
        },
        chunk_lines_overlap: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Lines Overlap",
            description: "How many lines of code each chunk overlaps with.",
            default: 15
        },
        max_chars: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Max Chars",
            description: "Maximum number of characters per chunk.",
            default: 1500
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CodeSplitter"
        }
    },
    type: "object",
    required: [
        "language"
    ],
    title: "CodeSplitter",
    description: `Split code using a AST parser.

Thank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.
https://docs.sweep.dev/blogs/chunking-2m-files`
};
const $CohereEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the embedding model.",
            default: "unknown"
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        api_key: {
            type: "string",
            title: "Api Key",
            description: "The Cohere API key."
        },
        truncate: {
            type: "string",
            title: "Truncate",
            description: "Truncation type - START/ END/ NONE"
        },
        input_type: {
            type: "string",
            title: "Input Type",
            description: "Model Input type. If not provided, search_document and search_query are used when needed."
        },
        embedding_type: {
            type: "string",
            title: "Embedding Type",
            description: "Embedding type. If not provided float embedding_type is used when needed."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CohereEmbedding"
        }
    },
    type: "object",
    required: [
        "api_key",
        "truncate",
        "embedding_type"
    ],
    title: "CohereEmbedding",
    description: "CohereEmbedding uses the Cohere API to generate embeddings for text."
};
const $ConfigurableDataSinkNames = {
    type: "string",
    enum: [
        "CHROMA",
        "PINECONE",
        "POSTGRES",
        "QDRANT",
        "WEAVIATE",
        "AZUREAI_SEARCH"
    ],
    title: "ConfigurableDataSinkNames",
    description: "An enumeration."
};
const $ConfigurableDataSourceNames = {
    type: "string",
    enum: [
        "S3",
        "AZURE_STORAGE_BLOB",
        "MICROSOFT_ONEDRIVE",
        "MICROSOFT_SHAREPOINT",
        "SLACK",
        "NOTION_PAGE",
        "CONFLUENCE",
        "JIRA"
    ],
    title: "ConfigurableDataSourceNames",
    description: "An enumeration."
};
const $ConfigurableTransformationDefinition = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        configurable_transformation_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/ConfigurableTransformationNames"
                }
            ],
            description: "The name field will act as the unique identifier of TransformationDefinition objects"
        },
        transformation_category: {
            allOf: [
                {
                    $ref: "#/components/schemas/TransformationCategoryNames"
                }
            ],
            description: "The transformation_category field will be used to group transformations in the UI"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "configurable_transformation_type",
        "transformation_category"
    ],
    title: "ConfigurableTransformationDefinition",
    description: "Schema for a transformation definition."
};
const $ConfigurableTransformationNames = {
    type: "string",
    enum: [
        "CODE_NODE_PARSER",
        "SENTENCE_AWARE_NODE_PARSER",
        "TOKEN_AWARE_NODE_PARSER",
        "HTML_NODE_PARSER",
        "MARKDOWN_NODE_PARSER",
        "JSON_NODE_PARSER",
        "SIMPLE_FILE_NODE_PARSER",
        "MARKDOWN_ELEMENT_NODE_PARSER",
        "OPENAI_EMBEDDING",
        "AZURE_EMBEDDING",
        "COHERE_EMBEDDING",
        "BEDROCK_EMBEDDING",
        "HUGGINGFACE_API_EMBEDDING",
        "GEMINI_EMBEDDING"
    ],
    title: "ConfigurableTransformationNames",
    description: "An enumeration."
};
const $ConfiguredTransformationItem = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id"
        },
        configurable_transformation_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/ConfigurableTransformationNames"
                }
            ],
            description: "Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames."
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CodeSplitter"
                        },
                        {
                            $ref: "#/components/schemas/SentenceSplitter"
                        },
                        {
                            $ref: "#/components/schemas/TokenTextSplitter"
                        },
                        {
                            $ref: "#/components/schemas/HTMLNodeParser"
                        },
                        {
                            $ref: "#/components/schemas/MarkdownNodeParser"
                        },
                        {
                            $ref: "#/components/schemas/JSONNodeParser"
                        },
                        {
                            $ref: "#/components/schemas/SimpleFileNodeParser"
                        },
                        {
                            $ref: "#/components/schemas/MarkdownElementNodeParser"
                        },
                        {
                            $ref: "#/components/schemas/OpenAIEmbedding"
                        },
                        {
                            $ref: "#/components/schemas/AzureOpenAIEmbedding"
                        },
                        {
                            $ref: "#/components/schemas/CohereEmbedding"
                        },
                        {
                            $ref: "#/components/schemas/BedrockEmbedding"
                        },
                        {
                            $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding"
                        },
                        {
                            $ref: "#/components/schemas/GeminiEmbedding"
                        }
                    ]
                }
            ],
            title: "Component",
            description: "Component that implements the transformation"
        }
    },
    type: "object",
    required: [
        "configurable_transformation_type",
        "component"
    ],
    title: "ConfiguredTransformationItem",
    description: `Configured transformations for pipelines.

Similar to ConfigurableTransformation but includes a few
more fields that are useful to the platform.`
};
const $CustomerPortalSessionCreatePayload = {
    properties: {
        return_url: {
            type: "string",
            maxLength: 65536,
            minLength: 1,
            format: "uri",
            title: "Return Url"
        }
    },
    type: "object",
    required: [
        "return_url"
    ],
    title: "CustomerPortalSessionCreatePayload"
};
const $DataSink = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudChromaVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPineconeVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPostgresVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudQdrantVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudWeaviateVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                        }
                    ]
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "sink_type",
        "component",
        "project_id"
    ],
    title: "DataSink",
    description: "Schema for a data sink."
};
const $DataSinkCreate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudChromaVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPineconeVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPostgresVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudQdrantVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudWeaviateVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                        }
                    ]
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "name",
        "sink_type",
        "component"
    ],
    title: "DataSinkCreate",
    description: "Schema for creating a data sink."
};
const $DataSinkDefinition = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        sink_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/ConfigurableDataSinkNames"
                }
            ],
            description: "The name field will act as the unique identifier of DataSinkDefinition objects"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "sink_type"
    ],
    title: "DataSinkDefinition",
    description: "Schema for a data sink definition."
};
const $DataSinkUpdate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudChromaVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPineconeVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudPostgresVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudQdrantVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudWeaviateVectorStore"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                        }
                    ]
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "sink_type"
    ],
    title: "DataSinkUpdate",
    description: "Schema for updating a data sink."
};
const $DataSource = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudS3DataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudOneDriveDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSharepointDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSlackDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudNotionPageDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudConfluenceDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudJiraDataSource"
                        }
                    ]
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "source_type",
        "component",
        "project_id"
    ],
    title: "DataSource",
    description: "Schema for a data source."
};
const $DataSourceCreate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudS3DataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudOneDriveDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSharepointDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSlackDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudNotionPageDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudConfluenceDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudJiraDataSource"
                        }
                    ]
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "name",
        "source_type",
        "component"
    ],
    title: "DataSourceCreate",
    description: "Schema for creating a data source."
};
const $DataSourceDefinition = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        source_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/ConfigurableDataSourceNames"
                }
            ],
            description: "The name field will act as the unique identifier of DataSourceDefinition objects"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "source_type"
    ],
    title: "DataSourceDefinition",
    description: "Schema for a data source definition."
};
const $DataSourceUpdate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudS3DataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudOneDriveDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSharepointDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSlackDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudNotionPageDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudConfluenceDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudJiraDataSource"
                        }
                    ]
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "source_type"
    ],
    title: "DataSourceUpdate",
    description: "Schema for updating a data source."
};
const $DefaultOrganizationUpdate = {
    properties: {
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        }
    },
    type: "object",
    required: [
        "organization_id"
    ],
    title: "DefaultOrganizationUpdate",
    description: "Schema for updating the default organization for a user."
};
const $EmbeddingConfig = {
    properties: {
        type: {
            allOf: [
                {
                    $ref: "#/components/schemas/EmbeddingConfigType"
                }
            ],
            description: "Type of the embedding model.",
            default: "OPENAI_EMBEDDING"
        },
        component: {
            anyOf: [
                {
                    $ref: "#/components/schemas/OpenAIEmbedding"
                },
                {
                    $ref: "#/components/schemas/AzureOpenAIEmbedding"
                },
                {
                    $ref: "#/components/schemas/BedrockEmbedding"
                },
                {
                    $ref: "#/components/schemas/CohereEmbedding"
                },
                {
                    $ref: "#/components/schemas/GeminiEmbedding"
                },
                {
                    $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding"
                }
            ],
            title: "Component",
            description: "Configuration for the transformation."
        }
    },
    type: "object",
    title: "EmbeddingConfig"
};
const $EmbeddingConfigType = {
    type: "string",
    enum: [
        "OPENAI_EMBEDDING",
        "AZURE_EMBEDDING",
        "BEDROCK_EMBEDDING",
        "COHERE_EMBEDDING",
        "GEMINI_EMBEDDING",
        "HUGGINGFACE_API_EMBEDDING"
    ],
    title: "EmbeddingConfigType",
    description: "An enumeration."
};
const $EvalDataset = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "EvalDataset",
    description: `Schema for an eval dataset.
Includes the other DB fields like id, created_at, & updated_at.`
};
const $EvalDatasetCreate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "EvalDatasetCreate",
    description: "Schema for creating an eval dataset."
};
const $EvalDatasetJobParams = {
    properties: {
        eval_question_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            title: "Eval Question Ids",
            description: "The IDs for the EvalQuestions this execution ran against."
        },
        eval_execution_params: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                }
            ],
            title: "Eval Execution Params",
            description: "The parameters for the eval execution."
        }
    },
    type: "object",
    required: [
        "eval_question_ids",
        "eval_execution_params"
    ],
    title: "EvalDatasetJobParams",
    description: "Schema for the parameters of an eval dataset job."
};
const $EvalDatasetJobRecord = {
    properties: {
        job_name: {
            type: "string",
            enum: [
                "eval_dataset_job"
            ],
            title: "Job Name"
        },
        partitions: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "string",
                        format: "uuid"
                    },
                    {
                        type: "string"
                    }
                ]
            },
            type: "object",
            title: "Partitions",
            description: "The partitions for this execution. Used for determining where to save job output."
        },
        parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalDatasetJobParams"
                }
            ],
            title: "Parameters",
            description: "Additional input parameters for the eval execution."
        },
        session_id: {
            type: "string",
            format: "uuid",
            title: "Session Id",
            description: "The upstream request ID that created this job. Used for tracking the job across services."
        },
        correlation_id: {
            type: "string",
            format: "uuid",
            title: "Correlation Id",
            description: "The correlation ID for this job. Used for tracking the job across services."
        },
        parent_job_execution_id: {
            type: "string",
            format: "uuid",
            title: "Parent Job Execution Id",
            description: "The ID of the parent job execution."
        },
        user_id: {
            type: "string",
            title: "User Id",
            description: "The ID of the user that created this job"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        status: {
            $ref: "#/components/schemas/StatusEnum"
        },
        error_message: {
            type: "string",
            title: "Error Message"
        },
        attempts: {
            type: "integer",
            title: "Attempts",
            description: "The number of times this job has been attempted",
            default: 0
        },
        started_at: {
            type: "string",
            format: "date-time",
            title: "Started At"
        },
        ended_at: {
            type: "string",
            format: "date-time",
            title: "Ended At"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        data: {
            allOf: [
                {
                    $ref: "#/components/schemas/Base"
                }
            ],
            title: "Data",
            description: "Additional metadata for the job execution."
        }
    },
    type: "object",
    required: [
        "job_name",
        "partitions",
        "status"
    ],
    title: "EvalDatasetJobRecord",
    description: "Schema for job that evaluates an EvalDataset against a pipeline."
};
const $EvalDatasetUpdate = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "EvalDatasetUpdate",
    description: `Schema for updating an eval dataset.
Only the name can be updated.`
};
const $EvalExecutionCreate = {
    properties: {
        eval_question_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            title: "Eval Question Ids"
        },
        params: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParamsOverride"
                }
            ],
            title: "Params",
            description: "The parameters for the eval execution that will override the ones set in the pipeline."
        }
    },
    type: "object",
    required: [
        "eval_question_ids"
    ],
    title: "EvalExecutionCreate",
    description: "Schema for creating an eval execution for a given set of questions on a pipeline."
};
const $EvalExecutionParams = {
    properties: {
        llm_model: {
            allOf: [
                {
                    $ref: "#/components/schemas/SupportedEvalLLMModelNames"
                }
            ],
            description: "The LLM model to use within eval execution.",
            default: "GPT_3_5_TURBO"
        },
        qa_prompt_tmpl: {
            type: "string",
            title: "Qa Prompt Tmpl",
            description: "The template to use for the question answering prompt.",
            default: `Context information is below.
---------------------
{context_str}
---------------------
Given the context information and not prior knowledge, answer the query.
Query: {query_str}
Answer: `
        }
    },
    type: "object",
    title: "EvalExecutionParams",
    description: "Schema for the params for an eval execution."
};
const $EvalExecutionParamsOverride = {
    properties: {
        llm_model: {
            allOf: [
                {
                    $ref: "#/components/schemas/SupportedEvalLLMModelNames"
                }
            ],
            description: "The LLM model to use within eval execution."
        },
        qa_prompt_tmpl: {
            type: "string",
            title: "Qa Prompt Tmpl",
            description: "The template to use for the question answering prompt."
        }
    },
    type: "object",
    title: "EvalExecutionParamsOverride",
    description: "Schema for the params override for an eval execution."
};
const $EvalLLMModelData = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the LLM model."
        },
        description: {
            type: "string",
            title: "Description",
            description: "The description of the LLM model."
        }
    },
    type: "object",
    required: [
        "name",
        "description"
    ],
    title: "EvalLLMModelData",
    description: "Schema for an eval LLM model."
};
const $EvalQuestion = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        content: {
            type: "string",
            maxLength: 1000,
            minLength: 1,
            title: "Content",
            description: "The content of the question."
        },
        eval_dataset_id: {
            type: "string",
            format: "uuid",
            title: "Eval Dataset Id"
        },
        eval_dataset_index: {
            type: "integer",
            title: "Eval Dataset Index",
            description: "The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.",
            min: 0
        }
    },
    type: "object",
    required: [
        "id",
        "content",
        "eval_dataset_id",
        "eval_dataset_index"
    ],
    title: "EvalQuestion",
    description: "Base schema model containing common database fields."
};
const $EvalQuestionCreate = {
    properties: {
        content: {
            type: "string",
            maxLength: 1000,
            minLength: 1,
            title: "Content",
            description: "The content of the question."
        }
    },
    type: "object",
    required: [
        "content"
    ],
    title: "EvalQuestionCreate"
};
const $EvalQuestionResult = {
    properties: {
        eval_question_id: {
            type: "string",
            format: "uuid",
            title: "Eval Question Id",
            description: "The ID of the question that was executed."
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the question was executed against."
        },
        source_nodes: {
            items: {
                $ref: "#/components/schemas/TextNode"
            },
            type: "array",
            title: "Source Nodes",
            description: "The nodes retrieved by the pipeline for the given question."
        },
        answer: {
            type: "string",
            title: "Answer",
            description: "The answer to the question."
        },
        eval_metrics: {
            additionalProperties: {
                $ref: "#/components/schemas/MetricResult"
            },
            type: "object",
            title: "Eval Metrics",
            description: "The eval metrics for the question."
        },
        eval_dataset_execution_id: {
            type: "string",
            format: "uuid",
            title: "Eval Dataset Execution Id",
            description: "The ID of the EvalDatasetJobRecord that this result was generated from."
        },
        eval_dataset_execution_params: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                }
            ],
            title: "Eval Dataset Execution Params",
            description: "The EvalExecutionParams that were used when this result was generated."
        },
        eval_finished_at: {
            type: "string",
            format: "date-time",
            title: "Eval Finished At",
            description: "The timestamp when the eval finished."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "EvalQuestionResult"
        }
    },
    type: "object",
    required: [
        "eval_question_id",
        "pipeline_id",
        "source_nodes",
        "answer",
        "eval_metrics",
        "eval_dataset_execution_id",
        "eval_dataset_execution_params",
        "eval_finished_at"
    ],
    title: "EvalQuestionResult",
    description: "Schema for the result of an eval question job."
};
const $ExtractionJob = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "The id of the extraction job"
        },
        status: {
            allOf: [
                {
                    $ref: "#/components/schemas/StatusEnum"
                }
            ],
            description: "The status of the extraction job"
        },
        file: {
            allOf: [
                {
                    $ref: "#/components/schemas/File"
                }
            ],
            title: "File",
            description: "The file that the extract was extracted from"
        }
    },
    type: "object",
    required: [
        "id",
        "status",
        "file"
    ],
    title: "ExtractionJob"
};
const $ExtractionJobCreate = {
    properties: {
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The id of the file"
        }
    },
    type: "object",
    required: [
        "schema_id",
        "file_id"
    ],
    title: "ExtractionJobCreate",
    description: "Schema for creating an extraction job."
};
const $ExtractionJobCreateBatch = {
    properties: {
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        file_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            minItems: 1,
            title: "File Ids",
            description: "The ids of the files"
        }
    },
    type: "object",
    required: [
        "schema_id",
        "file_ids"
    ],
    title: "ExtractionJobCreateBatch",
    description: "Schema for creating extraction jobs in batch."
};
const $ExtractionResult = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        data: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Data",
            description: "The data extracted from the file"
        },
        file: {
            allOf: [
                {
                    $ref: "#/components/schemas/File"
                }
            ],
            title: "File",
            description: "The file that the extract was extracted from"
        }
    },
    type: "object",
    required: [
        "id",
        "schema_id",
        "data",
        "file"
    ],
    title: "ExtractionResult",
    description: "Schema for an extraction result."
};
const $ExtractionSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        data_schema: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "ExtractionSchema",
    description: "Schema for extraction schema."
};
const $ExtractionSchemaCreate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        data_schema: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    required: [
        "name",
        "data_schema"
    ],
    title: "ExtractionSchemaCreate",
    description: "Schema for creating an extraction schema."
};
const $ExtractionSchemaInfer = {
    properties: {
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The ID of a schema to update with the new schema"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        file_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            minItems: 1,
            title: "File Ids",
            description: "The IDs of the files that the extraction schema contains"
        },
        stream: {
            type: "boolean",
            title: "Stream",
            description: "Whether to stream the results of the extraction schema",
            default: false
        }
    },
    type: "object",
    required: [
        "name",
        "file_ids"
    ],
    title: "ExtractionSchemaInfer",
    description: "Schema for inferring an extraction schema."
};
const $ExtractionSchemaUpdate = {
    properties: {
        data_schema: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    title: "ExtractionSchemaUpdate",
    description: "Schema for updating an extraction schema."
};
const $File = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        file_size: {
            type: "integer",
            minimum: 0,
            title: "File Size",
            description: "Size of the file in bytes"
        },
        file_type: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "File Type",
            description: "File type (e.g. pdf, docx, etc.)"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the file belongs to"
        },
        last_modified_at: {
            type: "string",
            format: "date-time",
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "File",
    description: "Schema for a file."
};
const $FileCreate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        file_size: {
            type: "integer",
            minimum: 0,
            title: "File Size",
            description: "Size of the file in bytes"
        },
        last_modified_at: {
            type: "string",
            format: "date-time",
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "FileCreate"
};
const $FilterCondition = {
    type: "string",
    enum: [
        "and",
        "or"
    ],
    title: "FilterCondition",
    description: "Vector store filter conditions to combine different filters."
};
const $FilterOperator = {
    type: "string",
    enum: [
        "==",
        ">",
        "<",
        "!=",
        ">=",
        "<=",
        "in",
        "nin",
        "any",
        "all",
        "text_match",
        "contains"
    ],
    title: "FilterOperator",
    description: "Vector store filter operator."
};
const $GeminiEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the embedding model.",
            default: "unknown"
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        title: {
            type: "string",
            title: "Title",
            description: "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.",
            default: ""
        },
        task_type: {
            type: "string",
            title: "Task Type",
            description: "The task for embedding model.",
            default: "retrieval_document"
        },
        api_key: {
            type: "string",
            title: "Api Key",
            description: "API key to access the model. Defaults to None."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "GeminiEmbedding"
        }
    },
    type: "object",
    title: "GeminiEmbedding",
    description: `Google Gemini embeddings.

Args:
    model_name (str): Model for embedding.
        Defaults to "models/embedding-001".

    api_key (Optional[str]): API key to access the model. Defaults to None.
    api_base (Optional[str]): API base to access the model. Defaults to Official Base.
    transport (Optional[str]): Transport to access the model.`
};
const $HTMLNodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        tags: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Tags",
            description: "HTML tags to extract text from.",
            default: [
                "p",
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "li",
                "b",
                "i",
                "u",
                "section"
            ]
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "HTMLNodeParser"
        }
    },
    type: "object",
    title: "HTMLNodeParser",
    description: `HTML node parser.

Splits a document into Nodes using custom HTML splitting logic.

Args:
    include_metadata (bool): whether to include metadata in nodes
    include_prev_next_rel (bool): whether to include prev/next relationships`
};
const $HTTPValidationError = {
    properties: {
        detail: {
            items: {
                $ref: "#/components/schemas/ValidationError"
            },
            type: "array",
            title: "Detail"
        }
    },
    type: "object",
    title: "HTTPValidationError"
};
const $HuggingFaceInferenceAPIEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "Hugging Face model name. If None, the task will be used."
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        pooling: {
            allOf: [
                {
                    $ref: "#/components/schemas/Pooling"
                }
            ],
            description: "Pooling strategy. If None, the model's default pooling is used.",
            default: "cls"
        },
        query_instruction: {
            type: "string",
            title: "Query Instruction",
            description: "Instruction to prepend during query embedding."
        },
        text_instruction: {
            type: "string",
            title: "Text Instruction",
            description: "Instruction to prepend during text embedding."
        },
        token: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "boolean"
                }
            ],
            title: "Token",
            description: "Hugging Face token. Will default to the locally saved token. Pass token=False if you dont want to send your token to the server."
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available."
        },
        headers: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Headers",
            description: "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values."
        },
        cookies: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Cookies",
            description: "Additional cookies to send to the server."
        },
        task: {
            type: "string",
            title: "Task",
            description: "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "HuggingFaceInferenceAPIEmbedding"
        }
    },
    type: "object",
    title: "HuggingFaceInferenceAPIEmbedding",
    description: `Wrapper on the Hugging Face's Inference API for embeddings.

Overview of the design:
- Uses the feature extraction task: https://huggingface.co/tasks/feature-extraction`
};
const $JSONNodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "JSONNodeParser"
        }
    },
    type: "object",
    title: "JSONNodeParser",
    description: `JSON node parser.

Splits a document into Nodes using custom JSON splitting logic.

Args:
    include_metadata (bool): whether to include metadata in nodes
    include_prev_next_rel (bool): whether to include prev/next relationships`
};
const $LLM = {
    properties: {
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        system_prompt: {
            type: "string",
            title: "System Prompt",
            description: "System prompt for LLM calls."
        },
        output_parser: {
            type: "object",
            title: "Output Parser",
            description: "Output parser to parse, validate, and correct errors programmatically.",
            default: {}
        },
        pydantic_program_mode: {
            allOf: [
                {
                    $ref: "#/components/schemas/PydanticProgramMode"
                }
            ],
            default: "default"
        },
        query_wrapper_prompt: {
            allOf: [
                {
                    $ref: "#/components/schemas/BasePromptTemplate"
                }
            ],
            title: "Query Wrapper Prompt",
            description: "Query wrapper prompt for LLM calls."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "LLM",
    description: `The LLM class is the main class for interacting with language models.

Attributes:
    system_prompt (Optional[str]):
        System prompt for LLM calls.
    messages_to_prompt (Callable):
        Function to convert a list of messages to an LLM prompt.
    completion_to_prompt (Callable):
        Function to convert a completion to an LLM prompt.
    output_parser (Optional[BaseOutputParser]):
        Output parser to parse, validate, and correct errors programmatically.
    pydantic_program_mode (PydanticProgramMode):
        Pydantic program mode to use for structured prediction.`
};
const $LlamaParseParameters = {
    properties: {
        languages: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            minItems: 1
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        disable_ocr: {
            type: "boolean",
            title: "Disable Ocr",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: true
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            type: "string",
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "string",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name",
            default: ""
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        }
    },
    type: "object",
    title: "LlamaParseParameters",
    description: "Settings that can be configured for how to use LlamaParse to parse files witin a LlamaCloud pipeline."
};
const $LlamaParseSupportedFileExtensions = {
    type: "string",
    enum: [
        ".pdf",
        ".doc",
        ".docx",
        ".docm",
        ".dot",
        ".dotx",
        ".dotm",
        ".rtf",
        ".wps",
        ".wpd",
        ".sxw",
        ".stw",
        ".sxg",
        ".pages",
        ".mw",
        ".mcw",
        ".uot",
        ".uof",
        ".uos",
        ".uop",
        ".ppt",
        ".pptx",
        ".pot",
        ".pptm",
        ".potx",
        ".potm",
        ".key",
        ".odp",
        ".odg",
        ".otp",
        ".fopd",
        ".sxi",
        ".sti",
        ".epub",
        ".html",
        ".htm",
        ".xls",
        ".xlsx",
        ".xlsm",
        ".xlsb",
        ".xlw",
        ".csv",
        ".dif",
        ".sylk",
        ".slk",
        ".prn",
        ".numbers",
        ".et",
        ".ods",
        ".fods",
        ".uos1",
        ".uos2",
        ".dbf",
        ".wk1",
        ".wk2",
        ".wk3",
        ".wk4",
        ".wks",
        ".wq1",
        ".wq2",
        ".wb1",
        ".wb2",
        ".wb3",
        ".qpw",
        ".xlr",
        ".eth",
        ".tsv"
    ],
    title: "LlamaParseSupportedFileExtensions",
    description: "An enumeration."
};
const $LocalEval = {
    properties: {
        query: {
            type: "string",
            title: "Query",
            description: "Query string"
        },
        contexts: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Contexts",
            description: "Context strings"
        },
        response: {
            type: "string",
            title: "Response",
            description: "Response string"
        },
        passing: {
            type: "boolean",
            title: "Passing",
            description: "Binary evaluation result (passing or not)"
        },
        feedback: {
            type: "string",
            title: "Feedback",
            description: "Feedback or reasoning for the response"
        },
        score: {
            type: "number",
            title: "Score",
            description: "Score for the response"
        },
        pairwise_source: {
            type: "string",
            title: "Pairwise Source",
            description: "Used only for pairwise and specifies whether it is from original order of presented answers or flipped order"
        },
        invalid_result: {
            type: "boolean",
            title: "Invalid Result",
            description: "Whether the evaluation result is an invalid one.",
            default: false
        },
        invalid_reason: {
            type: "string",
            title: "Invalid Reason",
            description: "Reason for invalid evaluation."
        }
    },
    type: "object",
    title: "LocalEval",
    description: `Evaluation result, EvaluationResult from llama_index.

Output of an BaseEvaluator.`
};
const $LocalEvalResults = {
    properties: {
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project."
        },
        eval_set_id: {
            type: "string",
            format: "uuid",
            title: "Eval Set Id",
            description: "The ID of the local eval result set."
        },
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        eval_name: {
            type: "string",
            title: "Eval Name",
            description: "The name of the eval."
        },
        result: {
            allOf: [
                {
                    $ref: "#/components/schemas/LocalEval"
                }
            ],
            title: "Result",
            description: "The eval results."
        }
    },
    type: "object",
    required: [
        "project_id",
        "app_name",
        "eval_name",
        "result"
    ],
    title: "LocalEvalResults",
    description: "Schema for the result of a local evaluation."
};
const $LocalEvalSetCreate = {
    properties: {
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        results: {
            additionalProperties: {
                items: {
                    $ref: "#/components/schemas/LocalEval"
                },
                type: "array"
            },
            type: "object",
            title: "Results",
            description: "The eval results."
        }
    },
    type: "object",
    required: [
        "app_name",
        "results"
    ],
    title: "LocalEvalSetCreate",
    description: "Schema for creating a local eval set."
};
const $LocalEvalSets = {
    properties: {
        eval_set_id: {
            type: "string",
            format: "uuid",
            title: "Eval Set Id",
            description: "The ID of the eval set."
        },
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        upload_time: {
            type: "string",
            format: "date-time",
            title: "Upload Time",
            description: "The time of the upload."
        }
    },
    type: "object",
    required: [
        "eval_set_id",
        "app_name",
        "upload_time"
    ],
    title: "LocalEvalSets"
};
const $ManagedIngestionStatus = {
    type: "string",
    enum: [
        "NOT_STARTED",
        "IN_PROGRESS",
        "SUCCESS",
        "ERROR",
        "PARTIAL_SUCCESS"
    ],
    title: "ManagedIngestionStatus",
    description: "Status of managed ingestion with partial Updates."
};
const $ManagedIngestionStatusResponse = {
    properties: {
        status: {
            allOf: [
                {
                    $ref: "#/components/schemas/ManagedIngestionStatus"
                }
            ],
            description: "Status of the ingestion."
        }
    },
    type: "object",
    required: [
        "status"
    ],
    title: "ManagedIngestionStatusResponse"
};
const $MarkdownElementNodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        llm: {
            allOf: [
                {
                    $ref: "#/components/schemas/LLM"
                }
            ],
            title: "Llm",
            description: "LLM model to use for summarization."
        },
        summary_query_str: {
            type: "string",
            title: "Summary Query Str",
            description: "Query string to use for summarization.",
            default: "What is this table about? Give a very concise summary (imagine you are adding a new caption and summary for this table), and output the real/existing table title/caption if context provided.and output the real/existing table id if context provided.and also output whether or not the table should be kept."
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "Num of workers for async jobs.",
            default: 4
        },
        show_progress: {
            type: "boolean",
            title: "Show Progress",
            description: "Whether to show progress.",
            default: true
        },
        nested_node_parser: {
            allOf: [
                {
                    $ref: "#/components/schemas/NodeParser"
                }
            ],
            title: "Nested Node Parser",
            description: "Other types of node parsers to handle some types of nodes."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "MarkdownElementNodeParser"
        }
    },
    type: "object",
    title: "MarkdownElementNodeParser",
    description: `Markdown element node parser.

Splits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects
(e.g. tables).`
};
const $MarkdownNodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "MarkdownNodeParser"
        }
    },
    type: "object",
    title: "MarkdownNodeParser",
    description: `Markdown node parser.

Splits a document into Nodes using custom Markdown splitting logic.

Args:
    include_metadata (bool): whether to include metadata in nodes
    include_prev_next_rel (bool): whether to include prev/next relationships`
};
const $MessageRole = {
    type: "string",
    enum: [
        "system",
        "user",
        "assistant",
        "function",
        "tool",
        "chatbot",
        "model"
    ],
    title: "MessageRole",
    description: "Message role."
};
const $MetadataFilter = {
    properties: {
        key: {
            type: "string",
            title: "Key"
        },
        value: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "number"
                },
                {
                    type: "string"
                },
                {
                    items: {
                        type: "string"
                    },
                    type: "array"
                },
                {
                    items: {
                        type: "number"
                    },
                    type: "array"
                },
                {
                    items: {
                        type: "integer"
                    },
                    type: "array"
                }
            ],
            title: "Value"
        },
        operator: {
            allOf: [
                {
                    $ref: "#/components/schemas/FilterOperator"
                }
            ],
            default: "=="
        }
    },
    type: "object",
    required: [
        "key",
        "value"
    ],
    title: "MetadataFilter",
    description: `Comprehensive metadata filter for vector stores to support more operators.

Value uses Strict* types, as int, float and str are compatible types and were all
converted to string before.

See: https://docs.pydantic.dev/latest/usage/types/#strict-types`
};
const $MetadataFilters = {
    properties: {
        filters: {
            items: {
                anyOf: [
                    {
                        $ref: "#/components/schemas/MetadataFilter"
                    },
                    {
                        $ref: "#/components/schemas/MetadataFilters"
                    }
                ]
            },
            type: "array",
            title: "Filters"
        },
        condition: {
            allOf: [
                {
                    $ref: "#/components/schemas/FilterCondition"
                }
            ],
            default: "and"
        }
    },
    type: "object",
    required: [
        "filters"
    ],
    title: "MetadataFilters",
    description: "Metadata filters for vector stores."
};
const $MetricResult = {
    properties: {
        passing: {
            type: "boolean",
            title: "Passing",
            description: "Whether the metric passed or not."
        },
        score: {
            type: "number",
            title: "Score",
            description: "The score for the metric."
        },
        feedback: {
            type: "string",
            title: "Feedback",
            description: "The reasoning for the metric."
        }
    },
    type: "object",
    title: "MetricResult"
};
const $NodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "NodeParser",
    description: "Base interface for node parser."
};
const $ObjectType = {
    type: "string",
    enum: [
        "1",
        "2",
        "3",
        "4"
    ],
    title: "ObjectType",
    description: "An enumeration."
};
const $OpenAIEmbedding = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the embedding model.",
            default: "unknown"
        },
        embed_batch_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10,
            lte: 2048
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the OpenAI API."
        },
        api_key: {
            type: "string",
            title: "Api Key",
            description: "The OpenAI API key."
        },
        api_base: {
            type: "string",
            title: "Api Base",
            description: "The base URL for OpenAI API.",
            default: "https://api.openai.com/v1"
        },
        api_version: {
            type: "string",
            title: "Api Version",
            description: "The version for OpenAI API.",
            default: ""
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            description: "Maximum number of retries.",
            default: 10,
            gte: 0
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "Timeout for each request.",
            default: 60,
            gte: 0
        },
        default_headers: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Default Headers",
            description: "The default headers for API requests."
        },
        reuse_client: {
            type: "boolean",
            title: "Reuse Client",
            description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
            default: true
        },
        dimensions: {
            type: "integer",
            title: "Dimensions",
            description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "OpenAIEmbedding"
        }
    },
    type: "object",
    required: [
        "api_key"
    ],
    title: "OpenAIEmbedding",
    description: `OpenAI class for embeddings.

Args:
    mode (str): Mode for embedding.
        Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.
        Options are:

        - OpenAIEmbeddingMode.SIMILARITY_MODE
        - OpenAIEmbeddingMode.TEXT_SEARCH_MODE

    model (str): Model for embedding.
        Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.
        Options are:

        - OpenAIEmbeddingModelType.DAVINCI
        - OpenAIEmbeddingModelType.CURIE
        - OpenAIEmbeddingModelType.BABBAGE
        - OpenAIEmbeddingModelType.ADA
        - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002`
};
const $Organization = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    required: [
        "id",
        "name"
    ],
    title: "Organization",
    description: "Schema for an organization."
};
const $OrganizationCreate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "OrganizationCreate",
    description: "Schema for creating an organization."
};
const $OrganizationUpdate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    title: "OrganizationUpdate",
    description: "Schema for updating an organization."
};
const $ParserLanguages = {
    type: "string",
    enum: [
        "af",
        "az",
        "bs",
        "cs",
        "cy",
        "da",
        "de",
        "en",
        "es",
        "et",
        "fr",
        "ga",
        "hr",
        "hu",
        "id",
        "is",
        "it",
        "ku",
        "la",
        "lt",
        "lv",
        "mi",
        "ms",
        "mt",
        "nl",
        "no",
        "oc",
        "pi",
        "pl",
        "pt",
        "ro",
        "rs_latin",
        "sk",
        "sl",
        "sq",
        "sv",
        "sw",
        "tl",
        "tr",
        "uz",
        "vi",
        "ar",
        "fa",
        "ug",
        "ur",
        "bn",
        "as",
        "mni",
        "ru",
        "rs_cyrillic",
        "be",
        "bg",
        "uk",
        "mn",
        "abq",
        "ady",
        "kbd",
        "ava",
        "dar",
        "inh",
        "che",
        "lbe",
        "lez",
        "tab",
        "tjk",
        "hi",
        "mr",
        "ne",
        "bh",
        "mai",
        "ang",
        "bho",
        "mah",
        "sck",
        "new",
        "gom",
        "sa",
        "bgc",
        "th",
        "ch_sim",
        "ch_tra",
        "ja",
        "ko",
        "ta",
        "te",
        "kn"
    ],
    title: "ParserLanguages",
    description: "Enum for representing the languages supported by the parser"
};
const $ParsingHistoryItem = {
    properties: {
        user_id: {
            type: "string",
            title: "User Id"
        },
        day: {
            type: "string",
            title: "Day"
        },
        job_id: {
            type: "string",
            title: "Job Id"
        },
        file_name: {
            type: "string",
            title: "File Name"
        },
        original_file_name: {
            type: "string",
            title: "Original File Name"
        },
        expired: {
            type: "boolean",
            title: "Expired",
            default: false
        },
        pages: {
            type: "number",
            title: "Pages"
        },
        images: {
            type: "number",
            title: "Images"
        },
        time: {
            type: "number",
            title: "Time"
        }
    },
    type: "object",
    required: [
        "user_id",
        "day",
        "job_id",
        "file_name",
        "original_file_name"
    ],
    title: "ParsingHistoryItem"
};
const $ParsingJob = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id"
        },
        status: {
            $ref: "#/components/schemas/StatusEnum"
        }
    },
    type: "object",
    required: [
        "id",
        "status"
    ],
    title: "ParsingJob"
};
const $ParsingJobJsonResult = {
    properties: {
        pages: {
            title: "Pages",
            description: "The json result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    title: "ParsingJobJsonResult"
};
const $ParsingJobMarkdownResult = {
    properties: {
        markdown: {
            type: "string",
            title: "Markdown",
            description: "The markdown result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    required: [
        "markdown"
    ],
    title: "ParsingJobMarkdownResult"
};
const $ParsingJobTextResult = {
    properties: {
        text: {
            type: "string",
            title: "Text",
            description: "The text result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    required: [
        "text"
    ],
    title: "ParsingJobTextResult"
};
const $ParsingUsage = {
    properties: {
        usage_pdf_pages: {
            type: "integer",
            title: "Usage Pdf Pages"
        },
        max_pdf_pages: {
            type: "integer",
            title: "Max Pdf Pages"
        }
    },
    type: "object",
    required: [
        "usage_pdf_pages",
        "max_pdf_pages"
    ],
    title: "ParsingUsage"
};
const $Pipeline = {
    properties: {
        configured_transformations: {
            items: {
                $ref: "#/components/schemas/ConfiguredTransformationItem"
            },
            type: "array",
            title: "Configured Transformations"
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        },
        pipeline_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/PipelineType"
                }
            ],
            description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
            default: "MANAGED"
        },
        managed_pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        },
        preset_retrieval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/PresetRetrievalParams"
                }
            ],
            title: "Preset Retrieval Parameters",
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                }
            ],
            title: "Eval Parameters",
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/LlamaParseParameters"
                }
            ],
            title: "Llama Parse Parameters",
            description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
        },
        data_sink: {
            allOf: [
                {
                    $ref: "#/components/schemas/DataSink"
                }
            ],
            title: "Data Sink",
            description: "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink."
        }
    },
    type: "object",
    required: [
        "configured_transformations",
        "id",
        "name",
        "project_id"
    ],
    title: "Pipeline",
    description: "Schema for a pipeline."
};
const $PipelineCreate = {
    properties: {
        embedding_config: {
            allOf: [
                {
                    $ref: "#/components/schemas/EmbeddingConfig"
                }
            ],
            title: "Embedding Config",
            description: "Configuration for the embedding model."
        },
        transform_config: {
            allOf: [
                {
                    $ref: "#/components/schemas/TransformConfig"
                }
            ],
            title: "Transform Config",
            description: "Configuration for the transformation."
        },
        configured_transformations: {
            items: {
                $ref: "#/components/schemas/ConfiguredTransformationItem"
            },
            type: "array",
            title: "Configured Transformations",
            description: "List of configured transformations."
        },
        data_sink_id: {
            type: "string",
            format: "uuid",
            title: "Data Sink Id",
            description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID."
        },
        data_sink: {
            allOf: [
                {
                    $ref: "#/components/schemas/DataSinkCreate"
                }
            ],
            title: "Data Sink",
            description: "Data sink. When provided instead of data_sink_id, the data sink will be created."
        },
        preset_retrieval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/PresetRetrievalParams"
                }
            ],
            title: "Preset Retrieval Parameters",
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                }
            ],
            title: "Eval Parameters",
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/LlamaParseParameters"
                }
            ],
            title: "Llama Parse Parameters",
            description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        pipeline_type: {
            allOf: [
                {
                    $ref: "#/components/schemas/PipelineType"
                }
            ],
            description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
            default: "MANAGED"
        },
        managed_pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "PipelineCreate",
    description: "Schema for creating a pipeline."
};
const $PipelineDataSource = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    anyOf: [
                        {
                            $ref: "#/components/schemas/CloudS3DataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudOneDriveDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSharepointDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudSlackDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudNotionPageDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudConfluenceDataSource"
                        },
                        {
                            $ref: "#/components/schemas/CloudJiraDataSource"
                        }
                    ]
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        },
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source."
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline."
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "source_type",
        "component",
        "project_id",
        "data_source_id",
        "pipeline_id"
    ],
    title: "PipelineDataSource",
    description: "Schema for a data source in a pipeline."
};
const $PipelineDataSourceCreate = {
    properties: {
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source."
        }
    },
    type: "object",
    required: [
        "data_source_id"
    ],
    title: "PipelineDataSourceCreate",
    description: "Schema for creating an association between a data source and a pipeline."
};
const $PipelineDeployment = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        status: {
            allOf: [
                {
                    $ref: "#/components/schemas/ManagedIngestionStatus"
                }
            ],
            description: "Status of the pipeline deployment."
        },
        started_at: {
            type: "string",
            format: "date-time",
            title: "Started At",
            description: "Time the pipeline deployment started."
        },
        ended_at: {
            type: "string",
            format: "date-time",
            title: "Ended At",
            description: "Time the pipeline deployment finished."
        }
    },
    type: "object",
    required: [
        "id",
        "status"
    ],
    title: "PipelineDeployment",
    description: "Base schema model containing common database fields."
};
const $PipelineFile = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        file_size: {
            type: "integer",
            minimum: 0,
            title: "File Size",
            description: "Size of the file in bytes"
        },
        file_type: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "File Type",
            description: "File type (e.g. pdf, docx, etc.)"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the file belongs to"
        },
        last_modified_at: {
            type: "string",
            format: "date-time",
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        },
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The ID of the file"
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the file is associated with"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        }
    },
    type: "object",
    required: [
        "id",
        "project_id",
        "pipeline_id"
    ],
    title: "PipelineFile",
    description: "Schema for a file that is associated with a pipeline."
};
const $PipelineFileCreate = {
    properties: {
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The ID of the file"
        },
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        }
    },
    type: "object",
    required: [
        "file_id"
    ],
    title: "PipelineFileCreate",
    description: "Schema for creating a file that is associated with a pipeline."
};
const $PipelineFileUpdate = {
    properties: {
        custom_metadata: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    }
                ]
            },
            type: "object",
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        }
    },
    type: "object",
    title: "PipelineFileUpdate",
    description: "Schema for updating a file that is associated with a pipeline."
};
const $PipelineType = {
    type: "string",
    enum: [
        "PLAYGROUND",
        "MANAGED"
    ],
    title: "PipelineType",
    description: "Enum for representing the type of a pipeline"
};
const $PipelineUpdate = {
    properties: {
        embedding_config: {
            allOf: [
                {
                    $ref: "#/components/schemas/EmbeddingConfig"
                }
            ],
            title: "Embedding Config",
            description: "Configuration for the embedding model."
        },
        transform_config: {
            allOf: [
                {
                    $ref: "#/components/schemas/TransformConfig"
                }
            ],
            title: "Transform Config",
            description: "Configuration for the transformation."
        },
        configured_transformations: {
            items: {
                $ref: "#/components/schemas/ConfiguredTransformationItem"
            },
            type: "array",
            title: "Configured Transformations",
            description: "List of configured transformations."
        },
        data_sink_id: {
            type: "string",
            format: "uuid",
            title: "Data Sink Id",
            description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID."
        },
        data_sink: {
            allOf: [
                {
                    $ref: "#/components/schemas/DataSinkCreate"
                }
            ],
            title: "Data Sink",
            description: "Data sink. When provided instead of data_sink_id, the data sink will be created."
        },
        preset_retrieval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/PresetRetrievalParams"
                }
            ],
            title: "Preset Retrieval Parameters",
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                }
            ],
            title: "Eval Parameters",
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            allOf: [
                {
                    $ref: "#/components/schemas/LlamaParseParameters"
                }
            ],
            title: "Llama Parse Parameters",
            description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
        },
        name: {
            type: "string",
            title: "Name"
        },
        managed_pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        }
    },
    type: "object",
    title: "PipelineUpdate",
    description: "Schema for updating a pipeline."
};
const $Pooling = {
    type: "string",
    enum: [
        "cls",
        "mean",
        "last"
    ],
    title: "Pooling",
    description: "Enum of possible pooling choices with pooling behaviors."
};
const $PresetRetrievalParams = {
    properties: {
        dense_similarity_top_k: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Dense Similarity Top K",
            description: "Number of nodes for dense retrieval.",
            default: 30
        },
        sparse_similarity_top_k: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Sparse Similarity Top K",
            description: "Number of nodes for sparse retrieval.",
            default: 30
        },
        enable_reranking: {
            type: "boolean",
            title: "Enable Reranking",
            description: "Enable reranking for retrieval",
            default: true
        },
        rerank_top_n: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Rerank Top N",
            description: "Number of reranked nodes for returning.",
            default: 3
        },
        alpha: {
            type: "number",
            maximum: 1,
            minimum: 0,
            title: "Alpha",
            description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
            default: 0.5
        },
        search_filters: {
            allOf: [
                {
                    $ref: "#/components/schemas/MetadataFilters"
                }
            ],
            title: "Search Filters",
            description: "Search filters for retrieval."
        },
        files_top_k: {
            type: "integer",
            maximum: 5,
            minimum: 1,
            title: "Files Top K",
            description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
            default: 1
        },
        retrieval_mode: {
            allOf: [
                {
                    $ref: "#/components/schemas/RetrievalMode"
                }
            ],
            description: "The retrieval mode for the query.",
            default: "chunks"
        }
    },
    type: "object",
    title: "PresetRetrievalParams",
    description: "Schema for the search params for an retrieval execution that can be preset for a pipeline."
};
const $PresignedUrl = {
    properties: {
        url: {
            type: "string",
            maxLength: 65536,
            minLength: 1,
            format: "uri",
            title: "Url",
            description: "A presigned URL for IO operations against a private file"
        },
        expires_at: {
            type: "string",
            format: "date-time",
            title: "Expires At",
            description: "The time at which the presigned URL expires"
        },
        form_fields: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Form Fields",
            description: "Form fields for a presigned POST request"
        }
    },
    type: "object",
    required: [
        "url",
        "expires_at"
    ],
    title: "PresignedUrl",
    description: "Schema for a presigned URL."
};
const $Project = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        ad_hoc_eval_dataset_id: {
            type: "string",
            format: "uuid",
            title: "Ad Hoc Eval Dataset Id"
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The Organization ID the project is under."
        },
        is_default: {
            type: "boolean",
            title: "Is Default",
            description: "Whether this project is the default project for the user.",
            default: false
        }
    },
    type: "object",
    required: [
        "name",
        "id",
        "organization_id"
    ],
    title: "Project",
    description: "Schema for a project."
};
const $ProjectCreate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "ProjectCreate",
    description: "Schema for creating a project."
};
const $ProjectUpdate = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "ProjectUpdate",
    description: "Schema for updating a project."
};
const $PromptMixinPrompts = {
    properties: {
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project."
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "The ID of the prompt set."
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the prompt set."
        },
        prompts: {
            items: {
                $ref: "#/components/schemas/PromptSpec"
            },
            type: "array",
            title: "Prompts",
            description: "The prompts."
        }
    },
    type: "object",
    required: [
        "project_id",
        "name",
        "prompts"
    ],
    title: "PromptMixinPrompts",
    description: "Schema for the prompts derived from the PromptMixin."
};
const $PromptSpec = {
    properties: {
        prompt_key: {
            type: "string",
            title: "Prompt Key",
            description: "The key of the prompt in the PromptMixin."
        },
        prompt_class: {
            type: "string",
            title: "Prompt Class",
            description: "The class of the prompt (PromptTemplate or ChatPromptTemplate)."
        },
        prompt_type: {
            type: "string",
            title: "Prompt Type",
            description: "The type of prompt."
        },
        template: {
            type: "string",
            title: "Template",
            description: "The template of the prompt."
        },
        message_templates: {
            items: {
                $ref: "#/components/schemas/ChatMessage"
            },
            type: "array",
            title: "Message Templates",
            description: "The chat message templates of the prompt."
        }
    },
    type: "object",
    required: [
        "prompt_key",
        "prompt_class",
        "prompt_type"
    ],
    title: "PromptSpec"
};
const $PydanticProgramMode = {
    type: "string",
    enum: [
        "default",
        "openai",
        "llm",
        "function",
        "guidance",
        "lm-format-enforcer"
    ],
    title: "PydanticProgramMode",
    description: "Pydantic program mode."
};
const $RelatedNodeInfo = {
    properties: {
        node_id: {
            type: "string",
            title: "Node Id"
        },
        node_type: {
            $ref: "#/components/schemas/ObjectType"
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        hash: {
            type: "string",
            title: "Hash"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "RelatedNodeInfo"
        }
    },
    type: "object",
    required: [
        "node_id"
    ],
    title: "RelatedNodeInfo",
    description: "Base component object to capture class names."
};
const $RetrievalMode = {
    type: "string",
    enum: [
        "chunks",
        "files_via_metadata",
        "files_via_content"
    ],
    title: "RetrievalMode",
    description: "An enumeration."
};
const $RetrievalParams = {
    properties: {
        dense_similarity_top_k: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Dense Similarity Top K",
            description: "Number of nodes for dense retrieval.",
            default: 30
        },
        sparse_similarity_top_k: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Sparse Similarity Top K",
            description: "Number of nodes for sparse retrieval.",
            default: 30
        },
        enable_reranking: {
            type: "boolean",
            title: "Enable Reranking",
            description: "Enable reranking for retrieval",
            default: true
        },
        rerank_top_n: {
            type: "integer",
            maximum: 100,
            minimum: 1,
            title: "Rerank Top N",
            description: "Number of reranked nodes for returning.",
            default: 3
        },
        alpha: {
            type: "number",
            maximum: 1,
            minimum: 0,
            title: "Alpha",
            description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
            default: 0.5
        },
        search_filters: {
            allOf: [
                {
                    $ref: "#/components/schemas/MetadataFilters"
                }
            ],
            title: "Search Filters",
            description: "Search filters for retrieval."
        },
        files_top_k: {
            type: "integer",
            maximum: 5,
            minimum: 1,
            title: "Files Top K",
            description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
            default: 1
        },
        retrieval_mode: {
            allOf: [
                {
                    $ref: "#/components/schemas/RetrievalMode"
                }
            ],
            description: "The retrieval mode for the query.",
            default: "chunks"
        },
        query: {
            type: "string",
            title: "Query",
            description: "The query to retrieve against."
        }
    },
    type: "object",
    required: [
        "query"
    ],
    title: "RetrievalParams",
    description: "Schema for the search params for an retrieval execution."
};
const $RetrieveResults = {
    properties: {
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the query was retrieved against."
        },
        retrieval_nodes: {
            items: {
                $ref: "#/components/schemas/TextNodeWithScore"
            },
            type: "array",
            title: "Retrieval Nodes",
            description: "The nodes retrieved by the pipeline for the given query."
        },
        retrieval_latency: {
            additionalProperties: {
                type: "number"
            },
            type: "object",
            title: "Retrieval Latency",
            description: "The end-to-end latency for retrieval and reranking."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "RetrieveResults"
        }
    },
    type: "object",
    required: [
        "pipeline_id",
        "retrieval_nodes",
        "retrieval_latency"
    ],
    title: "RetrieveResults",
    description: "Schema for the result of an retrieval execution."
};
const $SentenceSplitter = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "The token chunk size for each chunk.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            description: "The token overlap of each chunk when splitting.",
            default: 200,
            gte: 0
        },
        separator: {
            type: "string",
            title: "Separator",
            description: "Default separator for splitting into words",
            default: " "
        },
        paragraph_separator: {
            type: "string",
            title: "Paragraph Separator",
            description: "Separator between paragraphs.",
            default: `


`
        },
        secondary_chunking_regex: {
            type: "string",
            title: "Secondary Chunking Regex",
            description: "Backup regex for splitting into sentences.",
            default: "[^,.;]+[,.;]?"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "SentenceSplitter"
        }
    },
    type: "object",
    title: "SentenceSplitter",
    description: `Parse text with a preference for complete sentences.

In general, this class tries to keep sentences and paragraphs together. Therefore
compared to the original TokenTextSplitter, there are less likely to be
hanging sentences or parts of sentences at the end of the node chunk.`
};
const $SimpleFileNodeParser = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "SimpleFileNodeParser"
        }
    },
    type: "object",
    title: "SimpleFileNodeParser",
    description: `Simple file node parser.

Splits a document loaded from a file into Nodes using logic based on the file type
automatically detects the NodeParser to use based on file type

Args:
    include_metadata (bool): whether to include metadata in nodes
    include_prev_next_rel (bool): whether to include prev/next relationships`
};
const $StatusEnum = {
    type: "string",
    enum: [
        "PENDING",
        "SUCCESS",
        "ERROR",
        "PARTIAL_SUCCESS"
    ],
    title: "StatusEnum",
    description: "Enum for representing the status of a job"
};
const $SupportedEvalLLMModel = {
    properties: {
        name: {
            allOf: [
                {
                    $ref: "#/components/schemas/SupportedEvalLLMModelNames"
                }
            ],
            description: "The name of the supported eval LLM model."
        },
        details: {
            allOf: [
                {
                    $ref: "#/components/schemas/EvalLLMModelData"
                }
            ],
            title: "Details",
            description: "The details of the supported eval LLM model."
        }
    },
    type: "object",
    required: [
        "name",
        "details"
    ],
    title: "SupportedEvalLLMModel",
    description: "Response Schema for a supported eval LLM model."
};
const $SupportedEvalLLMModelNames = {
    type: "string",
    enum: [
        "GPT_3_5_TURBO",
        "GPT_4",
        "GPT_4_TURBO"
    ],
    title: "SupportedEvalLLMModelNames",
    description: "An enumeration."
};
const $TextNode = {
    properties: {
        id_: {
            type: "string",
            title: "Id ",
            description: "Unique ID of the node."
        },
        embedding: {
            items: {
                type: "number"
            },
            type: "array",
            title: "Embedding",
            description: "Embedding of the node."
        },
        extra_info: {
            type: "object",
            title: "Extra Info",
            description: "A flat dictionary of metadata fields"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            description: "Metadata keys that are excluded from text for the embed model."
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            description: "Metadata keys that are excluded from text for the LLM."
        },
        relationships: {
            additionalProperties: {
                anyOf: [
                    {
                        $ref: "#/components/schemas/RelatedNodeInfo"
                    },
                    {
                        items: {
                            $ref: "#/components/schemas/RelatedNodeInfo"
                        },
                        type: "array"
                    }
                ]
            },
            type: "object",
            title: "Relationships",
            description: "A mapping of relationships to other node information."
        },
        text: {
            type: "string",
            title: "Text",
            description: "Text content of the node.",
            default: ""
        },
        mimetype: {
            type: "string",
            title: "Mimetype",
            description: "MIME type of the node content.",
            default: "text/plain"
        },
        start_char_idx: {
            type: "integer",
            title: "Start Char Idx",
            description: "Start char index of the node."
        },
        end_char_idx: {
            type: "integer",
            title: "End Char Idx",
            description: "End char index of the node."
        },
        text_template: {
            type: "string",
            title: "Text Template",
            description: "Template for how text is formatted, with {content} and {metadata_str} placeholders.",
            default: `{metadata_str}

{content}`
        },
        metadata_template: {
            type: "string",
            title: "Metadata Template",
            description: "Template for how metadata is formatted, with {key} and {value} placeholders.",
            default: "{key}: {value}"
        },
        metadata_seperator: {
            type: "string",
            title: "Metadata Seperator",
            description: "Separator between metadata fields when converting to string.",
            default: `
`
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "TextNode"
        }
    },
    type: "object",
    title: "TextNode",
    description: `Base node Object.

Generic abstract interface for retrievable nodes`
};
const $TextNodeWithScore = {
    properties: {
        node: {
            $ref: "#/components/schemas/TextNode"
        },
        score: {
            type: "number",
            title: "Score"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "NodeWithScore"
        }
    },
    type: "object",
    required: [
        "node"
    ],
    title: "TextNodeWithScore",
    description: `Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
FastAPI doesn't accept abstract classes like BaseNode.`
};
const $TokenTextSplitter = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            type: "object",
            title: "Callback Manager",
            default: {}
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "The token chunk size for each chunk.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            description: "The token overlap of each chunk when splitting.",
            default: 20,
            gte: 0
        },
        separator: {
            type: "string",
            title: "Separator",
            description: "Default separator for splitting into words",
            default: " "
        },
        backup_separators: {
            items: {},
            type: "array",
            title: "Backup Separators",
            description: "Additional separators for splitting."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "TokenTextSplitter"
        }
    },
    type: "object",
    title: "TokenTextSplitter",
    description: "Implementation of splitting text that looks at word tokens."
};
const $TransformConfig = {
    properties: {
        mode: {
            allOf: [
                {
                    $ref: "#/components/schemas/TransformConfigMode"
                }
            ],
            description: "Mode for the transformation configuration.",
            default: "AUTO"
        },
        config: {
            allOf: [
                {
                    $ref: "#/components/schemas/AutoTransformConfig"
                }
            ],
            title: "Config",
            description: "Configuration for the transformation."
        }
    },
    type: "object",
    title: "TransformConfig"
};
const $TransformConfigMode = {
    type: "string",
    enum: [
        "AUTO",
        "ADVANCED"
    ],
    title: "TransformConfigMode",
    description: "An enumeration."
};
const $TransformationCategoryNames = {
    type: "string",
    enum: [
        "NODE_PARSER",
        "EMBEDDING"
    ],
    title: "TransformationCategoryNames",
    description: "An enumeration."
};
const $UserOrganization = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        email: {
            type: "string",
            format: "email",
            title: "Email",
            description: "The user's email address."
        },
        user_id: {
            type: "string",
            title: "User Id",
            description: "The user's ID."
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        },
        pending: {
            type: "boolean",
            title: "Pending",
            description: "Whether the user's membership is pending account signup.",
            default: true
        },
        invited_by_user_id: {
            type: "string",
            title: "Invited By User Id",
            description: "The user ID of the user who added the user to the organization."
        },
        invited_by_user_email: {
            type: "string",
            format: "email",
            title: "Invited By User Email",
            description: "The email address of the user who added the user to the organization."
        }
    },
    type: "object",
    required: [
        "id",
        "email",
        "organization_id"
    ],
    title: "UserOrganization",
    description: "Schema for a user's membership to an organization."
};
const $UserOrganizationCreate = {
    properties: {
        user_id: {
            type: "string",
            title: "User Id",
            description: "The user's ID."
        },
        email: {
            type: "string",
            format: "email",
            title: "Email",
            description: "The user's email address."
        }
    },
    type: "object",
    title: "UserOrganizationCreate",
    description: "Schema for creating a user's membership to an organization."
};
const $UserOrganizationDelete = {
    properties: {
        user_id: {
            type: "string",
            title: "User Id",
            description: "The user's ID."
        },
        email: {
            type: "string",
            format: "email",
            title: "Email",
            description: "The user's email address."
        }
    },
    type: "object",
    title: "UserOrganizationDelete",
    description: "Schema for deleting a user's membership to an organization."
};
const $ValidationError = {
    properties: {
        loc: {
            items: {
                anyOf: [
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    }
                ]
            },
            type: "array",
            title: "Location"
        },
        msg: {
            type: "string",
            title: "Message"
        },
        type: {
            type: "string",
            title: "Error Type"
        }
    },
    type: "object",
    required: [
        "loc",
        "msg",
        "type"
    ],
    title: "ValidationError"
};

const isString = (value)=>{
    return typeof value === "string";
};
const isStringWithValue = (value)=>{
    return isString(value) && value !== "";
};
const isBlob = (value)=>{
    return value instanceof Blob;
};
const isFormData = (value)=>{
    return value instanceof FormData;
};
const base64 = (str)=>{
    try {
        return btoa(str);
    } catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString("base64");
    }
};
const getQueryString = (params)=>{
    const qs = [];
    const append = (key, value)=>{
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    const encodePair = (key, value)=>{
        if (value === undefined || value === null) {
            return;
        }
        if (value instanceof Date) {
            append(key, value.toISOString());
        } else if (Array.isArray(value)) {
            value.forEach((v)=>encodePair(key, v));
        } else if (typeof value === "object") {
            Object.entries(value).forEach(([k, v])=>encodePair(`${key}[${k}]`, v));
        } else {
            append(key, value);
        }
    };
    Object.entries(params).forEach(([key, value])=>encodePair(key, value));
    return qs.length ? `?${qs.join("&")}` : "";
};
const getUrl = (config, options)=>{
    const encoder = config.ENCODE_PATH || encodeURI;
    const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group)=>{
        if (options.path?.hasOwnProperty(group)) {
            return encoder(String(options.path[group]));
        }
        return substring;
    });
    const url = config.BASE + path;
    return options.query ? url + getQueryString(options.query) : url;
};
const getFormData = (options)=>{
    if (options.formData) {
        const formData = new FormData();
        const process = (key, value)=>{
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            } else {
                formData.append(key, JSON.stringify(value));
            }
        };
        Object.entries(options.formData).filter(([, value])=>value !== undefined && value !== null).forEach(([key, value])=>{
            if (Array.isArray(value)) {
                value.forEach((v)=>process(key, v));
            } else {
                process(key, value);
            }
        });
        return formData;
    }
    return undefined;
};
const resolve = async (options, resolver)=>{
    if (typeof resolver === "function") {
        return resolver(options);
    }
    return resolver;
};
const getHeaders = async (config, options)=>{
    const [token, username, password, additionalHeaders] = await Promise.all([
        // @ts-ignore
        resolve(options, config.TOKEN),
        // @ts-ignore
        resolve(options, config.USERNAME),
        // @ts-ignore
        resolve(options, config.PASSWORD),
        // @ts-ignore
        resolve(options, config.HEADERS)
    ]);
    const headers = Object.entries({
        Accept: "application/json",
        ...additionalHeaders,
        ...options.headers
    }).filter(([, value])=>value !== undefined && value !== null).reduce((headers, [key, value])=>({
            ...headers,
            [key]: String(value)
        }), {});
    if (isStringWithValue(token)) {
        headers["Authorization"] = `Bearer ${token}`;
    }
    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers["Authorization"] = `Basic ${credentials}`;
    }
    if (options.body !== undefined) {
        if (options.mediaType) {
            headers["Content-Type"] = options.mediaType;
        } else if (isBlob(options.body)) {
            headers["Content-Type"] = options.body.type || "application/octet-stream";
        } else if (isString(options.body)) {
            headers["Content-Type"] = "text/plain";
        } else if (!isFormData(options.body)) {
            headers["Content-Type"] = "application/json";
        }
    }
    return new Headers(headers);
};
const getRequestBody = (options)=>{
    if (options.body !== undefined) {
        if (options.mediaType?.includes("application/json") || options.mediaType?.includes("+json")) {
            return JSON.stringify(options.body);
        } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
            return options.body;
        } else {
            return JSON.stringify(options.body);
        }
    }
    return undefined;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel)=>{
    const controller = new AbortController();
    let request = {
        headers,
        body: body ?? formData,
        method: options.method,
        signal: controller.signal
    };
    if (config.WITH_CREDENTIALS) {
        request.credentials = config.CREDENTIALS;
    }
    for (const fn of config.interceptors.request._fns){
        request = await fn(request);
    }
    onCancel(()=>controller.abort());
    return await fetch(url, request);
};
const getResponseHeader = (response, responseHeader)=>{
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};
const getResponseBody = async (response)=>{
    if (response.status !== 204) {
        try {
            const contentType = response.headers.get("Content-Type");
            if (contentType) {
                const binaryTypes = [
                    "application/octet-stream",
                    "application/pdf",
                    "application/zip",
                    "audio/",
                    "image/",
                    "video/"
                ];
                if (contentType.includes("application/json") || contentType.includes("+json")) {
                    return await response.json();
                } else if (binaryTypes.some((type)=>contentType.includes(type))) {
                    return await response.blob();
                } else if (contentType.includes("multipart/form-data")) {
                    return await response.formData();
                } else if (contentType.includes("text/")) {
                    return await response.text();
                }
            }
        } catch (error) {
            console.error(error);
        }
    }
    return undefined;
};
const catchErrorCodes = (options, result)=>{
    const errors = {
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "Im a teapot",
        421: "Misdirected Request",
        422: "Unprocessable Content",
        423: "Locked",
        424: "Failed Dependency",
        425: "Too Early",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        510: "Not Extended",
        511: "Network Authentication Required",
        ...options.errors
    };
    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }
    if (!result.ok) {
        const errorStatus = result.status ?? "unknown";
        const errorStatusText = result.statusText ?? "unknown";
        const errorBody = (()=>{
            try {
                return JSON.stringify(result.body, null, 2);
            } catch (e) {
                return undefined;
            }
        })();
        throw new ApiError(options, result, `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`);
    }
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */ const request = (config, options)=>{
    return new CancelablePromise(async (resolve, reject, onCancel)=>{
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options);
            if (!onCancel.isCancelled) {
                let response = await sendRequest(config, options, url, body, formData, headers, onCancel);
                for (const fn of config.interceptors.response._fns){
                    response = await fn(response);
                }
                const responseBody = await getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);
                let transformedBody = responseBody;
                if (options.responseTransformer && response.ok) {
                    transformedBody = await options.responseTransformer(responseBody);
                }
                const result = {
                    url,
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? transformedBody
                };
                catchErrorCodes(options, result);
                resolve(result.body);
            }
        } catch (error) {
            reject(error);
        }
    });
};

// This file is auto-generated by @hey-api/openapi-ts
class ApiKeysService {
    /**
   * List Keys
   * List API Keys for a user.
   * @param data The data for the request.
   * @param data.session
   * @returns APIKey Successful Response
   * @throws ApiError
   */ static listKeysApiV1ApiKeysGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/api-keys",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Generate Key
   * Generate a new API Key.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns APIKey Successful Response
   * @throws ApiError
   */ static generateKeyApiV1ApiKeysPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/api-keys",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Existing Api Key
   * Update name of an existing API Key.
   * @param data The data for the request.
   * @param data.apiKeyId
   * @param data.requestBody
   * @param data.session
   * @returns APIKey Successful Response
   * @throws ApiError
   */ static updateExistingApiKeyApiV1ApiKeysApiKeyIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/api-keys/{api_key_id}",
            path: {
                api_key_id: data.apiKeyId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Api Key
   * Delete an API Key by ID.
   * @param data The data for the request.
   * @param data.apiKeyId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteApiKeyApiV1ApiKeysApiKeyIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/api-keys/{api_key_id}",
            path: {
                api_key_id: data.apiKeyId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class DataSinksService {
    /**
   * List Data Sinks
   * List data sinks for a given project.
   * If project_id is not provided, uses the default project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns DataSink Successful Response
   * @throws ApiError
   */ static listDataSinksApiV1DataSinksGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/data-sinks",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Data Sink
   * Upserts a data sink.
   * Updates if a data sink with the same name and project_id already exists. Otherwise, creates a new data sink.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.organizationId
   * @param data.session
   * @returns DataSink Successful Response
   * @throws ApiError
   */ static upsertDataSinkApiV1DataSinksPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/data-sinks",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId,
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Data Sink
   * Create a new data sink.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.organizationId
   * @param data.session
   * @returns DataSink Successful Response
   * @throws ApiError
   */ static createDataSinkApiV1DataSinksPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/data-sinks",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId,
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Data Sink
   * Get a data sink by ID.
   * @param data The data for the request.
   * @param data.dataSinkId
   * @param data.session
   * @returns DataSink Successful Response
   * @throws ApiError
   */ static getDataSinkApiV1DataSinksDataSinkIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/data-sinks/{data_sink_id}",
            path: {
                data_sink_id: data.dataSinkId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Data Sink
   * Update a data sink by ID.
   * @param data The data for the request.
   * @param data.dataSinkId
   * @param data.requestBody
   * @param data.session
   * @returns DataSink Successful Response
   * @throws ApiError
   */ static updateDataSinkApiV1DataSinksDataSinkIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/data-sinks/{data_sink_id}",
            path: {
                data_sink_id: data.dataSinkId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Data Sink
   * Delete a data sink by ID.
   * @param data The data for the request.
   * @param data.dataSinkId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteDataSinkApiV1DataSinksDataSinkIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/data-sinks/{data_sink_id}",
            path: {
                data_sink_id: data.dataSinkId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class DataSourcesService {
    /**
   * List Data Sources
   * List data sources for a given project.
   * If project_id is not provided, uses the default project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.organizationId
   * @param data.session
   * @returns DataSource Successful Response
   * @throws ApiError
   */ static listDataSourcesApiV1DataSourcesGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/data-sources",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId,
                organization_id: data.organizationId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Data Source
   * Upserts a data source.
   * Updates if a data source with the same name and project_id already exists. Otherwise, creates a new data source.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.organizationId
   * @param data.session
   * @returns DataSource Successful Response
   * @throws ApiError
   */ static upsertDataSourceApiV1DataSourcesPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/data-sources",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId,
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Data Source
   * Create a new data source.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.organizationId
   * @param data.session
   * @returns DataSource Successful Response
   * @throws ApiError
   */ static createDataSourceApiV1DataSourcesPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/data-sources",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId,
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Data Source
   * Get a data source by ID.
   * @param data The data for the request.
   * @param data.dataSourceId
   * @param data.session
   * @returns DataSource Successful Response
   * @throws ApiError
   */ static getDataSourceApiV1DataSourcesDataSourceIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/data-sources/{data_source_id}",
            path: {
                data_source_id: data.dataSourceId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Data Source
   * Update a data source by ID.
   * @param data The data for the request.
   * @param data.dataSourceId
   * @param data.requestBody
   * @param data.session
   * @returns DataSource Successful Response
   * @throws ApiError
   */ static updateDataSourceApiV1DataSourcesDataSourceIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/data-sources/{data_source_id}",
            path: {
                data_source_id: data.dataSourceId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Data Source
   * Delete a data source by ID.
   * @param data The data for the request.
   * @param data.dataSourceId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteDataSourceApiV1DataSourcesDataSourceIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/data-sources/{data_source_id}",
            path: {
                data_source_id: data.dataSourceId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class OrganizationsService {
    /**
   * List Organizations
   * List organizations for a user.
   * @param data The data for the request.
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static listOrganizationsApiV1OrganizationsGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/organizations",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Organization
   * Upsert a new organization.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static upsertOrganizationApiV1OrganizationsPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/organizations",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Organization
   * Create a new organization.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static createOrganizationApiV1OrganizationsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/organizations",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Default Organization
   * Get the default organization for the user.
   * @param data The data for the request.
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static getDefaultOrganizationApiV1OrganizationsDefaultGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/organizations/default",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Set Default Organization
   * Set the default organization for the user.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static setDefaultOrganizationApiV1OrganizationsDefaultPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/organizations/default",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Organization
   * Get an organization by ID.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static getOrganizationApiV1OrganizationsOrganizationIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/organizations/{organization_id}",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Organization
   * Update an existing organization.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.requestBody
   * @param data.session
   * @returns Organization Successful Response
   * @throws ApiError
   */ static updateOrganizationApiV1OrganizationsOrganizationIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/organizations/{organization_id}",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Organization
   * Delete an organization by ID.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteOrganizationApiV1OrganizationsOrganizationIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/organizations/{organization_id}",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Organization Users
   * Get all users in an organization.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.session
   * @returns UserOrganization Successful Response
   * @throws ApiError
   */ static listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/organizations/{organization_id}/users",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Add Users To Organization
   * Add a user to an organization.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.requestBody
   * @param data.session
   * @returns UserOrganization Successful Response
   * @throws ApiError
   */ static addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/organizations/{organization_id}/users",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Remove Users From Organization
   * Remove users from an organization by email.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.memberUserId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/organizations/{organization_id}/users/{member_user_id}",
            path: {
                organization_id: data.organizationId,
                member_user_id: data.memberUserId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Batch Remove Users From Organization
   * Remove a batch of users from an organization.
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.requestBody
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/organizations/{organization_id}/users/remove",
            path: {
                organization_id: data.organizationId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class ProjectsService {
    /**
   * List Projects
   * List projects or get one by name
   * @param data The data for the request.
   * @param data.organizationId
   * @param data.projectName
   * @param data.session
   * @returns Project Successful Response
   * @throws ApiError
   */ static listProjectsApiV1ProjectsGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects",
            cookies: {
                session: data.session
            },
            query: {
                organization_id: data.organizationId,
                project_name: data.projectName
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Project
   * Upsert a project.
   * Updates if a project with the same name already exists. Otherwise, creates a new project.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.organizationId
   * @param data.session
   * @returns Project Successful Response
   * @throws ApiError
   */ static upsertProjectApiV1ProjectsPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/projects",
            cookies: {
                session: data.session
            },
            query: {
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Project
   * Create a new project.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.organizationId
   * @param data.session
   * @returns Project Successful Response
   * @throws ApiError
   */ static createProjectApiV1ProjectsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/projects",
            cookies: {
                session: data.session
            },
            query: {
                organization_id: data.organizationId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Project
   * Get a project by ID.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns Project Successful Response
   * @throws ApiError
   */ static getProjectApiV1ProjectsProjectIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects/{project_id}",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Existing Project
   * Update an existing project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.requestBody
   * @param data.session
   * @returns Project Successful Response
   * @throws ApiError
   */ static updateExistingProjectApiV1ProjectsProjectIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/projects/{project_id}",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Project
   * Delete a project by ID.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteProjectApiV1ProjectsProjectIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/projects/{project_id}",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Datasets For Project
   * List eval datasets for a project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns EvalDataset Successful Response
   * @throws ApiError
   */ static listDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects/{project_id}/eval/dataset",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Eval Dataset For Project
   * Create a new eval dataset for a project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.requestBody
   * @param data.session
   * @returns EvalDataset Successful Response
   * @throws ApiError
   */ static createEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/projects/{project_id}/eval/dataset",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Local Eval Set For Project
   * Create a new local eval set.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.requestBody
   * @param data.session
   * @returns LocalEvalResults Successful Response
   * @throws ApiError
   */ static createLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/projects/{project_id}/localevalset",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Local Evals For Project
   * List local eval results for a project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns LocalEvalResults Successful Response
   * @throws ApiError
   */ static listLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects/{project_id}/localeval",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Local Eval Sets For Project
   * List local eval sets for a project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns LocalEvalSets Successful Response
   * @throws ApiError
   */ static listLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects/{project_id}/localevalsets",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Local Eval Set
   * Delete a local eval set.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.localEvalSetId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static deleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/projects/{project_id}/localevalset/{local_eval_set_id}",
            path: {
                project_id: data.projectId,
                local_eval_set_id: data.localEvalSetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Promptmixin Prompts
   * List PromptMixin prompt sets for a project.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns PromptMixinPrompts Successful Response
   * @throws ApiError
   */ static listPromptmixinPromptsApiV1ProjectsProjectIdPromptsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/projects/{project_id}/prompts",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Prompt Mixin Prompts
   * Create a new PromptMixin prompt set.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.requestBody
   * @param data.session
   * @returns PromptMixinPrompts Successful Response
   * @throws ApiError
   */ static createPromptMixinPromptsApiV1ProjectsProjectIdPromptsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/projects/{project_id}/prompts",
            path: {
                project_id: data.projectId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Promptmixin Prompts
   * Update a PromptMixin prompt set.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.promptSetId
   * @param data.requestBody
   * @param data.session
   * @returns PromptMixinPrompts Successful Response
   * @throws ApiError
   */ static updatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/projects/{project_id}/prompts/{prompt_set_id}",
            path: {
                project_id: data.projectId,
                prompt_set_id: data.promptSetId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Prompt Mixin Prompts
   * Delete a PromptMixin prompt set.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.promptSetId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static deletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/projects/{project_id}/prompts/{prompt_set_id}",
            path: {
                project_id: data.projectId,
                prompt_set_id: data.promptSetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class FilesService {
    /**
   * Get File
   * Read File metadata objects.
   * @param data The data for the request.
   * @param data.id
   * @param data.projectId
   * @param data.session
   * @returns File Successful Response
   * @throws ApiError
   */ static getFileApiV1FilesIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/files/{id}",
            path: {
                id: data.id
            },
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete File
   * Delete the file from S3.
   * @param data The data for the request.
   * @param data.id
   * @param data.projectId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteFileApiV1FilesIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/files/{id}",
            path: {
                id: data.id
            },
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Files
   * Read File metadata objects.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns File Successful Response
   * @throws ApiError
   */ static listFilesApiV1FilesGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/files",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Generate Presigned Url
   * Create a presigned url for uploading a file.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.session
   * @returns PresignedUrl Successful Response
   * @throws ApiError
   */ static generatePresignedUrlApiV1FilesPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/files",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upload File
   * Upload a file to S3.
   * @param data The data for the request.
   * @param data.formData
   * @param data.projectId
   * @param data.session
   * @returns File Successful Response
   * @throws ApiError
   */ static uploadFileApiV1FilesPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/files",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            formData: data.formData,
            mediaType: "multipart/form-data",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Sync Files
   * Sync Files API against file contents uploaded via S3 presigned urls.
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns File Successful Response
   * @throws ApiError
   */ static syncFilesApiV1FilesSyncPut(data = {}) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/files/sync",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Read File Content
   * Returns a presigned url to read the file content.
   * @param data The data for the request.
   * @param data.id
   * @param data.projectId
   * @param data.session
   * @returns PresignedUrl Successful Response
   * @throws ApiError
   */ static readFileContentApiV1FilesIdContentGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/files/{id}/content",
            path: {
                id: data.id
            },
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class PipelinesService {
    /**
   * Search Pipelines
   * Search for pipelines by various parameters.
   * @param data The data for the request.
   * @param data.projectName
   * @param data.pipelineName
   * @param data.pipelineType
   * @param data.projectId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static searchPipelinesApiV1PipelinesGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines",
            cookies: {
                session: data.session
            },
            query: {
                project_name: data.projectName,
                pipeline_name: data.pipelineName,
                pipeline_type: data.pipelineType,
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Pipeline
   * Upsert a pipeline for a project.
   * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static upsertPipelineApiV1PipelinesPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Pipeline
   * Create a new pipeline for a project.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.projectId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static createPipelineApiV1PipelinesPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline
   * Get a pipeline by ID for a given project.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static getPipelineApiV1PipelinesPipelineIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Existing Pipeline
   * Update an existing pipeline for a project.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static updateExistingPipelineApiV1PipelinesPipelineIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Pipeline
   * Delete a pipeline by ID.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deletePipelineApiV1PipelinesPipelineIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/pipelines/{pipeline_id}",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline Status
   * Get the status of a pipeline by ID.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns ManagedIngestionStatusResponse Successful Response
   * @throws ApiError
   */ static getPipelineStatusApiV1PipelinesPipelineIdStatusGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/status",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Sync Pipeline
   * Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static syncPipelineApiV1PipelinesPipelineIdSyncPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/sync",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Copy Pipeline
   * Copy a pipeline by ID.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static copyPipelineApiV1PipelinesPipelineIdCopyPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/copy",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Eval Dataset Executions
   * Get the status of an EvalDatasetExecution.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.evalDatasetId
   * @param data.session
   * @returns EvalDatasetJobRecord Successful Response
   * @throws ApiError
   */ static getEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute",
            path: {
                pipeline_id: data.pipelineId,
                eval_dataset_id: data.evalDatasetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Execute Eval Dataset
   * Execute a dataset.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.evalDatasetId
   * @param data.requestBody
   * @param data.session
   * @returns EvalDatasetJobRecord Successful Response
   * @throws ApiError
   */ static executeEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute",
            path: {
                pipeline_id: data.pipelineId,
                eval_dataset_id: data.evalDatasetId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Eval Dataset Execution Result
   * Get the result of an EvalDatasetExecution.
   * If eval_question_ids is specified, only the results for the specified
   * questions will be returned.
   * If any of the specified questions do not have a result, they will be ignored.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.evalDatasetId
   * @param data.session
   * @returns EvalQuestionResult Successful Response
   * @throws ApiError
   */ static getEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/result",
            path: {
                pipeline_id: data.pipelineId,
                eval_dataset_id: data.evalDatasetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Eval Dataset Execution
   * Get the status of an EvalDatasetExecution.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.evalDatasetId
   * @param data.evalDatasetExecutionId
   * @param data.session
   * @returns EvalDatasetJobRecord Successful Response
   * @throws ApiError
   */ static getEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/{eval_dataset_execution_id}",
            path: {
                pipeline_id: data.pipelineId,
                eval_dataset_id: data.evalDatasetId,
                eval_dataset_execution_id: data.evalDatasetExecutionId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Pipeline Files
   * Get files for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.dataSourceId
   * @param data.onlyManuallyUploaded
   * @param data.session
   * @returns PipelineFile Successful Response
   * @throws ApiError
   */ static listPipelineFilesApiV1PipelinesPipelineIdFilesGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/files",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            query: {
                data_source_id: data.dataSourceId,
                only_manually_uploaded: data.onlyManuallyUploaded
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Add Files To Pipeline
   * Add files to a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns PipelineFile Successful Response
   * @throws ApiError
   */ static addFilesToPipelineApiV1PipelinesPipelineIdFilesPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}/files",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline File Status
   * Get status of a file for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.fileId
   * @param data.session
   * @returns ManagedIngestionStatusResponse Successful Response
   * @throws ApiError
   */ static getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status",
            path: {
                pipeline_id: data.pipelineId,
                file_id: data.fileId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Pipeline File
   * Update a file for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.fileId
   * @param data.requestBody
   * @param data.session
   * @returns PipelineFile Successful Response
   * @throws ApiError
   */ static updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}",
            path: {
                pipeline_id: data.pipelineId,
                file_id: data.fileId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Pipeline File
   * Delete a file from a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.fileId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}",
            path: {
                pipeline_id: data.pipelineId,
                file_id: data.fileId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Import Pipeline Metadata
   * Import metadata for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.formData
   * @param data.session
   * @returns string Successful Response
   * @throws ApiError
   */ static importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}/metadata",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            formData: data.formData,
            mediaType: "multipart/form-data",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Pipeline Files Metadata
   * Delete metadata for all files in a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/pipelines/{pipeline_id}/metadata",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Pipeline Data Sources
   * Get data sources for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns PipelineDataSource Successful Response
   * @throws ApiError
   */ static listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/data-sources",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Add Data Sources To Pipeline
   * Add data sources to a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns PipelineDataSource Successful Response
   * @throws ApiError
   */ static addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}/data-sources",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Pipeline Data Source
   * Delete a data source from a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.dataSourceId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}",
            path: {
                pipeline_id: data.pipelineId,
                data_source_id: data.dataSourceId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Sync Pipeline Data Source
   * Run ingestion for the pipeline data source by incrementally updating the data-sink with upstream changes from data-source.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.dataSourceId
   * @param data.session
   * @returns Pipeline Successful Response
   * @throws ApiError
   */ static syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync",
            path: {
                pipeline_id: data.pipelineId,
                data_source_id: data.dataSourceId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Run Search
   * Get retrieval results for a managed pipeline and a query
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns RetrieveResults Successful Response
   * @throws ApiError
   */ static runSearchApiV1PipelinesPipelineIdRetrievePost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/retrieve",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Pipeline Jobs
   * Get jobs for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.session
   * @returns PipelineDeployment Successful Response
   * @throws ApiError
   */ static listPipelineJobsApiV1PipelinesPipelineIdJobsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/jobs",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline Job
   * Get a job for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.jobId
   * @param data.session
   * @returns PipelineDeployment Successful Response
   * @throws ApiError
   */ static getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/jobs/{job_id}",
            path: {
                pipeline_id: data.pipelineId,
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Chat
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static chatApiV1PipelinesPipelineIdChatPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/chat",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Pipeline Documents
   * Return a list of documents for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.skip
   * @param data.limit
   * @param data.fileId
   * @param data.onlyDirectUpload
   * @param data.session
   * @returns CloudDocument Successful Response
   * @throws ApiError
   */ static listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/documents",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            query: {
                skip: data.skip,
                limit: data.limit,
                file_id: data.fileId,
                only_direct_upload: data.onlyDirectUpload
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Upsert Batch Pipeline Documents
   * Batch create or update a document for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns CloudDocument Successful Response
   * @throws ApiError
   */ static upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/pipelines/{pipeline_id}/documents",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Batch Pipeline Documents
   * Batch create documents for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.requestBody
   * @param data.session
   * @returns CloudDocument Successful Response
   * @throws ApiError
   */ static createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/pipelines/{pipeline_id}/documents",
            path: {
                pipeline_id: data.pipelineId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline Document
   * Return a single document for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.documentId
   * @param data.session
   * @returns CloudDocument Successful Response
   * @throws ApiError
   */ static getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}",
            path: {
                pipeline_id: data.pipelineId,
                document_id: data.documentId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Pipeline Document
   * Delete a document for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.documentId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}",
            path: {
                pipeline_id: data.pipelineId,
                document_id: data.documentId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Pipeline Document Status
   * Return a single document for a pipeline.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.documentId
   * @param data.session
   * @returns ManagedIngestionStatusResponse Successful Response
   * @throws ApiError
   */ static getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status",
            path: {
                pipeline_id: data.pipelineId,
                document_id: data.documentId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Pipeline Document Chunks
   * Return a list of chunks for a pipeline document.
   * @param data The data for the request.
   * @param data.pipelineId
   * @param data.documentId
   * @param data.session
   * @returns TextNode Successful Response
   * @throws ApiError
   */ static listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks",
            path: {
                pipeline_id: data.pipelineId,
                document_id: data.documentId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class EvalsService {
    /**
   * Get Dataset
   * Get a dataset by ID.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.session
   * @returns EvalDataset Successful Response
   * @throws ApiError
   */ static getDatasetApiV1EvalsDatasetsDatasetIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/evals/datasets/{dataset_id}",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Dataset
   * Update a dataset.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.requestBody
   * @param data.session
   * @returns EvalDataset Successful Response
   * @throws ApiError
   */ static updateDatasetApiV1EvalsDatasetsDatasetIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/evals/datasets/{dataset_id}",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Dataset
   * Delete a dataset.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteDatasetApiV1EvalsDatasetsDatasetIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/evals/datasets/{dataset_id}",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Questions
   * List questions for a dataset.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.session
   * @returns EvalQuestion Successful Response
   * @throws ApiError
   */ static listQuestionsApiV1EvalsDatasetsDatasetIdQuestionGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/evals/datasets/{dataset_id}/question",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Question
   * Create a new question.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.requestBody
   * @param data.session
   * @returns EvalQuestion Successful Response
   * @throws ApiError
   */ static createQuestionApiV1EvalsDatasetsDatasetIdQuestionPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/evals/datasets/{dataset_id}/question",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Questions
   * Create a new question.
   * @param data The data for the request.
   * @param data.datasetId
   * @param data.requestBody
   * @param data.session
   * @returns EvalQuestion Successful Response
   * @throws ApiError
   */ static createQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/evals/datasets/{dataset_id}/questions",
            path: {
                dataset_id: data.datasetId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Question
   * Get a question by ID.
   * @param data The data for the request.
   * @param data.questionId
   * @param data.session
   * @returns EvalQuestion Successful Response
   * @throws ApiError
   */ static getQuestionApiV1EvalsQuestionsQuestionIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/evals/questions/{question_id}",
            path: {
                question_id: data.questionId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Replace Question
   * Replace a question.
   * @param data The data for the request.
   * @param data.questionId
   * @param data.requestBody
   * @param data.session
   * @returns EvalQuestion Successful Response
   * @throws ApiError
   */ static replaceQuestionApiV1EvalsQuestionsQuestionIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/evals/questions/{question_id}",
            path: {
                question_id: data.questionId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Delete Question
   * Delete a question.
   * @param data The data for the request.
   * @param data.questionId
   * @param data.session
   * @returns void Successful Response
   * @throws ApiError
   */ static deleteQuestionApiV1EvalsQuestionsQuestionIdDelete(data) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/api/v1/evals/questions/{question_id}",
            path: {
                question_id: data.questionId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Supported Models
   * List supported models.
   * @param data The data for the request.
   * @param data.session
   * @returns SupportedEvalLLMModel Successful Response
   * @throws ApiError
   */ static listSupportedModelsApiV1EvalsModelsGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/evals/models",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class ParsingService {
    /**
   * Get Job Image Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.name
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobImageResultApiV1ParsingJobJobIdResultImageNameGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/image/{name}",
            path: {
                job_id: data.jobId,
                name: data.name
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Supported File Extensions
   * Get a list of supported file extensions
   * @returns LlamaParseSupportedFileExtensions Successful Response
   * @throws ApiError
   */ static getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet() {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/supported_file_extensions"
        });
    }
    /**
   * Upload File
   * Upload a file to s3 and create a job. return a job id
   * @param data The data for the request.
   * @param data.formData
   * @param data.session
   * @returns ParsingJob Successful Response
   * @throws ApiError
   */ static uploadFileApiV1ParsingUploadPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/parsing/upload",
            cookies: {
                session: data.session
            },
            formData: data.formData,
            mediaType: "multipart/form-data",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Usage
   * Get parsing usage for user
   * @param data The data for the request.
   * @param data.session
   * @returns ParsingUsage Successful Response
   * @throws ApiError
   */ static usageApiV1ParsingUsageGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/usage",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJob Successful Response
   * @throws ApiError
   */ static getJobApiV1ParsingJobJobIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Parsing Job Details
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/details",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Text Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobTextResult Successful Response
   * @throws ApiError
   */ static getJobTextResultApiV1ParsingJobJobIdResultTextGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/text",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Raw Text Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobRawTextResultApiV1ParsingJobJobIdResultRawTextGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/raw/text",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobMarkdownResult Successful Response
   * @throws ApiError
   */ static getJobResultApiV1ParsingJobJobIdResultMarkdownGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/markdown",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Raw Md Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/raw/markdown",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Json Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobJsonResult Successful Response
   * @throws ApiError
   */ static getJobJsonResultApiV1ParsingJobJobIdResultJsonGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/json",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Json Raw Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/result/raw/json",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Parsing History Result
   * Get parsing history for user
   * @param data The data for the request.
   * @param data.session
   * @returns ParsingHistoryItem Successful Response
   * @throws ApiError
   */ static getParsingHistoryResultApiV1ParsingHistoryGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/history",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Generate Presigned Url
   * Generate a presigned URL for a job
   * @param data The data for the request.
   * @param data.jobId
   * @param data.filename
   * @param data.session
   * @returns PresignedUrl Successful Response
   * @throws ApiError
   */ static generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/parsing/job/{job_id}/read/{filename}",
            path: {
                job_id: data.jobId,
                filename: data.filename
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class ComponentDefinitionsService {
    /**
   * List Transformation Definitions
   * List transformation component definitions.
   * @returns ConfigurableTransformationDefinition Successful Response
   * @throws ApiError
   */ static listTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGet() {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/component-definition/configurable-transformations"
        });
    }
    /**
   * List Data Source Definitions
   * List data source component definitions.
   * @returns DataSourceDefinition Successful Response
   * @throws ApiError
   */ static listDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGet() {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/component-definition/data-sources"
        });
    }
    /**
   * List Data Sink Definitions
   * List data sink component definitions.
   * @returns DataSinkDefinition Successful Response
   * @throws ApiError
   */ static listDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGet() {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/component-definition/data-sinks"
        });
    }
}
class BillingService {
    /**
   * Create Checkout Session
   * Create a new checkout session.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns string Successful Response
   * @throws ApiError
   */ static createCheckoutSessionApiV1BillingCheckoutSessionPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/billing/checkout-session",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Customer Portal Session
   * Create a new customer portal session.
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns string Successful Response
   * @throws ApiError
   */ static createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/billing/customer-portal-session",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Stripe Webhook
   * Stripe webhook endpoint.
   * @param data The data for the request.
   * @param data.stripeSignature
   * @returns unknown Successful Response
   * @throws ApiError
   */ static stripeWebhookApiV1BillingWebhookPost(data = {}) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/billing/webhook",
            headers: {
                "stripe-signature": data.stripeSignature
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class ExtractionService {
    /**
   * List Schemas
   * @param data The data for the request.
   * @param data.projectId
   * @param data.session
   * @returns ExtractionSchema Successful Response
   * @throws ApiError
   */ static listSchemasApiV1ExtractionSchemasGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/extraction/schemas",
            cookies: {
                session: data.session
            },
            query: {
                project_id: data.projectId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Create Schema
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns ExtractionSchema Successful Response
   * @throws ApiError
   */ static createSchemaApiV1ExtractionSchemasPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/extraction/schemas",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Infer Schema
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns ExtractionSchema Successful Response
   * @throws ApiError
   */ static inferSchemaApiV1ExtractionSchemasInferPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/extraction/schemas/infer",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Schema
   * @param data The data for the request.
   * @param data.schemaId
   * @param data.session
   * @returns ExtractionSchema Successful Response
   * @throws ApiError
   */ static getSchemaApiV1ExtractionSchemasSchemaIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/extraction/schemas/{schema_id}",
            path: {
                schema_id: data.schemaId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Update Schema
   * @param data The data for the request.
   * @param data.schemaId
   * @param data.requestBody
   * @param data.session
   * @returns ExtractionSchema Successful Response
   * @throws ApiError
   */ static updateSchemaApiV1ExtractionSchemasSchemaIdPut(data) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/api/v1/extraction/schemas/{schema_id}",
            path: {
                schema_id: data.schemaId
            },
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * List Jobs
   * @param data The data for the request.
   * @param data.schemaId
   * @param data.session
   * @returns ExtractionJob Successful Response
   * @throws ApiError
   */ static listJobsApiV1ExtractionJobsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/extraction/jobs",
            cookies: {
                session: data.session
            },
            query: {
                schema_id: data.schemaId
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Run Job
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns ExtractionJob Successful Response
   * @throws ApiError
   */ static runJobApiV1ExtractionJobsPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/extraction/jobs",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ExtractionJob Successful Response
   * @throws ApiError
   */ static getJobApiV1ExtractionJobsJobIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/extraction/jobs/{job_id}",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Run Jobs In Batch
   * @param data The data for the request.
   * @param data.requestBody
   * @param data.session
   * @returns ExtractionJob Successful Response
   * @throws ApiError
   */ static runJobsInBatchApiV1ExtractionJobsBatchPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/v1/extraction/jobs/batch",
            cookies: {
                session: data.session
            },
            body: data.requestBody,
            mediaType: "application/json",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Result
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ExtractionResult Successful Response
   * @throws ApiError
   */ static getJobResultApiV1ExtractionJobsJobIdResultGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/v1/extraction/jobs/{job_id}/result",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}
class DeprecatedService {
    /**
   * Get Job Image Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.name
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobImageResultApiParsingJobJobIdResultImageNameGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/image/{name}",
            path: {
                job_id: data.jobId,
                name: data.name
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Supported File Extensions
   * Get a list of supported file extensions
   * @returns LlamaParseSupportedFileExtensions Successful Response
   * @throws ApiError
   */ static getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet() {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/supported_file_extensions"
        });
    }
    /**
   * Upload File
   * Upload a file to s3 and create a job. return a job id
   * @param data The data for the request.
   * @param data.formData
   * @param data.session
   * @returns ParsingJob Successful Response
   * @throws ApiError
   */ static uploadFileApiParsingUploadPost(data) {
        return request(OpenAPI, {
            method: "POST",
            url: "/api/parsing/upload",
            cookies: {
                session: data.session
            },
            formData: data.formData,
            mediaType: "multipart/form-data",
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Usage
   * Get parsing usage for user
   * @param data The data for the request.
   * @param data.session
   * @returns ParsingUsage Successful Response
   * @throws ApiError
   */ static usageApiParsingUsageGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/usage",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJob Successful Response
   * @throws ApiError
   */ static getJobApiParsingJobJobIdGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Parsing Job Details
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getParsingJobDetailsApiParsingJobJobIdDetailsGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/details",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Text Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobTextResult Successful Response
   * @throws ApiError
   */ static getJobTextResultApiParsingJobJobIdResultTextGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/text",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Raw Text Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobRawTextResultApiParsingJobJobIdResultRawTextGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/raw/text",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobMarkdownResult Successful Response
   * @throws ApiError
   */ static getJobResultApiParsingJobJobIdResultMarkdownGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/markdown",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Raw Md Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/raw/markdown",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Json Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns ParsingJobJsonResult Successful Response
   * @throws ApiError
   */ static getJobJsonResultApiParsingJobJobIdResultJsonGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/json",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Job Json Raw Result
   * Get a job by id
   * @param data The data for the request.
   * @param data.jobId
   * @param data.session
   * @returns unknown Successful Response
   * @throws ApiError
   */ static getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/result/raw/json",
            path: {
                job_id: data.jobId
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Get Parsing History Result
   * Get parsing history for user
   * @param data The data for the request.
   * @param data.session
   * @returns ParsingHistoryItem Successful Response
   * @throws ApiError
   */ static getParsingHistoryResultApiParsingHistoryGet(data = {}) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/history",
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
    /**
   * Generate Presigned Url
   * Generate a presigned URL for a job
   * @param data The data for the request.
   * @param data.jobId
   * @param data.filename
   * @param data.session
   * @returns PresignedUrl Successful Response
   * @throws ApiError
   */ static generatePresignedUrlApiParsingJobJobIdReadFilenameGet(data) {
        return request(OpenAPI, {
            method: "GET",
            url: "/api/parsing/job/{job_id}/read/{filename}",
            path: {
                job_id: data.jobId,
                filename: data.filename
            },
            cookies: {
                session: data.session
            },
            errors: {
                422: "Validation Error"
            }
        });
    }
}

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Schema for an API Key.
 */ /**
 * An enumeration.
 */ const ConfigurableDataSinkNames = {
    CHROMA: "CHROMA",
    PINECONE: "PINECONE",
    POSTGRES: "POSTGRES",
    QDRANT: "QDRANT",
    WEAVIATE: "WEAVIATE",
    AZUREAI_SEARCH: "AZUREAI_SEARCH"
};
/**
 * An enumeration.
 */ const ConfigurableDataSourceNames = {
    S3: "S3",
    AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB",
    MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE",
    MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT",
    SLACK: "SLACK",
    NOTION_PAGE: "NOTION_PAGE",
    CONFLUENCE: "CONFLUENCE",
    JIRA: "JIRA"
};
/**
 * An enumeration.
 */ const ConfigurableTransformationNames = {
    CODE_NODE_PARSER: "CODE_NODE_PARSER",
    SENTENCE_AWARE_NODE_PARSER: "SENTENCE_AWARE_NODE_PARSER",
    TOKEN_AWARE_NODE_PARSER: "TOKEN_AWARE_NODE_PARSER",
    HTML_NODE_PARSER: "HTML_NODE_PARSER",
    MARKDOWN_NODE_PARSER: "MARKDOWN_NODE_PARSER",
    JSON_NODE_PARSER: "JSON_NODE_PARSER",
    SIMPLE_FILE_NODE_PARSER: "SIMPLE_FILE_NODE_PARSER",
    MARKDOWN_ELEMENT_NODE_PARSER: "MARKDOWN_ELEMENT_NODE_PARSER",
    OPENAI_EMBEDDING: "OPENAI_EMBEDDING",
    AZURE_EMBEDDING: "AZURE_EMBEDDING",
    COHERE_EMBEDDING: "COHERE_EMBEDDING",
    BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING",
    HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING",
    GEMINI_EMBEDDING: "GEMINI_EMBEDDING"
};
/**
 * An enumeration.
 */ const EmbeddingConfigType = {
    OPENAI_EMBEDDING: "OPENAI_EMBEDDING",
    AZURE_EMBEDDING: "AZURE_EMBEDDING",
    BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING",
    COHERE_EMBEDDING: "COHERE_EMBEDDING",
    GEMINI_EMBEDDING: "GEMINI_EMBEDDING",
    HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING"
};
const job_name = {
    EVAL_DATASET_JOB: "eval_dataset_job"
};
/**
 * Vector store filter conditions to combine different filters.
 */ const FilterCondition = {
    AND: "and",
    OR: "or"
};
/**
 * Vector store filter operator.
 */ const FilterOperator = {
    __: "<=",
    _: "<",
    IN: "in",
    NIN: "nin",
    ANY: "any",
    ALL: "all",
    TEXT_MATCH: "text_match",
    CONTAINS: "contains"
};
/**
 * An enumeration.
 */ const LlamaParseSupportedFileExtensions = {
    _PDF: ".pdf",
    _DOC: ".doc",
    _DOCX: ".docx",
    _DOCM: ".docm",
    _DOT: ".dot",
    _DOTX: ".dotx",
    _DOTM: ".dotm",
    _RTF: ".rtf",
    _WPS: ".wps",
    _WPD: ".wpd",
    _SXW: ".sxw",
    _STW: ".stw",
    _SXG: ".sxg",
    _PAGES: ".pages",
    _MW: ".mw",
    _MCW: ".mcw",
    _UOT: ".uot",
    _UOF: ".uof",
    _UOS: ".uos",
    _UOP: ".uop",
    _PPT: ".ppt",
    _PPTX: ".pptx",
    _POT: ".pot",
    _PPTM: ".pptm",
    _POTX: ".potx",
    _POTM: ".potm",
    _KEY: ".key",
    _ODP: ".odp",
    _ODG: ".odg",
    _OTP: ".otp",
    _FOPD: ".fopd",
    _SXI: ".sxi",
    _STI: ".sti",
    _EPUB: ".epub",
    _HTML: ".html",
    _HTM: ".htm",
    _XLS: ".xls",
    _XLSX: ".xlsx",
    _XLSM: ".xlsm",
    _XLSB: ".xlsb",
    _XLW: ".xlw",
    _CSV: ".csv",
    _DIF: ".dif",
    _SYLK: ".sylk",
    _SLK: ".slk",
    _PRN: ".prn",
    _NUMBERS: ".numbers",
    _ET: ".et",
    _ODS: ".ods",
    _FODS: ".fods",
    _UOS1: ".uos1",
    _UOS2: ".uos2",
    _DBF: ".dbf",
    _WK1: ".wk1",
    _WK2: ".wk2",
    _WK3: ".wk3",
    _WK4: ".wk4",
    _WKS: ".wks",
    _WQ1: ".wq1",
    _WQ2: ".wq2",
    _WB1: ".wb1",
    _WB2: ".wb2",
    _WB3: ".wb3",
    _QPW: ".qpw",
    _XLR: ".xlr",
    _ETH: ".eth",
    _TSV: ".tsv"
};
/**
 * Status of managed ingestion with partial Updates.
 */ const ManagedIngestionStatus = {
    NOT_STARTED: "NOT_STARTED",
    IN_PROGRESS: "IN_PROGRESS",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS"
};
/**
 * Message role.
 */ const MessageRole = {
    SYSTEM: "system",
    USER: "user",
    ASSISTANT: "assistant",
    FUNCTION: "function",
    TOOL: "tool",
    CHATBOT: "chatbot",
    MODEL: "model"
};
/**
 * An enumeration.
 */ const ObjectType = {
    _1: "1",
    _2: "2",
    _3: "3",
    _4: "4"
};
/**
 * Enum for representing the languages supported by the parser
 */ const ParserLanguages = {
    AF: "af",
    AZ: "az",
    BS: "bs",
    CS: "cs",
    CY: "cy",
    DA: "da",
    DE: "de",
    EN: "en",
    ES: "es",
    ET: "et",
    FR: "fr",
    GA: "ga",
    HR: "hr",
    HU: "hu",
    ID: "id",
    IS: "is",
    IT: "it",
    KU: "ku",
    LA: "la",
    LT: "lt",
    LV: "lv",
    MI: "mi",
    MS: "ms",
    MT: "mt",
    NL: "nl",
    NO: "no",
    OC: "oc",
    PI: "pi",
    PL: "pl",
    PT: "pt",
    RO: "ro",
    RS_LATIN: "rs_latin",
    SK: "sk",
    SL: "sl",
    SQ: "sq",
    SV: "sv",
    SW: "sw",
    TL: "tl",
    TR: "tr",
    UZ: "uz",
    VI: "vi",
    AR: "ar",
    FA: "fa",
    UG: "ug",
    UR: "ur",
    BN: "bn",
    AS: "as",
    MNI: "mni",
    RU: "ru",
    RS_CYRILLIC: "rs_cyrillic",
    BE: "be",
    BG: "bg",
    UK: "uk",
    MN: "mn",
    ABQ: "abq",
    ADY: "ady",
    KBD: "kbd",
    AVA: "ava",
    DAR: "dar",
    INH: "inh",
    CHE: "che",
    LBE: "lbe",
    LEZ: "lez",
    TAB: "tab",
    TJK: "tjk",
    HI: "hi",
    MR: "mr",
    NE: "ne",
    BH: "bh",
    MAI: "mai",
    ANG: "ang",
    BHO: "bho",
    MAH: "mah",
    SCK: "sck",
    NEW: "new",
    GOM: "gom",
    SA: "sa",
    BGC: "bgc",
    TH: "th",
    CH_SIM: "ch_sim",
    CH_TRA: "ch_tra",
    JA: "ja",
    KO: "ko",
    TA: "ta",
    TE: "te",
    KN: "kn"
};
/**
 * Enum for representing the type of a pipeline
 */ const PipelineType = {
    PLAYGROUND: "PLAYGROUND",
    MANAGED: "MANAGED"
};
/**
 * Enum of possible pooling choices with pooling behaviors.
 */ const Pooling = {
    CLS: "cls",
    MEAN: "mean",
    LAST: "last"
};
/**
 * Pydantic program mode.
 */ const PydanticProgramMode = {
    DEFAULT: "default",
    OPENAI: "openai",
    LLM: "llm",
    FUNCTION: "function",
    GUIDANCE: "guidance",
    LM_FORMAT_ENFORCER: "lm-format-enforcer"
};
/**
 * An enumeration.
 */ const RetrievalMode = {
    CHUNKS: "chunks",
    FILES_VIA_METADATA: "files_via_metadata",
    FILES_VIA_CONTENT: "files_via_content"
};
/**
 * Enum for representing the status of a job
 */ const StatusEnum = {
    PENDING: "PENDING",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS"
};
/**
 * An enumeration.
 */ const SupportedEvalLLMModelNames = {
    GPT_3_5_TURBO: "GPT_3_5_TURBO",
    GPT_4: "GPT_4",
    GPT_4_TURBO: "GPT_4_TURBO"
};
/**
 * An enumeration.
 */ const TransformConfigMode = {
    AUTO: "AUTO",
    ADVANCED: "ADVANCED"
};
/**
 * An enumeration.
 */ const TransformationCategoryNames = {
    NODE_PARSER: "NODE_PARSER",
    EMBEDDING: "EMBEDDING"
};

export { $APIKey, $APIKeyCreate, $APIKeyUpdate, $AutoTransformConfig, $AzureOpenAIEmbedding, $Base, $BasePromptTemplate, $BedrockEmbedding, $Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put, $Body_upload_file_api_parsing_upload_post, $Body_upload_file_api_v1_files_post, $Body_upload_file_api_v1_parsing_upload_post, $ChatData, $ChatMessage, $ChatParams, $CheckoutSessionCreatePayload, $CloudAzStorageBlobDataSource, $CloudAzureAISearchVectorStore, $CloudChromaVectorStore, $CloudConfluenceDataSource, $CloudDocument, $CloudDocumentCreate, $CloudJiraDataSource, $CloudNotionPageDataSource, $CloudOneDriveDataSource, $CloudPineconeVectorStore, $CloudPostgresVectorStore, $CloudQdrantVectorStore, $CloudS3DataSource, $CloudSharepointDataSource, $CloudSlackDataSource, $CloudWeaviateVectorStore, $CodeSplitter, $CohereEmbedding, $ConfigurableDataSinkNames, $ConfigurableDataSourceNames, $ConfigurableTransformationDefinition, $ConfigurableTransformationNames, $ConfiguredTransformationItem, $CustomerPortalSessionCreatePayload, $DataSink, $DataSinkCreate, $DataSinkDefinition, $DataSinkUpdate, $DataSource, $DataSourceCreate, $DataSourceDefinition, $DataSourceUpdate, $DefaultOrganizationUpdate, $EmbeddingConfig, $EmbeddingConfigType, $EvalDataset, $EvalDatasetCreate, $EvalDatasetJobParams, $EvalDatasetJobRecord, $EvalDatasetUpdate, $EvalExecutionCreate, $EvalExecutionParams, $EvalExecutionParamsOverride, $EvalLLMModelData, $EvalQuestion, $EvalQuestionCreate, $EvalQuestionResult, $ExtractionJob, $ExtractionJobCreate, $ExtractionJobCreateBatch, $ExtractionResult, $ExtractionSchema, $ExtractionSchemaCreate, $ExtractionSchemaInfer, $ExtractionSchemaUpdate, $File, $FileCreate, $FilterCondition, $FilterOperator, $GeminiEmbedding, $HTMLNodeParser, $HTTPValidationError, $HuggingFaceInferenceAPIEmbedding, $JSONNodeParser, $LLM, $LlamaParseParameters, $LlamaParseSupportedFileExtensions, $LocalEval, $LocalEvalResults, $LocalEvalSetCreate, $LocalEvalSets, $ManagedIngestionStatus, $ManagedIngestionStatusResponse, $MarkdownElementNodeParser, $MarkdownNodeParser, $MessageRole, $MetadataFilter, $MetadataFilters, $MetricResult, $NodeParser, $ObjectType, $OpenAIEmbedding, $Organization, $OrganizationCreate, $OrganizationUpdate, $ParserLanguages, $ParsingHistoryItem, $ParsingJob, $ParsingJobJsonResult, $ParsingJobMarkdownResult, $ParsingJobTextResult, $ParsingUsage, $Pipeline, $PipelineCreate, $PipelineDataSource, $PipelineDataSourceCreate, $PipelineDeployment, $PipelineFile, $PipelineFileCreate, $PipelineFileUpdate, $PipelineType, $PipelineUpdate, $Pooling, $PresetRetrievalParams, $PresignedUrl, $Project, $ProjectCreate, $ProjectUpdate, $PromptMixinPrompts, $PromptSpec, $PydanticProgramMode, $RelatedNodeInfo, $RetrievalMode, $RetrievalParams, $RetrieveResults, $SentenceSplitter, $SimpleFileNodeParser, $StatusEnum, $SupportedEvalLLMModel, $SupportedEvalLLMModelNames, $TextNode, $TextNodeWithScore, $TokenTextSplitter, $TransformConfig, $TransformConfigMode, $TransformationCategoryNames, $UserOrganization, $UserOrganizationCreate, $UserOrganizationDelete, $ValidationError, ApiError, ApiKeysService, BillingService, CancelError, CancelablePromise, ComponentDefinitionsService, ConfigurableDataSinkNames, ConfigurableDataSourceNames, ConfigurableTransformationNames, DataSinksService, DataSourcesService, DeprecatedService, EmbeddingConfigType, EvalsService, ExtractionService, FilesService, FilterCondition, FilterOperator, LlamaParseSupportedFileExtensions, ManagedIngestionStatus, MessageRole, ObjectType, OpenAPI, OrganizationsService, ParserLanguages, ParsingService, PipelineType, PipelinesService, Pooling, ProjectsService, PydanticProgramMode, RetrievalMode, StatusEnum, SupportedEvalLLMModelNames, TransformConfigMode, TransformationCategoryNames, job_name };
