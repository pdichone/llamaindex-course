type ApiRequestOptions<T = unknown> = {
    readonly body?: any;
    readonly cookies?: Record<string, unknown>;
    readonly errors?: Record<number | string, string>;
    readonly formData?: Record<string, unknown> | any[];
    readonly headers?: Record<string, unknown>;
    readonly mediaType?: string;
    readonly method: "DELETE" | "GET" | "HEAD" | "OPTIONS" | "PATCH" | "POST" | "PUT";
    readonly path?: Record<string, unknown>;
    readonly query?: Record<string, unknown>;
    readonly responseHeader?: string;
    readonly responseTransformer?: (data: unknown) => Promise<T>;
    readonly url: string;
};

type ApiResult<TData = any> = {
    readonly body: TData;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly url: string;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: unknown;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    readonly cancelHandlers: (() => void)[];
    readonly promise: Promise<T>;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: unknown) => void, onCancel: OnCancel) => void);
    get [Symbol.toStringTag](): string;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

type Headers = Record<string, string>;
type Middleware<T> = (value: T) => T | Promise<T>;
type Resolver<T> = (options: ApiRequestOptions<T>) => Promise<T>;
declare class Interceptors<T> {
    _fns: Middleware<T>[];
    constructor();
    eject(fn: Middleware<T>): void;
    use(fn: Middleware<T>): void;
}
type OpenAPIConfig = {
    BASE: string;
    CREDENTIALS: "include" | "omit" | "same-origin";
    ENCODE_PATH?: ((path: string) => string) | undefined;
    HEADERS?: Headers | Resolver<Headers> | undefined;
    PASSWORD?: string | Resolver<string> | undefined;
    TOKEN?: string | Resolver<string> | undefined;
    USERNAME?: string | Resolver<string> | undefined;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    interceptors: {
        request: Interceptors<RequestInit>;
        response: Interceptors<Response>;
    };
};
declare const OpenAPI: OpenAPIConfig;

declare const $APIKey: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 0;
            readonly title: "Name";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
        };
        readonly redacted_api_key: {
            readonly type: "string";
            readonly title: "Redacted Api Key";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "user_id", "redacted_api_key"];
    readonly title: "APIKey";
    readonly description: "Schema for an API Key.";
};
declare const $APIKeyCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 0;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly title: "APIKeyCreate";
    readonly description: "Schema for creating an API key.";
};
declare const $APIKeyUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 0;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly title: "APIKeyUpdate";
    readonly description: "Schema for updating an API key.";
};
declare const $AutoTransformConfig: {
    readonly properties: {
        readonly chunk_size: {
            readonly type: "integer";
            readonly title: "Chunk Size";
            readonly description: "Chunk size for the transformation.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly description: "Chunk overlap for the transformation.";
            readonly default: 20;
        };
    };
    readonly type: "object";
    readonly title: "AutoTransformConfig";
};
declare const $AzureOpenAIEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the embedding model.";
            readonly default: "unknown";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the OpenAI API.";
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
            readonly description: "The OpenAI API key.";
        };
        readonly api_base: {
            readonly type: "string";
            readonly title: "Api Base";
            readonly description: "The base URL for Azure deployment.";
            readonly default: "";
        };
        readonly api_version: {
            readonly type: "string";
            readonly title: "Api Version";
            readonly description: "The version for Azure OpenAI API.";
            readonly default: "";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly description: "Maximum number of retries.";
            readonly default: 10;
            readonly gte: 0;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "Timeout for each request.";
            readonly default: 60;
            readonly gte: 0;
        };
        readonly default_headers: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Default Headers";
            readonly description: "The default headers for API requests.";
        };
        readonly reuse_client: {
            readonly type: "boolean";
            readonly title: "Reuse Client";
            readonly description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.";
            readonly default: true;
        };
        readonly dimensions: {
            readonly type: "integer";
            readonly title: "Dimensions";
            readonly description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.";
        };
        readonly azure_endpoint: {
            readonly type: "string";
            readonly title: "Azure Endpoint";
            readonly description: "The Azure endpoint to use.";
        };
        readonly azure_deployment: {
            readonly type: "string";
            readonly title: "Azure Deployment";
            readonly description: "The Azure deployment to use.";
        };
        readonly use_azure_ad: {
            readonly type: "boolean";
            readonly title: "Use Azure Ad";
            readonly description: "Indicates if Microsoft Entra ID (former Azure AD) is used for token authentication";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "AzureOpenAIEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key", "use_azure_ad"];
    readonly title: "AzureOpenAIEmbedding";
    readonly description: "OpenAI class for embeddings.\n\nArgs:\n    mode (str): Mode for embedding.\n        Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.\n        Options are:\n\n        - OpenAIEmbeddingMode.SIMILARITY_MODE\n        - OpenAIEmbeddingMode.TEXT_SEARCH_MODE\n\n    model (str): Model for embedding.\n        Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.\n        Options are:\n\n        - OpenAIEmbeddingModelType.DAVINCI\n        - OpenAIEmbeddingModelType.CURIE\n        - OpenAIEmbeddingModelType.BABBAGE\n        - OpenAIEmbeddingModelType.ADA\n        - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002";
};
declare const $Base: {
    readonly properties: {};
    readonly type: "object";
    readonly title: "Base";
};
declare const $BasePromptTemplate: {
    readonly properties: {
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly template_vars: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Template Vars";
        };
        readonly kwargs: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Kwargs";
        };
        readonly output_parser: {
            readonly type: "object";
            readonly title: "Output Parser";
            readonly default: {};
        };
        readonly template_var_mappings: {
            readonly type: "object";
            readonly title: "Template Var Mappings";
            readonly description: "Template variable mappings (Optional).";
        };
    };
    readonly type: "object";
    readonly required: readonly ["metadata", "template_vars", "kwargs"];
    readonly title: "BasePromptTemplate";
    readonly description: "Chainable mixin.\n\nA module that can produce a `QueryComponent` from a set of inputs through\n`as_query_component`.\n\nIf plugged in directly into a `QueryPipeline`, the `ChainableMixin` will be\nconverted into a `QueryComponent` with default parameters.";
};
declare const $BedrockEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The modelId of the Bedrock model to use.";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly profile_name: {
            readonly type: "string";
            readonly title: "Profile Name";
            readonly description: "The name of aws profile to use. If not given, then the default profile is used.";
        };
        readonly aws_access_key_id: {
            readonly type: "string";
            readonly title: "Aws Access Key Id";
            readonly description: "AWS Access Key ID to use";
        };
        readonly aws_secret_access_key: {
            readonly type: "string";
            readonly title: "Aws Secret Access Key";
            readonly description: "AWS Secret Access Key to use";
        };
        readonly aws_session_token: {
            readonly type: "string";
            readonly title: "Aws Session Token";
            readonly description: "AWS Session Token to use";
        };
        readonly region_name: {
            readonly type: "string";
            readonly title: "Region Name";
            readonly description: "AWS region name to use. Uses region configured in AWS CLI if not passed";
        };
        readonly botocore_session: {
            readonly title: "Botocore Session";
            readonly description: "Use this Botocore session instead of creating a new default one.";
        };
        readonly botocore_config: {
            readonly title: "Botocore Config";
            readonly description: "Custom configuration object to use instead of the default generated one.";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Max Retries";
            readonly description: "The maximum number of API retries.";
            readonly default: 10;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.";
            readonly default: 60;
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the bedrock client.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "BedrockEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["model_name"];
    readonly title: "BedrockEmbedding";
    readonly description: "Base class for embeddings.";
};
declare const $Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put: {
    readonly properties: {
        readonly upload_file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "Upload File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["upload_file"];
    readonly title: "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put";
};
declare const $Body_upload_file_api_parsing_upload_post: {
    readonly properties: {
        readonly language: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly default: readonly ["en"];
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "boolean";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
        readonly file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["file"];
    readonly title: "Body_upload_file_api_parsing_upload_post";
};
declare const $Body_upload_file_api_v1_files_post: {
    readonly properties: {
        readonly upload_file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "Upload File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["upload_file"];
    readonly title: "Body_upload_file_api_v1_files_post";
};
declare const $Body_upload_file_api_v1_parsing_upload_post: {
    readonly properties: {
        readonly language: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly default: readonly ["en"];
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "boolean";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
        readonly file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["file"];
    readonly title: "Body_upload_file_api_v1_parsing_upload_post";
};
declare const $ChatData: {
    readonly properties: {
        readonly retrieval_parameters: {
            readonly $ref: "#/components/schemas/PresetRetrievalParams";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["retrieval_parameters"];
    readonly title: "ChatData";
    readonly description: "Base schema model for BaseComponent classes used in the platform.\nComes with special serialization logic for types used commonly in platform codebase.";
};
declare const $ChatMessage: {
    readonly properties: {
        readonly role: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/MessageRole";
            }];
            readonly default: "user";
        };
        readonly content: {
            readonly title: "Content";
            readonly default: "";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
        };
    };
    readonly type: "object";
    readonly title: "ChatMessage";
    readonly description: "Chat message.";
};
declare const $ChatParams: {
    readonly properties: {
        readonly messages: {
            readonly items: {
                readonly $ref: "#/components/schemas/ChatMessage";
            };
            readonly type: "array";
            readonly title: "Messages";
        };
        readonly data: {
            readonly $ref: "#/components/schemas/ChatData";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["messages", "data"];
    readonly title: "ChatParams";
    readonly description: "Base schema model for BaseComponent classes used in the platform.\nComes with special serialization logic for types used commonly in platform codebase.";
};
declare const $CheckoutSessionCreatePayload: {
    readonly properties: {
        readonly success_url: {
            readonly type: "string";
            readonly maxLength: 65536;
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Success Url";
        };
        readonly cancel_url: {
            readonly type: "string";
            readonly maxLength: 65536;
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Cancel Url";
        };
    };
    readonly type: "object";
    readonly required: readonly ["success_url", "cancel_url"];
    readonly title: "CheckoutSessionCreatePayload";
};
declare const $CloudAzStorageBlobDataSource: {
    readonly properties: {
        readonly container_name: {
            readonly type: "string";
            readonly title: "Container Name";
            readonly description: "The name of the Azure Storage Blob container to read from.";
        };
        readonly account_url: {
            readonly type: "string";
            readonly title: "Account Url";
            readonly description: "The Azure Storage Blob account URL to use for authentication.";
        };
        readonly blob: {
            readonly type: "string";
            readonly title: "Blob";
            readonly description: "The blob name to read from.";
        };
        readonly prefix: {
            readonly type: "string";
            readonly title: "Prefix";
            readonly description: "The prefix of the Azure Storage Blob objects to read from.";
            readonly default: "";
        };
        readonly account_name: {
            readonly type: "string";
            readonly title: "Account Name";
            readonly description: "The Azure Storage Blob account name to use for authentication.";
        };
        readonly account_key: {
            readonly type: "string";
            readonly title: "Account Key";
            readonly description: "The Azure Storage Blob account key to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudAzStorageBlobDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["container_name", "account_url", "account_name", "account_key"];
    readonly title: "CloudAzStorageBlobDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudAzureAISearchVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly search_service_api_key: {
            readonly type: "string";
            readonly title: "Search Service Api Key";
        };
        readonly search_service_endpoint: {
            readonly type: "string";
            readonly title: "Search Service Endpoint";
        };
        readonly search_service_api_version: {
            readonly type: "string";
            readonly title: "Search Service Api Version";
        };
        readonly index_name: {
            readonly type: "string";
            readonly title: "Index Name";
        };
        readonly filterable_metadata_field_keys: {
            readonly type: "object";
            readonly title: "Filterable Metadata Field Keys";
        };
        readonly embedding_dimension: {
            readonly type: "integer";
            readonly title: "Embedding Dimension";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudAzureAISearchVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["search_service_api_key", "search_service_endpoint"];
    readonly title: "CloudAzureAISearchVectorStore";
    readonly description: "Cloud Azure AI Search Vector Store.";
};
declare const $CloudChromaVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly collection_name: {
            readonly type: "string";
            readonly title: "Collection Name";
        };
        readonly host: {
            readonly type: "string";
            readonly title: "Host";
        };
        readonly port: {
            readonly type: "string";
            readonly title: "Port";
        };
        readonly ssl: {
            readonly type: "boolean";
            readonly title: "Ssl";
        };
        readonly headers: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Headers";
        };
        readonly persist_dir: {
            readonly type: "string";
            readonly title: "Persist Dir";
        };
        readonly collection_kwargs: {
            readonly type: "object";
            readonly title: "Collection Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudChromaVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["ssl"];
    readonly title: "CloudChromaVectorStore";
    readonly description: "Base class for cloud vector stores.";
};
declare const $CloudConfluenceDataSource: {
    readonly properties: {
        readonly server_url: {
            readonly type: "string";
            readonly title: "Server Url";
            readonly description: "The server URL of the Confluence instance.";
        };
        readonly authentication_mechanism: {
            readonly type: "string";
            readonly title: "Authentication Mechanism";
            readonly description: "Type of Authentication for connecting to Confluence APIs.";
        };
        readonly user_name: {
            readonly type: "string";
            readonly title: "User Name";
            readonly description: "The username to use for authentication.";
        };
        readonly api_token: {
            readonly type: "string";
            readonly title: "Api Token";
            readonly description: "The API token to use for authentication.";
        };
        readonly space_key: {
            readonly type: "string";
            readonly title: "Space Key";
            readonly description: "The space key to read from.";
        };
        readonly page_ids: {
            readonly type: "string";
            readonly title: "Page Ids";
            readonly description: "The page IDs of the Confluence to read from.";
        };
        readonly cql: {
            readonly type: "string";
            readonly title: "Cql";
            readonly description: "The CQL query to use for fetching pages.";
        };
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label to use for fetching pages.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudConfluenceDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["server_url", "authentication_mechanism"];
    readonly title: "CloudConfluenceDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudDocument: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly default: readonly [];
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly default: readonly [];
        };
        readonly id: {
            readonly type: "string";
            readonly title: "Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text", "metadata", "id"];
    readonly title: "CloudDocument";
    readonly description: "Cloud document stored in S3.";
};
declare const $CloudDocumentCreate: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly default: readonly [];
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly default: readonly [];
        };
        readonly id: {
            readonly type: "string";
            readonly title: "Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text", "metadata"];
    readonly title: "CloudDocumentCreate";
    readonly description: "Create a new cloud document.";
};
declare const $CloudJiraDataSource: {
    readonly properties: {
        readonly email: {
            readonly type: "string";
            readonly title: "Email";
            readonly description: "The email address to use for authentication.";
        };
        readonly api_token: {
            readonly type: "string";
            readonly title: "Api Token";
            readonly description: "The API/ Access Token used for Basic, PAT and OAuth2 authentication.";
        };
        readonly server_url: {
            readonly type: "string";
            readonly title: "Server Url";
            readonly description: "The server url for Jira Cloud.";
        };
        readonly cloud_id: {
            readonly type: "string";
            readonly title: "Cloud Id";
            readonly description: "The cloud ID, used in case of OAuth2.";
        };
        readonly authentication_mechanism: {
            readonly type: "string";
            readonly title: "Authentication Mechanism";
            readonly description: "Type of Authentication for connecting to Jira APIs.";
        };
        readonly query: {
            readonly type: "string";
            readonly title: "Query";
            readonly description: "JQL (Jira Query Language) query to search.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudJiraDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["authentication_mechanism", "query"];
    readonly title: "CloudJiraDataSource";
    readonly description: "Cloud Jira Data Source integrating JiraReader.";
};
declare const $CloudNotionPageDataSource: {
    readonly properties: {
        readonly integration_token: {
            readonly type: "string";
            readonly title: "Integration Token";
            readonly description: "The integration token to use for authentication.";
        };
        readonly database_ids: {
            readonly type: "string";
            readonly title: "Database Ids";
            readonly description: "The Notion Database Id to read content from.";
        };
        readonly page_ids: {
            readonly type: "string";
            readonly title: "Page Ids";
            readonly description: "The Page ID's of the Notion to read from.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudNotionPageDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["integration_token"];
    readonly title: "CloudNotionPageDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudOneDriveDataSource: {
    readonly properties: {
        readonly user_principal_name: {
            readonly type: "string";
            readonly title: "User Principal Name";
            readonly description: "The user principal name to use for authentication.";
        };
        readonly folder_path: {
            readonly type: "string";
            readonly title: "Folder Path";
            readonly description: "The path of the OneDrive folder to read from.";
        };
        readonly folder_id: {
            readonly type: "string";
            readonly title: "Folder Id";
            readonly description: "The ID of the OneDrive folder to read from.";
        };
        readonly client_id: {
            readonly type: "string";
            readonly title: "Client Id";
            readonly description: "The client ID to use for authentication.";
        };
        readonly client_secret: {
            readonly type: "string";
            readonly title: "Client Secret";
            readonly description: "The client secret to use for authentication.";
        };
        readonly tenant_id: {
            readonly type: "string";
            readonly title: "Tenant Id";
            readonly description: "The tenant ID to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudOneDriveDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["user_principal_name", "client_id", "client_secret", "tenant_id"];
    readonly title: "CloudOneDriveDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudPineconeVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
        };
        readonly index_name: {
            readonly type: "string";
            readonly title: "Index Name";
        };
        readonly namespace: {
            readonly type: "string";
            readonly title: "Namespace";
        };
        readonly insert_kwargs: {
            readonly type: "object";
            readonly title: "Insert Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudPineconeVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key", "index_name"];
    readonly title: "CloudPineconeVectorStore";
    readonly description: "Cloud Pinecone Vector Store.\n\nThis class is used to store the configuration for a Pinecone vector store, so that it can be\ncreated and used in LlamaCloud.\n\nArgs:\n    api_key (str): API key for authenticating with Pinecone\n    index_name (str): name of the Pinecone index\n    namespace (optional[str]): namespace to use in the Pinecone index\n    insert_kwargs (optional[dict]): additional kwargs to pass during insertion";
};
declare const $CloudPostgresVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly connection_string: {
            readonly type: "string";
            readonly title: "Connection String";
        };
        readonly async_connection_string: {
            readonly type: "string";
            readonly title: "Async Connection String";
        };
        readonly table_name: {
            readonly type: "string";
            readonly title: "Table Name";
        };
        readonly schema_name: {
            readonly type: "string";
            readonly title: "Schema Name";
        };
        readonly embed_dim: {
            readonly type: "integer";
            readonly title: "Embed Dim";
        };
        readonly hybrid_search: {
            readonly type: "boolean";
            readonly title: "Hybrid Search";
        };
        readonly text_search_config: {
            readonly type: "string";
            readonly title: "Text Search Config";
        };
        readonly cache_ok: {
            readonly type: "boolean";
            readonly title: "Cache Ok";
        };
        readonly perform_setup: {
            readonly type: "boolean";
            readonly title: "Perform Setup";
        };
        readonly debug: {
            readonly type: "boolean";
            readonly title: "Debug";
        };
        readonly use_jsonb: {
            readonly type: "boolean";
            readonly title: "Use Jsonb";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudPostgresVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["connection_string", "async_connection_string", "table_name", "schema_name", "embed_dim", "hybrid_search", "text_search_config", "cache_ok", "perform_setup", "debug", "use_jsonb"];
    readonly title: "CloudPostgresVectorStore";
    readonly description: "Base class for cloud vector stores.";
};
declare const $CloudQdrantVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly collection_name: {
            readonly type: "string";
            readonly title: "Collection Name";
        };
        readonly url: {
            readonly type: "string";
            readonly title: "Url";
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly default: 3;
        };
        readonly client_kwargs: {
            readonly type: "object";
            readonly title: "Client Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudQdrantVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["collection_name", "url", "api_key"];
    readonly title: "CloudQdrantVectorStore";
    readonly description: "Cloud Qdrant Vector Store.\n\nThis class is used to store the configuration for a Qdrant vector store, so that it can be\ncreated and used in LlamaCloud.\n\nArgs:\n    collection_name (str): name of the Qdrant collection\n    url (str): url of the Qdrant instance\n    api_key (str): API key for authenticating with Qdrant\n    max_retries (int): maximum number of retries in case of a failure. Defaults to 3\n    client_kwargs (dict): additional kwargs to pass to the Qdrant client";
};
declare const $CloudS3DataSource: {
    readonly properties: {
        readonly bucket: {
            readonly type: "string";
            readonly title: "Bucket";
            readonly description: "The name of the S3 bucket to read from.";
        };
        readonly prefix: {
            readonly type: "string";
            readonly title: "Prefix";
            readonly description: "The prefix of the S3 objects to read from.";
        };
        readonly aws_access_id: {
            readonly type: "string";
            readonly title: "Aws Access Id";
            readonly description: "The AWS access ID to use for authentication.";
        };
        readonly aws_access_secret: {
            readonly type: "string";
            readonly title: "Aws Access Secret";
            readonly description: "The AWS access secret to use for authentication.";
        };
        readonly s3_endpoint_url: {
            readonly type: "string";
            readonly title: "S3 Endpoint Url";
            readonly description: "The S3 endpoint URL to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudS3DataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["bucket"];
    readonly title: "CloudS3DataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudSharepointDataSource: {
    readonly properties: {
        readonly site_name: {
            readonly type: "string";
            readonly title: "Site Name";
            readonly description: "The name of the SharePoint site to download from.";
        };
        readonly folder_path: {
            readonly type: "string";
            readonly title: "Folder Path";
            readonly description: "The path of the Sharepoint folder to read from.";
        };
        readonly folder_id: {
            readonly type: "string";
            readonly title: "Folder Id";
            readonly description: "The ID of the Sharepoint folder to read from.";
        };
        readonly drive_name: {
            readonly type: "string";
            readonly title: "Drive Name";
            readonly description: "The name of the Sharepoint drive to read from.";
        };
        readonly client_id: {
            readonly type: "string";
            readonly title: "Client Id";
            readonly description: "The client ID to use for authentication.";
        };
        readonly client_secret: {
            readonly type: "string";
            readonly title: "Client Secret";
            readonly description: "The client secret to use for authentication.";
        };
        readonly tenant_id: {
            readonly type: "string";
            readonly title: "Tenant Id";
            readonly description: "The tenant ID to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudSharepointDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["site_name", "client_id", "client_secret", "tenant_id"];
    readonly title: "CloudSharepointDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudSlackDataSource: {
    readonly properties: {
        readonly slack_token: {
            readonly type: "string";
            readonly title: "Slack Token";
            readonly description: "Slack Bot Token.";
        };
        readonly channel_ids: {
            readonly type: "string";
            readonly title: "Channel Ids";
            readonly description: "Slack Channel.";
        };
        readonly latest_date: {
            readonly type: "string";
            readonly title: "Latest Date";
            readonly description: "Latest date.";
        };
        readonly earliest_date: {
            readonly type: "string";
            readonly title: "Earliest Date";
            readonly description: "Earliest date.";
        };
        readonly earliest_date_timestamp: {
            readonly type: "number";
            readonly title: "Earliest Date Timestamp";
            readonly description: "Earliest date timestamp.";
        };
        readonly latest_date_timestamp: {
            readonly type: "number";
            readonly title: "Latest Date Timestamp";
            readonly description: "Latest date timestamp.";
        };
        readonly channel_patterns: {
            readonly type: "string";
            readonly title: "Channel Patterns";
            readonly description: "Slack Channel name pattern.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudSlackDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["slack_token"];
    readonly title: "CloudSlackDataSource";
    readonly description: "Base component object to capture class names.";
};
declare const $CloudWeaviateVectorStore: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly index_name: {
            readonly type: "string";
            readonly title: "Index Name";
        };
        readonly url: {
            readonly type: "string";
            readonly title: "Url";
        };
        readonly text_key: {
            readonly type: "string";
            readonly title: "Text Key";
        };
        readonly auth_config: {
            readonly type: "object";
            readonly title: "Auth Config";
        };
        readonly client_kwargs: {
            readonly type: "object";
            readonly title: "Client Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudWeaviateVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["index_name", "text_key"];
    readonly title: "CloudWeaviateVectorStore";
    readonly description: "Base class for cloud vector stores.";
};
declare const $CodeSplitter: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly language: {
            readonly type: "string";
            readonly title: "Language";
            readonly description: "The programming language of the code being split.";
        };
        readonly chunk_lines: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Lines";
            readonly description: "The number of lines to include in each chunk.";
            readonly default: 40;
        };
        readonly chunk_lines_overlap: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Lines Overlap";
            readonly description: "How many lines of code each chunk overlaps with.";
            readonly default: 15;
        };
        readonly max_chars: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Max Chars";
            readonly description: "Maximum number of characters per chunk.";
            readonly default: 1500;
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CodeSplitter";
        };
    };
    readonly type: "object";
    readonly required: readonly ["language"];
    readonly title: "CodeSplitter";
    readonly description: "Split code using a AST parser.\n\nThank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.\nhttps://docs.sweep.dev/blogs/chunking-2m-files";
};
declare const $CohereEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the embedding model.";
            readonly default: "unknown";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
            readonly description: "The Cohere API key.";
        };
        readonly truncate: {
            readonly type: "string";
            readonly title: "Truncate";
            readonly description: "Truncation type - START/ END/ NONE";
        };
        readonly input_type: {
            readonly type: "string";
            readonly title: "Input Type";
            readonly description: "Model Input type. If not provided, search_document and search_query are used when needed.";
        };
        readonly embedding_type: {
            readonly type: "string";
            readonly title: "Embedding Type";
            readonly description: "Embedding type. If not provided float embedding_type is used when needed.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CohereEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key", "truncate", "embedding_type"];
    readonly title: "CohereEmbedding";
    readonly description: "CohereEmbedding uses the Cohere API to generate embeddings for text.";
};
declare const $ConfigurableDataSinkNames: {
    readonly type: "string";
    readonly enum: readonly ["CHROMA", "PINECONE", "POSTGRES", "QDRANT", "WEAVIATE", "AZUREAI_SEARCH"];
    readonly title: "ConfigurableDataSinkNames";
    readonly description: "An enumeration.";
};
declare const $ConfigurableDataSourceNames: {
    readonly type: "string";
    readonly enum: readonly ["S3", "AZURE_STORAGE_BLOB", "MICROSOFT_ONEDRIVE", "MICROSOFT_SHAREPOINT", "SLACK", "NOTION_PAGE", "CONFLUENCE", "JIRA"];
    readonly title: "ConfigurableDataSourceNames";
    readonly description: "An enumeration.";
};
declare const $ConfigurableTransformationDefinition: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly configurable_transformation_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ConfigurableTransformationNames";
            }];
            readonly description: "The name field will act as the unique identifier of TransformationDefinition objects";
        };
        readonly transformation_category: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/TransformationCategoryNames";
            }];
            readonly description: "The transformation_category field will be used to group transformations in the UI";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "configurable_transformation_type", "transformation_category"];
    readonly title: "ConfigurableTransformationDefinition";
    readonly description: "Schema for a transformation definition.";
};
declare const $ConfigurableTransformationNames: {
    readonly type: "string";
    readonly enum: readonly ["CODE_NODE_PARSER", "SENTENCE_AWARE_NODE_PARSER", "TOKEN_AWARE_NODE_PARSER", "HTML_NODE_PARSER", "MARKDOWN_NODE_PARSER", "JSON_NODE_PARSER", "SIMPLE_FILE_NODE_PARSER", "MARKDOWN_ELEMENT_NODE_PARSER", "OPENAI_EMBEDDING", "AZURE_EMBEDDING", "COHERE_EMBEDDING", "BEDROCK_EMBEDDING", "HUGGINGFACE_API_EMBEDDING", "GEMINI_EMBEDDING"];
    readonly title: "ConfigurableTransformationNames";
    readonly description: "An enumeration.";
};
declare const $ConfiguredTransformationItem: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
        };
        readonly configurable_transformation_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ConfigurableTransformationNames";
            }];
            readonly description: "Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames.";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CodeSplitter";
                }, {
                    readonly $ref: "#/components/schemas/SentenceSplitter";
                }, {
                    readonly $ref: "#/components/schemas/TokenTextSplitter";
                }, {
                    readonly $ref: "#/components/schemas/HTMLNodeParser";
                }, {
                    readonly $ref: "#/components/schemas/MarkdownNodeParser";
                }, {
                    readonly $ref: "#/components/schemas/JSONNodeParser";
                }, {
                    readonly $ref: "#/components/schemas/SimpleFileNodeParser";
                }, {
                    readonly $ref: "#/components/schemas/MarkdownElementNodeParser";
                }, {
                    readonly $ref: "#/components/schemas/OpenAIEmbedding";
                }, {
                    readonly $ref: "#/components/schemas/AzureOpenAIEmbedding";
                }, {
                    readonly $ref: "#/components/schemas/CohereEmbedding";
                }, {
                    readonly $ref: "#/components/schemas/BedrockEmbedding";
                }, {
                    readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding";
                }, {
                    readonly $ref: "#/components/schemas/GeminiEmbedding";
                }];
            }];
            readonly title: "Component";
            readonly description: "Component that implements the transformation";
        };
    };
    readonly type: "object";
    readonly required: readonly ["configurable_transformation_type", "component"];
    readonly title: "ConfiguredTransformationItem";
    readonly description: "Configured transformations for pipelines.\n\nSimilar to ConfigurableTransformation but includes a few\nmore fields that are useful to the platform.";
};
declare const $CustomerPortalSessionCreatePayload: {
    readonly properties: {
        readonly return_url: {
            readonly type: "string";
            readonly maxLength: 65536;
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Return Url";
        };
    };
    readonly type: "object";
    readonly required: readonly ["return_url"];
    readonly title: "CustomerPortalSessionCreatePayload";
};
declare const $DataSink: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudChromaVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudWeaviateVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
                }];
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "sink_type", "component", "project_id"];
    readonly title: "DataSink";
    readonly description: "Schema for a data sink.";
};
declare const $DataSinkCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudChromaVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudWeaviateVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
                }];
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "sink_type", "component"];
    readonly title: "DataSinkCreate";
    readonly description: "Schema for creating a data sink.";
};
declare const $DataSinkDefinition: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly sink_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
            }];
            readonly description: "The name field will act as the unique identifier of DataSinkDefinition objects";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "sink_type"];
    readonly title: "DataSinkDefinition";
    readonly description: "Schema for a data sink definition.";
};
declare const $DataSinkUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudChromaVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudWeaviateVectorStore";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
                }];
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["sink_type"];
    readonly title: "DataSinkUpdate";
    readonly description: "Schema for updating a data sink.";
};
declare const $DataSource: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudS3DataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSharepointDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSlackDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudJiraDataSource";
                }];
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "source_type", "component", "project_id"];
    readonly title: "DataSource";
    readonly description: "Schema for a data source.";
};
declare const $DataSourceCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudS3DataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSharepointDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSlackDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudJiraDataSource";
                }];
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "source_type", "component"];
    readonly title: "DataSourceCreate";
    readonly description: "Schema for creating a data source.";
};
declare const $DataSourceDefinition: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly source_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
            }];
            readonly description: "The name field will act as the unique identifier of DataSourceDefinition objects";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "source_type"];
    readonly title: "DataSourceDefinition";
    readonly description: "Schema for a data source definition.";
};
declare const $DataSourceUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudS3DataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSharepointDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSlackDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudJiraDataSource";
                }];
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["source_type"];
    readonly title: "DataSourceUpdate";
    readonly description: "Schema for updating a data source.";
};
declare const $DefaultOrganizationUpdate: {
    readonly properties: {
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["organization_id"];
    readonly title: "DefaultOrganizationUpdate";
    readonly description: "Schema for updating the default organization for a user.";
};
declare const $EmbeddingConfig: {
    readonly properties: {
        readonly type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EmbeddingConfigType";
            }];
            readonly description: "Type of the embedding model.";
            readonly default: "OPENAI_EMBEDDING";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/OpenAIEmbedding";
            }, {
                readonly $ref: "#/components/schemas/AzureOpenAIEmbedding";
            }, {
                readonly $ref: "#/components/schemas/BedrockEmbedding";
            }, {
                readonly $ref: "#/components/schemas/CohereEmbedding";
            }, {
                readonly $ref: "#/components/schemas/GeminiEmbedding";
            }, {
                readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding";
            }];
            readonly title: "Component";
            readonly description: "Configuration for the transformation.";
        };
    };
    readonly type: "object";
    readonly title: "EmbeddingConfig";
};
declare const $EmbeddingConfigType: {
    readonly type: "string";
    readonly enum: readonly ["OPENAI_EMBEDDING", "AZURE_EMBEDDING", "BEDROCK_EMBEDDING", "COHERE_EMBEDDING", "GEMINI_EMBEDDING", "HUGGINGFACE_API_EMBEDDING"];
    readonly title: "EmbeddingConfigType";
    readonly description: "An enumeration.";
};
declare const $EvalDataset: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "EvalDataset";
    readonly description: "Schema for an eval dataset.\nIncludes the other DB fields like id, created_at, & updated_at.";
};
declare const $EvalDatasetCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "EvalDatasetCreate";
    readonly description: "Schema for creating an eval dataset.";
};
declare const $EvalDatasetJobParams: {
    readonly properties: {
        readonly eval_question_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly title: "Eval Question Ids";
            readonly description: "The IDs for the EvalQuestions this execution ran against.";
        };
        readonly eval_execution_params: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }];
            readonly title: "Eval Execution Params";
            readonly description: "The parameters for the eval execution.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_ids", "eval_execution_params"];
    readonly title: "EvalDatasetJobParams";
    readonly description: "Schema for the parameters of an eval dataset job.";
};
declare const $EvalDatasetJobRecord: {
    readonly properties: {
        readonly job_name: {
            readonly type: "string";
            readonly enum: readonly ["eval_dataset_job"];
            readonly title: "Job Name";
        };
        readonly partitions: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "string";
                    readonly format: "uuid";
                }, {
                    readonly type: "string";
                }];
            };
            readonly type: "object";
            readonly title: "Partitions";
            readonly description: "The partitions for this execution. Used for determining where to save job output.";
        };
        readonly parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalDatasetJobParams";
            }];
            readonly title: "Parameters";
            readonly description: "Additional input parameters for the eval execution.";
        };
        readonly session_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Session Id";
            readonly description: "The upstream request ID that created this job. Used for tracking the job across services.";
        };
        readonly correlation_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Correlation Id";
            readonly description: "The correlation ID for this job. Used for tracking the job across services.";
        };
        readonly parent_job_execution_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Parent Job Execution Id";
            readonly description: "The ID of the parent job execution.";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The ID of the user that created this job";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/StatusEnum";
        };
        readonly error_message: {
            readonly type: "string";
            readonly title: "Error Message";
        };
        readonly attempts: {
            readonly type: "integer";
            readonly title: "Attempts";
            readonly description: "The number of times this job has been attempted";
            readonly default: 0;
        };
        readonly started_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Started At";
        };
        readonly ended_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Ended At";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly data: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/Base";
            }];
            readonly title: "Data";
            readonly description: "Additional metadata for the job execution.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["job_name", "partitions", "status"];
    readonly title: "EvalDatasetJobRecord";
    readonly description: "Schema for job that evaluates an EvalDataset against a pipeline.";
};
declare const $EvalDatasetUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "EvalDatasetUpdate";
    readonly description: "Schema for updating an eval dataset.\nOnly the name can be updated.";
};
declare const $EvalExecutionCreate: {
    readonly properties: {
        readonly eval_question_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly title: "Eval Question Ids";
        };
        readonly params: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParamsOverride";
            }];
            readonly title: "Params";
            readonly description: "The parameters for the eval execution that will override the ones set in the pipeline.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_ids"];
    readonly title: "EvalExecutionCreate";
    readonly description: "Schema for creating an eval execution for a given set of questions on a pipeline.";
};
declare const $EvalExecutionParams: {
    readonly properties: {
        readonly llm_model: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/SupportedEvalLLMModelNames";
            }];
            readonly description: "The LLM model to use within eval execution.";
            readonly default: "GPT_3_5_TURBO";
        };
        readonly qa_prompt_tmpl: {
            readonly type: "string";
            readonly title: "Qa Prompt Tmpl";
            readonly description: "The template to use for the question answering prompt.";
            readonly default: "Context information is below.\n---------------------\n{context_str}\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: {query_str}\nAnswer: ";
        };
    };
    readonly type: "object";
    readonly title: "EvalExecutionParams";
    readonly description: "Schema for the params for an eval execution.";
};
declare const $EvalExecutionParamsOverride: {
    readonly properties: {
        readonly llm_model: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/SupportedEvalLLMModelNames";
            }];
            readonly description: "The LLM model to use within eval execution.";
        };
        readonly qa_prompt_tmpl: {
            readonly type: "string";
            readonly title: "Qa Prompt Tmpl";
            readonly description: "The template to use for the question answering prompt.";
        };
    };
    readonly type: "object";
    readonly title: "EvalExecutionParamsOverride";
    readonly description: "Schema for the params override for an eval execution.";
};
declare const $EvalLLMModelData: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the LLM model.";
        };
        readonly description: {
            readonly type: "string";
            readonly title: "Description";
            readonly description: "The description of the LLM model.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "description"];
    readonly title: "EvalLLMModelData";
    readonly description: "Schema for an eval LLM model.";
};
declare const $EvalQuestion: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly content: {
            readonly type: "string";
            readonly maxLength: 1000;
            readonly minLength: 1;
            readonly title: "Content";
            readonly description: "The content of the question.";
        };
        readonly eval_dataset_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Dataset Id";
        };
        readonly eval_dataset_index: {
            readonly type: "integer";
            readonly title: "Eval Dataset Index";
            readonly description: "The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.";
            readonly min: 0;
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "content", "eval_dataset_id", "eval_dataset_index"];
    readonly title: "EvalQuestion";
    readonly description: "Base schema model containing common database fields.";
};
declare const $EvalQuestionCreate: {
    readonly properties: {
        readonly content: {
            readonly type: "string";
            readonly maxLength: 1000;
            readonly minLength: 1;
            readonly title: "Content";
            readonly description: "The content of the question.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["content"];
    readonly title: "EvalQuestionCreate";
};
declare const $EvalQuestionResult: {
    readonly properties: {
        readonly eval_question_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Question Id";
            readonly description: "The ID of the question that was executed.";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the question was executed against.";
        };
        readonly source_nodes: {
            readonly items: {
                readonly $ref: "#/components/schemas/TextNode";
            };
            readonly type: "array";
            readonly title: "Source Nodes";
            readonly description: "The nodes retrieved by the pipeline for the given question.";
        };
        readonly answer: {
            readonly type: "string";
            readonly title: "Answer";
            readonly description: "The answer to the question.";
        };
        readonly eval_metrics: {
            readonly additionalProperties: {
                readonly $ref: "#/components/schemas/MetricResult";
            };
            readonly type: "object";
            readonly title: "Eval Metrics";
            readonly description: "The eval metrics for the question.";
        };
        readonly eval_dataset_execution_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Dataset Execution Id";
            readonly description: "The ID of the EvalDatasetJobRecord that this result was generated from.";
        };
        readonly eval_dataset_execution_params: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }];
            readonly title: "Eval Dataset Execution Params";
            readonly description: "The EvalExecutionParams that were used when this result was generated.";
        };
        readonly eval_finished_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Eval Finished At";
            readonly description: "The timestamp when the eval finished.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "EvalQuestionResult";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_id", "pipeline_id", "source_nodes", "answer", "eval_metrics", "eval_dataset_execution_id", "eval_dataset_execution_params", "eval_finished_at"];
    readonly title: "EvalQuestionResult";
    readonly description: "Schema for the result of an eval question job.";
};
declare const $ExtractionJob: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "The id of the extraction job";
        };
        readonly status: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/StatusEnum";
            }];
            readonly description: "The status of the extraction job";
        };
        readonly file: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/File";
            }];
            readonly title: "File";
            readonly description: "The file that the extract was extracted from";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status", "file"];
    readonly title: "ExtractionJob";
};
declare const $ExtractionJobCreate: {
    readonly properties: {
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The id of the file";
        };
    };
    readonly type: "object";
    readonly required: readonly ["schema_id", "file_id"];
    readonly title: "ExtractionJobCreate";
    readonly description: "Schema for creating an extraction job.";
};
declare const $ExtractionJobCreateBatch: {
    readonly properties: {
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly file_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly minItems: 1;
            readonly title: "File Ids";
            readonly description: "The ids of the files";
        };
    };
    readonly type: "object";
    readonly required: readonly ["schema_id", "file_ids"];
    readonly title: "ExtractionJobCreateBatch";
    readonly description: "Schema for creating extraction jobs in batch.";
};
declare const $ExtractionResult: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly data: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Data";
            readonly description: "The data extracted from the file";
        };
        readonly file: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/File";
            }];
            readonly title: "File";
            readonly description: "The file that the extract was extracted from";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "schema_id", "data", "file"];
    readonly title: "ExtractionResult";
    readonly description: "Schema for an extraction result.";
};
declare const $ExtractionSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly data_schema: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "ExtractionSchema";
    readonly description: "Schema for extraction schema.";
};
declare const $ExtractionSchemaCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly data_schema: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "data_schema"];
    readonly title: "ExtractionSchemaCreate";
    readonly description: "Schema for creating an extraction schema.";
};
declare const $ExtractionSchemaInfer: {
    readonly properties: {
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The ID of a schema to update with the new schema";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly file_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly minItems: 1;
            readonly title: "File Ids";
            readonly description: "The IDs of the files that the extraction schema contains";
        };
        readonly stream: {
            readonly type: "boolean";
            readonly title: "Stream";
            readonly description: "Whether to stream the results of the extraction schema";
            readonly default: false;
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "file_ids"];
    readonly title: "ExtractionSchemaInfer";
    readonly description: "Schema for inferring an extraction schema.";
};
declare const $ExtractionSchemaUpdate: {
    readonly properties: {
        readonly data_schema: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly title: "ExtractionSchemaUpdate";
    readonly description: "Schema for updating an extraction schema.";
};
declare const $File: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly file_size: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly file_type: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "File Type";
            readonly description: "File type (e.g. pdf, docx, etc.)";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the file belongs to";
        };
        readonly last_modified_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "File";
    readonly description: "Schema for a file.";
};
declare const $FileCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly file_size: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly last_modified_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "FileCreate";
};
declare const $FilterCondition: {
    readonly type: "string";
    readonly enum: readonly ["and", "or"];
    readonly title: "FilterCondition";
    readonly description: "Vector store filter conditions to combine different filters.";
};
declare const $FilterOperator: {
    readonly type: "string";
    readonly enum: readonly ["==", ">", "<", "!=", ">=", "<=", "in", "nin", "any", "all", "text_match", "contains"];
    readonly title: "FilterOperator";
    readonly description: "Vector store filter operator.";
};
declare const $GeminiEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the embedding model.";
            readonly default: "unknown";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly title: {
            readonly type: "string";
            readonly title: "Title";
            readonly description: "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.";
            readonly default: "";
        };
        readonly task_type: {
            readonly type: "string";
            readonly title: "Task Type";
            readonly description: "The task for embedding model.";
            readonly default: "retrieval_document";
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
            readonly description: "API key to access the model. Defaults to None.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "GeminiEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "GeminiEmbedding";
    readonly description: "Google Gemini embeddings.\n\nArgs:\n    model_name (str): Model for embedding.\n        Defaults to \"models/embedding-001\".\n\n    api_key (Optional[str]): API key to access the model. Defaults to None.\n    api_base (Optional[str]): API base to access the model. Defaults to Official Base.\n    transport (Optional[str]): Transport to access the model.";
};
declare const $HTMLNodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly tags: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Tags";
            readonly description: "HTML tags to extract text from.";
            readonly default: readonly ["p", "h1", "h2", "h3", "h4", "h5", "h6", "li", "b", "i", "u", "section"];
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "HTMLNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "HTMLNodeParser";
    readonly description: "HTML node parser.\n\nSplits a document into Nodes using custom HTML splitting logic.\n\nArgs:\n    include_metadata (bool): whether to include metadata in nodes\n    include_prev_next_rel (bool): whether to include prev/next relationships";
};
declare const $HTTPValidationError: {
    readonly properties: {
        readonly detail: {
            readonly items: {
                readonly $ref: "#/components/schemas/ValidationError";
            };
            readonly type: "array";
            readonly title: "Detail";
        };
    };
    readonly type: "object";
    readonly title: "HTTPValidationError";
};
declare const $HuggingFaceInferenceAPIEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "Hugging Face model name. If None, the task will be used.";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly pooling: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/Pooling";
            }];
            readonly description: "Pooling strategy. If None, the model's default pooling is used.";
            readonly default: "cls";
        };
        readonly query_instruction: {
            readonly type: "string";
            readonly title: "Query Instruction";
            readonly description: "Instruction to prepend during query embedding.";
        };
        readonly text_instruction: {
            readonly type: "string";
            readonly title: "Text Instruction";
            readonly description: "Instruction to prepend during text embedding.";
        };
        readonly token: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "boolean";
            }];
            readonly title: "Token";
            readonly description: "Hugging Face token. Will default to the locally saved token. Pass token=False if you dont want to send your token to the server.";
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.";
        };
        readonly headers: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Headers";
            readonly description: "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.";
        };
        readonly cookies: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Cookies";
            readonly description: "Additional cookies to send to the server.";
        };
        readonly task: {
            readonly type: "string";
            readonly title: "Task";
            readonly description: "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "HuggingFaceInferenceAPIEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "HuggingFaceInferenceAPIEmbedding";
    readonly description: "Wrapper on the Hugging Face's Inference API for embeddings.\n\nOverview of the design:\n- Uses the feature extraction task: https://huggingface.co/tasks/feature-extraction";
};
declare const $JSONNodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "JSONNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "JSONNodeParser";
    readonly description: "JSON node parser.\n\nSplits a document into Nodes using custom JSON splitting logic.\n\nArgs:\n    include_metadata (bool): whether to include metadata in nodes\n    include_prev_next_rel (bool): whether to include prev/next relationships";
};
declare const $LLM: {
    readonly properties: {
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly system_prompt: {
            readonly type: "string";
            readonly title: "System Prompt";
            readonly description: "System prompt for LLM calls.";
        };
        readonly output_parser: {
            readonly type: "object";
            readonly title: "Output Parser";
            readonly description: "Output parser to parse, validate, and correct errors programmatically.";
            readonly default: {};
        };
        readonly pydantic_program_mode: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PydanticProgramMode";
            }];
            readonly default: "default";
        };
        readonly query_wrapper_prompt: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/BasePromptTemplate";
            }];
            readonly title: "Query Wrapper Prompt";
            readonly description: "Query wrapper prompt for LLM calls.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "LLM";
    readonly description: "The LLM class is the main class for interacting with language models.\n\nAttributes:\n    system_prompt (Optional[str]):\n        System prompt for LLM calls.\n    messages_to_prompt (Callable):\n        Function to convert a list of messages to an LLM prompt.\n    completion_to_prompt (Callable):\n        Function to convert a completion to an LLM prompt.\n    output_parser (Optional[BaseOutputParser]):\n        Output parser to parse, validate, and correct errors programmatically.\n    pydantic_program_mode (PydanticProgramMode):\n        Pydantic program mode to use for structured prediction.";
};
declare const $LlamaParseParameters: {
    readonly properties: {
        readonly languages: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly minItems: 1;
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly disable_ocr: {
            readonly type: "boolean";
            readonly title: "Disable Ocr";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: true;
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "string";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
            readonly default: "";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
    };
    readonly type: "object";
    readonly title: "LlamaParseParameters";
    readonly description: "Settings that can be configured for how to use LlamaParse to parse files witin a LlamaCloud pipeline.";
};
declare const $LlamaParseSupportedFileExtensions: {
    readonly type: "string";
    readonly enum: readonly [".pdf", ".doc", ".docx", ".docm", ".dot", ".dotx", ".dotm", ".rtf", ".wps", ".wpd", ".sxw", ".stw", ".sxg", ".pages", ".mw", ".mcw", ".uot", ".uof", ".uos", ".uop", ".ppt", ".pptx", ".pot", ".pptm", ".potx", ".potm", ".key", ".odp", ".odg", ".otp", ".fopd", ".sxi", ".sti", ".epub", ".html", ".htm", ".xls", ".xlsx", ".xlsm", ".xlsb", ".xlw", ".csv", ".dif", ".sylk", ".slk", ".prn", ".numbers", ".et", ".ods", ".fods", ".uos1", ".uos2", ".dbf", ".wk1", ".wk2", ".wk3", ".wk4", ".wks", ".wq1", ".wq2", ".wb1", ".wb2", ".wb3", ".qpw", ".xlr", ".eth", ".tsv"];
    readonly title: "LlamaParseSupportedFileExtensions";
    readonly description: "An enumeration.";
};
declare const $LocalEval: {
    readonly properties: {
        readonly query: {
            readonly type: "string";
            readonly title: "Query";
            readonly description: "Query string";
        };
        readonly contexts: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Contexts";
            readonly description: "Context strings";
        };
        readonly response: {
            readonly type: "string";
            readonly title: "Response";
            readonly description: "Response string";
        };
        readonly passing: {
            readonly type: "boolean";
            readonly title: "Passing";
            readonly description: "Binary evaluation result (passing or not)";
        };
        readonly feedback: {
            readonly type: "string";
            readonly title: "Feedback";
            readonly description: "Feedback or reasoning for the response";
        };
        readonly score: {
            readonly type: "number";
            readonly title: "Score";
            readonly description: "Score for the response";
        };
        readonly pairwise_source: {
            readonly type: "string";
            readonly title: "Pairwise Source";
            readonly description: "Used only for pairwise and specifies whether it is from original order of presented answers or flipped order";
        };
        readonly invalid_result: {
            readonly type: "boolean";
            readonly title: "Invalid Result";
            readonly description: "Whether the evaluation result is an invalid one.";
            readonly default: false;
        };
        readonly invalid_reason: {
            readonly type: "string";
            readonly title: "Invalid Reason";
            readonly description: "Reason for invalid evaluation.";
        };
    };
    readonly type: "object";
    readonly title: "LocalEval";
    readonly description: "Evaluation result, EvaluationResult from llama_index.\n\nOutput of an BaseEvaluator.";
};
declare const $LocalEvalResults: {
    readonly properties: {
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project.";
        };
        readonly eval_set_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Set Id";
            readonly description: "The ID of the local eval result set.";
        };
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly eval_name: {
            readonly type: "string";
            readonly title: "Eval Name";
            readonly description: "The name of the eval.";
        };
        readonly result: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/LocalEval";
            }];
            readonly title: "Result";
            readonly description: "The eval results.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["project_id", "app_name", "eval_name", "result"];
    readonly title: "LocalEvalResults";
    readonly description: "Schema for the result of a local evaluation.";
};
declare const $LocalEvalSetCreate: {
    readonly properties: {
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly results: {
            readonly additionalProperties: {
                readonly items: {
                    readonly $ref: "#/components/schemas/LocalEval";
                };
                readonly type: "array";
            };
            readonly type: "object";
            readonly title: "Results";
            readonly description: "The eval results.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["app_name", "results"];
    readonly title: "LocalEvalSetCreate";
    readonly description: "Schema for creating a local eval set.";
};
declare const $LocalEvalSets: {
    readonly properties: {
        readonly eval_set_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Set Id";
            readonly description: "The ID of the eval set.";
        };
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly upload_time: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Upload Time";
            readonly description: "The time of the upload.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_set_id", "app_name", "upload_time"];
    readonly title: "LocalEvalSets";
};
declare const $ManagedIngestionStatus: {
    readonly type: "string";
    readonly enum: readonly ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "PARTIAL_SUCCESS"];
    readonly title: "ManagedIngestionStatus";
    readonly description: "Status of managed ingestion with partial Updates.";
};
declare const $ManagedIngestionStatusResponse: {
    readonly properties: {
        readonly status: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ManagedIngestionStatus";
            }];
            readonly description: "Status of the ingestion.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["status"];
    readonly title: "ManagedIngestionStatusResponse";
};
declare const $MarkdownElementNodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly llm: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/LLM";
            }];
            readonly title: "Llm";
            readonly description: "LLM model to use for summarization.";
        };
        readonly summary_query_str: {
            readonly type: "string";
            readonly title: "Summary Query Str";
            readonly description: "Query string to use for summarization.";
            readonly default: "What is this table about? Give a very concise summary (imagine you are adding a new caption and summary for this table), and output the real/existing table title/caption if context provided.and output the real/existing table id if context provided.and also output whether or not the table should be kept.";
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "Num of workers for async jobs.";
            readonly default: 4;
        };
        readonly show_progress: {
            readonly type: "boolean";
            readonly title: "Show Progress";
            readonly description: "Whether to show progress.";
            readonly default: true;
        };
        readonly nested_node_parser: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/NodeParser";
            }];
            readonly title: "Nested Node Parser";
            readonly description: "Other types of node parsers to handle some types of nodes.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "MarkdownElementNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "MarkdownElementNodeParser";
    readonly description: "Markdown element node parser.\n\nSplits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects\n(e.g. tables).";
};
declare const $MarkdownNodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "MarkdownNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "MarkdownNodeParser";
    readonly description: "Markdown node parser.\n\nSplits a document into Nodes using custom Markdown splitting logic.\n\nArgs:\n    include_metadata (bool): whether to include metadata in nodes\n    include_prev_next_rel (bool): whether to include prev/next relationships";
};
declare const $MessageRole: {
    readonly type: "string";
    readonly enum: readonly ["system", "user", "assistant", "function", "tool", "chatbot", "model"];
    readonly title: "MessageRole";
    readonly description: "Message role.";
};
declare const $MetadataFilter: {
    readonly properties: {
        readonly key: {
            readonly type: "string";
            readonly title: "Key";
        };
        readonly value: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "number";
            }, {
                readonly type: "string";
            }, {
                readonly items: {
                    readonly type: "string";
                };
                readonly type: "array";
            }, {
                readonly items: {
                    readonly type: "number";
                };
                readonly type: "array";
            }, {
                readonly items: {
                    readonly type: "integer";
                };
                readonly type: "array";
            }];
            readonly title: "Value";
        };
        readonly operator: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/FilterOperator";
            }];
            readonly default: "==";
        };
    };
    readonly type: "object";
    readonly required: readonly ["key", "value"];
    readonly title: "MetadataFilter";
    readonly description: "Comprehensive metadata filter for vector stores to support more operators.\n\nValue uses Strict* types, as int, float and str are compatible types and were all\nconverted to string before.\n\nSee: https://docs.pydantic.dev/latest/usage/types/#strict-types";
};
declare const $MetadataFilters: {
    readonly properties: {
        readonly filters: {
            readonly items: {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/MetadataFilter";
                }, {
                    readonly $ref: "#/components/schemas/MetadataFilters";
                }];
            };
            readonly type: "array";
            readonly title: "Filters";
        };
        readonly condition: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/FilterCondition";
            }];
            readonly default: "and";
        };
    };
    readonly type: "object";
    readonly required: readonly ["filters"];
    readonly title: "MetadataFilters";
    readonly description: "Metadata filters for vector stores.";
};
declare const $MetricResult: {
    readonly properties: {
        readonly passing: {
            readonly type: "boolean";
            readonly title: "Passing";
            readonly description: "Whether the metric passed or not.";
        };
        readonly score: {
            readonly type: "number";
            readonly title: "Score";
            readonly description: "The score for the metric.";
        };
        readonly feedback: {
            readonly type: "string";
            readonly title: "Feedback";
            readonly description: "The reasoning for the metric.";
        };
    };
    readonly type: "object";
    readonly title: "MetricResult";
};
declare const $NodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "NodeParser";
    readonly description: "Base interface for node parser.";
};
declare const $ObjectType: {
    readonly type: "string";
    readonly enum: readonly ["1", "2", "3", "4"];
    readonly title: "ObjectType";
    readonly description: "An enumeration.";
};
declare const $OpenAIEmbedding: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the embedding model.";
            readonly default: "unknown";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
            readonly lte: 2048;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the OpenAI API.";
        };
        readonly api_key: {
            readonly type: "string";
            readonly title: "Api Key";
            readonly description: "The OpenAI API key.";
        };
        readonly api_base: {
            readonly type: "string";
            readonly title: "Api Base";
            readonly description: "The base URL for OpenAI API.";
            readonly default: "https://api.openai.com/v1";
        };
        readonly api_version: {
            readonly type: "string";
            readonly title: "Api Version";
            readonly description: "The version for OpenAI API.";
            readonly default: "";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly description: "Maximum number of retries.";
            readonly default: 10;
            readonly gte: 0;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "Timeout for each request.";
            readonly default: 60;
            readonly gte: 0;
        };
        readonly default_headers: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Default Headers";
            readonly description: "The default headers for API requests.";
        };
        readonly reuse_client: {
            readonly type: "boolean";
            readonly title: "Reuse Client";
            readonly description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.";
            readonly default: true;
        };
        readonly dimensions: {
            readonly type: "integer";
            readonly title: "Dimensions";
            readonly description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "OpenAIEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key"];
    readonly title: "OpenAIEmbedding";
    readonly description: "OpenAI class for embeddings.\n\nArgs:\n    mode (str): Mode for embedding.\n        Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.\n        Options are:\n\n        - OpenAIEmbeddingMode.SIMILARITY_MODE\n        - OpenAIEmbeddingMode.TEXT_SEARCH_MODE\n\n    model (str): Model for embedding.\n        Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.\n        Options are:\n\n        - OpenAIEmbeddingModelType.DAVINCI\n        - OpenAIEmbeddingModelType.CURIE\n        - OpenAIEmbeddingModelType.BABBAGE\n        - OpenAIEmbeddingModelType.ADA\n        - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002";
};
declare const $Organization: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name"];
    readonly title: "Organization";
    readonly description: "Schema for an organization.";
};
declare const $OrganizationCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "OrganizationCreate";
    readonly description: "Schema for creating an organization.";
};
declare const $OrganizationUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly title: "OrganizationUpdate";
    readonly description: "Schema for updating an organization.";
};
declare const $ParserLanguages: {
    readonly type: "string";
    readonly enum: readonly ["af", "az", "bs", "cs", "cy", "da", "de", "en", "es", "et", "fr", "ga", "hr", "hu", "id", "is", "it", "ku", "la", "lt", "lv", "mi", "ms", "mt", "nl", "no", "oc", "pi", "pl", "pt", "ro", "rs_latin", "sk", "sl", "sq", "sv", "sw", "tl", "tr", "uz", "vi", "ar", "fa", "ug", "ur", "bn", "as", "mni", "ru", "rs_cyrillic", "be", "bg", "uk", "mn", "abq", "ady", "kbd", "ava", "dar", "inh", "che", "lbe", "lez", "tab", "tjk", "hi", "mr", "ne", "bh", "mai", "ang", "bho", "mah", "sck", "new", "gom", "sa", "bgc", "th", "ch_sim", "ch_tra", "ja", "ko", "ta", "te", "kn"];
    readonly title: "ParserLanguages";
    readonly description: "Enum for representing the languages supported by the parser";
};
declare const $ParsingHistoryItem: {
    readonly properties: {
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
        };
        readonly day: {
            readonly type: "string";
            readonly title: "Day";
        };
        readonly job_id: {
            readonly type: "string";
            readonly title: "Job Id";
        };
        readonly file_name: {
            readonly type: "string";
            readonly title: "File Name";
        };
        readonly original_file_name: {
            readonly type: "string";
            readonly title: "Original File Name";
        };
        readonly expired: {
            readonly type: "boolean";
            readonly title: "Expired";
            readonly default: false;
        };
        readonly pages: {
            readonly type: "number";
            readonly title: "Pages";
        };
        readonly images: {
            readonly type: "number";
            readonly title: "Images";
        };
        readonly time: {
            readonly type: "number";
            readonly title: "Time";
        };
    };
    readonly type: "object";
    readonly required: readonly ["user_id", "day", "job_id", "file_name", "original_file_name"];
    readonly title: "ParsingHistoryItem";
};
declare const $ParsingJob: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/StatusEnum";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status"];
    readonly title: "ParsingJob";
};
declare const $ParsingJobJsonResult: {
    readonly properties: {
        readonly pages: {
            readonly title: "Pages";
            readonly description: "The json result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly title: "ParsingJobJsonResult";
};
declare const $ParsingJobMarkdownResult: {
    readonly properties: {
        readonly markdown: {
            readonly type: "string";
            readonly title: "Markdown";
            readonly description: "The markdown result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly required: readonly ["markdown"];
    readonly title: "ParsingJobMarkdownResult";
};
declare const $ParsingJobTextResult: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
            readonly description: "The text result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text"];
    readonly title: "ParsingJobTextResult";
};
declare const $ParsingUsage: {
    readonly properties: {
        readonly usage_pdf_pages: {
            readonly type: "integer";
            readonly title: "Usage Pdf Pages";
        };
        readonly max_pdf_pages: {
            readonly type: "integer";
            readonly title: "Max Pdf Pages";
        };
    };
    readonly type: "object";
    readonly required: readonly ["usage_pdf_pages", "max_pdf_pages"];
    readonly title: "ParsingUsage";
};
declare const $Pipeline: {
    readonly properties: {
        readonly configured_transformations: {
            readonly items: {
                readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
            };
            readonly type: "array";
            readonly title: "Configured Transformations";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
        readonly pipeline_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PipelineType";
            }];
            readonly description: "Type of pipeline. Either PLAYGROUND or MANAGED.";
            readonly default: "MANAGED";
        };
        readonly managed_pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
        readonly preset_retrieval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PresetRetrievalParams";
            }];
            readonly title: "Preset Retrieval Parameters";
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }];
            readonly title: "Eval Parameters";
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/LlamaParseParameters";
            }];
            readonly title: "Llama Parse Parameters";
            readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
        };
        readonly data_sink: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/DataSink";
            }];
            readonly title: "Data Sink";
            readonly description: "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["configured_transformations", "id", "name", "project_id"];
    readonly title: "Pipeline";
    readonly description: "Schema for a pipeline.";
};
declare const $PipelineCreate: {
    readonly properties: {
        readonly embedding_config: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EmbeddingConfig";
            }];
            readonly title: "Embedding Config";
            readonly description: "Configuration for the embedding model.";
        };
        readonly transform_config: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/TransformConfig";
            }];
            readonly title: "Transform Config";
            readonly description: "Configuration for the transformation.";
        };
        readonly configured_transformations: {
            readonly items: {
                readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
            };
            readonly type: "array";
            readonly title: "Configured Transformations";
            readonly description: "List of configured transformations.";
        };
        readonly data_sink_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Sink Id";
            readonly description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.";
        };
        readonly data_sink: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/DataSinkCreate";
            }];
            readonly title: "Data Sink";
            readonly description: "Data sink. When provided instead of data_sink_id, the data sink will be created.";
        };
        readonly preset_retrieval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PresetRetrievalParams";
            }];
            readonly title: "Preset Retrieval Parameters";
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }];
            readonly title: "Eval Parameters";
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/LlamaParseParameters";
            }];
            readonly title: "Llama Parse Parameters";
            readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly pipeline_type: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PipelineType";
            }];
            readonly description: "Type of pipeline. Either PLAYGROUND or MANAGED.";
            readonly default: "MANAGED";
        };
        readonly managed_pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "PipelineCreate";
    readonly description: "Schema for creating a pipeline.";
};
declare const $PipelineDataSource: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/CloudS3DataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSharepointDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudSlackDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
                }, {
                    readonly $ref: "#/components/schemas/CloudJiraDataSource";
                }];
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source.";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "source_type", "component", "project_id", "data_source_id", "pipeline_id"];
    readonly title: "PipelineDataSource";
    readonly description: "Schema for a data source in a pipeline.";
};
declare const $PipelineDataSourceCreate: {
    readonly properties: {
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["data_source_id"];
    readonly title: "PipelineDataSourceCreate";
    readonly description: "Schema for creating an association between a data source and a pipeline.";
};
declare const $PipelineDeployment: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly status: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/ManagedIngestionStatus";
            }];
            readonly description: "Status of the pipeline deployment.";
        };
        readonly started_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Started At";
            readonly description: "Time the pipeline deployment started.";
        };
        readonly ended_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Ended At";
            readonly description: "Time the pipeline deployment finished.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status"];
    readonly title: "PipelineDeployment";
    readonly description: "Base schema model containing common database fields.";
};
declare const $PipelineFile: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly file_size: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly file_type: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "File Type";
            readonly description: "File type (e.g. pdf, docx, etc.)";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the file belongs to";
        };
        readonly last_modified_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The ID of the file";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the file is associated with";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "project_id", "pipeline_id"];
    readonly title: "PipelineFile";
    readonly description: "Schema for a file that is associated with a pipeline.";
};
declare const $PipelineFileCreate: {
    readonly properties: {
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The ID of the file";
        };
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
    };
    readonly type: "object";
    readonly required: readonly ["file_id"];
    readonly title: "PipelineFileCreate";
    readonly description: "Schema for creating a file that is associated with a pipeline.";
};
declare const $PipelineFileUpdate: {
    readonly properties: {
        readonly custom_metadata: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }];
            };
            readonly type: "object";
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
    };
    readonly type: "object";
    readonly title: "PipelineFileUpdate";
    readonly description: "Schema for updating a file that is associated with a pipeline.";
};
declare const $PipelineType: {
    readonly type: "string";
    readonly enum: readonly ["PLAYGROUND", "MANAGED"];
    readonly title: "PipelineType";
    readonly description: "Enum for representing the type of a pipeline";
};
declare const $PipelineUpdate: {
    readonly properties: {
        readonly embedding_config: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EmbeddingConfig";
            }];
            readonly title: "Embedding Config";
            readonly description: "Configuration for the embedding model.";
        };
        readonly transform_config: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/TransformConfig";
            }];
            readonly title: "Transform Config";
            readonly description: "Configuration for the transformation.";
        };
        readonly configured_transformations: {
            readonly items: {
                readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
            };
            readonly type: "array";
            readonly title: "Configured Transformations";
            readonly description: "List of configured transformations.";
        };
        readonly data_sink_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Sink Id";
            readonly description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.";
        };
        readonly data_sink: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/DataSinkCreate";
            }];
            readonly title: "Data Sink";
            readonly description: "Data sink. When provided instead of data_sink_id, the data sink will be created.";
        };
        readonly preset_retrieval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/PresetRetrievalParams";
            }];
            readonly title: "Preset Retrieval Parameters";
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }];
            readonly title: "Eval Parameters";
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/LlamaParseParameters";
            }];
            readonly title: "Llama Parse Parameters";
            readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
        };
        readonly managed_pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
    };
    readonly type: "object";
    readonly title: "PipelineUpdate";
    readonly description: "Schema for updating a pipeline.";
};
declare const $Pooling: {
    readonly type: "string";
    readonly enum: readonly ["cls", "mean", "last"];
    readonly title: "Pooling";
    readonly description: "Enum of possible pooling choices with pooling behaviors.";
};
declare const $PresetRetrievalParams: {
    readonly properties: {
        readonly dense_similarity_top_k: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Dense Similarity Top K";
            readonly description: "Number of nodes for dense retrieval.";
            readonly default: 30;
        };
        readonly sparse_similarity_top_k: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Sparse Similarity Top K";
            readonly description: "Number of nodes for sparse retrieval.";
            readonly default: 30;
        };
        readonly enable_reranking: {
            readonly type: "boolean";
            readonly title: "Enable Reranking";
            readonly description: "Enable reranking for retrieval";
            readonly default: true;
        };
        readonly rerank_top_n: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Rerank Top N";
            readonly description: "Number of reranked nodes for returning.";
            readonly default: 3;
        };
        readonly alpha: {
            readonly type: "number";
            readonly maximum: 1;
            readonly minimum: 0;
            readonly title: "Alpha";
            readonly description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.";
            readonly default: 0.5;
        };
        readonly search_filters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/MetadataFilters";
            }];
            readonly title: "Search Filters";
            readonly description: "Search filters for retrieval.";
        };
        readonly files_top_k: {
            readonly type: "integer";
            readonly maximum: 5;
            readonly minimum: 1;
            readonly title: "Files Top K";
            readonly description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).";
            readonly default: 1;
        };
        readonly retrieval_mode: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/RetrievalMode";
            }];
            readonly description: "The retrieval mode for the query.";
            readonly default: "chunks";
        };
    };
    readonly type: "object";
    readonly title: "PresetRetrievalParams";
    readonly description: "Schema for the search params for an retrieval execution that can be preset for a pipeline.";
};
declare const $PresignedUrl: {
    readonly properties: {
        readonly url: {
            readonly type: "string";
            readonly maxLength: 65536;
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Url";
            readonly description: "A presigned URL for IO operations against a private file";
        };
        readonly expires_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Expires At";
            readonly description: "The time at which the presigned URL expires";
        };
        readonly form_fields: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Form Fields";
            readonly description: "Form fields for a presigned POST request";
        };
    };
    readonly type: "object";
    readonly required: readonly ["url", "expires_at"];
    readonly title: "PresignedUrl";
    readonly description: "Schema for a presigned URL.";
};
declare const $Project: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly ad_hoc_eval_dataset_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Ad Hoc Eval Dataset Id";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The Organization ID the project is under.";
        };
        readonly is_default: {
            readonly type: "boolean";
            readonly title: "Is Default";
            readonly description: "Whether this project is the default project for the user.";
            readonly default: false;
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "id", "organization_id"];
    readonly title: "Project";
    readonly description: "Schema for a project.";
};
declare const $ProjectCreate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "ProjectCreate";
    readonly description: "Schema for creating a project.";
};
declare const $ProjectUpdate: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "ProjectUpdate";
    readonly description: "Schema for updating a project.";
};
declare const $PromptMixinPrompts: {
    readonly properties: {
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project.";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "The ID of the prompt set.";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the prompt set.";
        };
        readonly prompts: {
            readonly items: {
                readonly $ref: "#/components/schemas/PromptSpec";
            };
            readonly type: "array";
            readonly title: "Prompts";
            readonly description: "The prompts.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["project_id", "name", "prompts"];
    readonly title: "PromptMixinPrompts";
    readonly description: "Schema for the prompts derived from the PromptMixin.";
};
declare const $PromptSpec: {
    readonly properties: {
        readonly prompt_key: {
            readonly type: "string";
            readonly title: "Prompt Key";
            readonly description: "The key of the prompt in the PromptMixin.";
        };
        readonly prompt_class: {
            readonly type: "string";
            readonly title: "Prompt Class";
            readonly description: "The class of the prompt (PromptTemplate or ChatPromptTemplate).";
        };
        readonly prompt_type: {
            readonly type: "string";
            readonly title: "Prompt Type";
            readonly description: "The type of prompt.";
        };
        readonly template: {
            readonly type: "string";
            readonly title: "Template";
            readonly description: "The template of the prompt.";
        };
        readonly message_templates: {
            readonly items: {
                readonly $ref: "#/components/schemas/ChatMessage";
            };
            readonly type: "array";
            readonly title: "Message Templates";
            readonly description: "The chat message templates of the prompt.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["prompt_key", "prompt_class", "prompt_type"];
    readonly title: "PromptSpec";
};
declare const $PydanticProgramMode: {
    readonly type: "string";
    readonly enum: readonly ["default", "openai", "llm", "function", "guidance", "lm-format-enforcer"];
    readonly title: "PydanticProgramMode";
    readonly description: "Pydantic program mode.";
};
declare const $RelatedNodeInfo: {
    readonly properties: {
        readonly node_id: {
            readonly type: "string";
            readonly title: "Node Id";
        };
        readonly node_type: {
            readonly $ref: "#/components/schemas/ObjectType";
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly hash: {
            readonly type: "string";
            readonly title: "Hash";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "RelatedNodeInfo";
        };
    };
    readonly type: "object";
    readonly required: readonly ["node_id"];
    readonly title: "RelatedNodeInfo";
    readonly description: "Base component object to capture class names.";
};
declare const $RetrievalMode: {
    readonly type: "string";
    readonly enum: readonly ["chunks", "files_via_metadata", "files_via_content"];
    readonly title: "RetrievalMode";
    readonly description: "An enumeration.";
};
declare const $RetrievalParams: {
    readonly properties: {
        readonly dense_similarity_top_k: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Dense Similarity Top K";
            readonly description: "Number of nodes for dense retrieval.";
            readonly default: 30;
        };
        readonly sparse_similarity_top_k: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Sparse Similarity Top K";
            readonly description: "Number of nodes for sparse retrieval.";
            readonly default: 30;
        };
        readonly enable_reranking: {
            readonly type: "boolean";
            readonly title: "Enable Reranking";
            readonly description: "Enable reranking for retrieval";
            readonly default: true;
        };
        readonly rerank_top_n: {
            readonly type: "integer";
            readonly maximum: 100;
            readonly minimum: 1;
            readonly title: "Rerank Top N";
            readonly description: "Number of reranked nodes for returning.";
            readonly default: 3;
        };
        readonly alpha: {
            readonly type: "number";
            readonly maximum: 1;
            readonly minimum: 0;
            readonly title: "Alpha";
            readonly description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.";
            readonly default: 0.5;
        };
        readonly search_filters: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/MetadataFilters";
            }];
            readonly title: "Search Filters";
            readonly description: "Search filters for retrieval.";
        };
        readonly files_top_k: {
            readonly type: "integer";
            readonly maximum: 5;
            readonly minimum: 1;
            readonly title: "Files Top K";
            readonly description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).";
            readonly default: 1;
        };
        readonly retrieval_mode: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/RetrievalMode";
            }];
            readonly description: "The retrieval mode for the query.";
            readonly default: "chunks";
        };
        readonly query: {
            readonly type: "string";
            readonly title: "Query";
            readonly description: "The query to retrieve against.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["query"];
    readonly title: "RetrievalParams";
    readonly description: "Schema for the search params for an retrieval execution.";
};
declare const $RetrieveResults: {
    readonly properties: {
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the query was retrieved against.";
        };
        readonly retrieval_nodes: {
            readonly items: {
                readonly $ref: "#/components/schemas/TextNodeWithScore";
            };
            readonly type: "array";
            readonly title: "Retrieval Nodes";
            readonly description: "The nodes retrieved by the pipeline for the given query.";
        };
        readonly retrieval_latency: {
            readonly additionalProperties: {
                readonly type: "number";
            };
            readonly type: "object";
            readonly title: "Retrieval Latency";
            readonly description: "The end-to-end latency for retrieval and reranking.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "RetrieveResults";
        };
    };
    readonly type: "object";
    readonly required: readonly ["pipeline_id", "retrieval_nodes", "retrieval_latency"];
    readonly title: "RetrieveResults";
    readonly description: "Schema for the result of an retrieval execution.";
};
declare const $SentenceSplitter: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "The token chunk size for each chunk.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly description: "The token overlap of each chunk when splitting.";
            readonly default: 200;
            readonly gte: 0;
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly description: "Default separator for splitting into words";
            readonly default: " ";
        };
        readonly paragraph_separator: {
            readonly type: "string";
            readonly title: "Paragraph Separator";
            readonly description: "Separator between paragraphs.";
            readonly default: "\n\n\n";
        };
        readonly secondary_chunking_regex: {
            readonly type: "string";
            readonly title: "Secondary Chunking Regex";
            readonly description: "Backup regex for splitting into sentences.";
            readonly default: "[^,.;]+[,.;]?";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "SentenceSplitter";
        };
    };
    readonly type: "object";
    readonly title: "SentenceSplitter";
    readonly description: "Parse text with a preference for complete sentences.\n\nIn general, this class tries to keep sentences and paragraphs together. Therefore\ncompared to the original TokenTextSplitter, there are less likely to be\nhanging sentences or parts of sentences at the end of the node chunk.";
};
declare const $SimpleFileNodeParser: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "SimpleFileNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "SimpleFileNodeParser";
    readonly description: "Simple file node parser.\n\nSplits a document loaded from a file into Nodes using logic based on the file type\nautomatically detects the NodeParser to use based on file type\n\nArgs:\n    include_metadata (bool): whether to include metadata in nodes\n    include_prev_next_rel (bool): whether to include prev/next relationships";
};
declare const $StatusEnum: {
    readonly type: "string";
    readonly enum: readonly ["PENDING", "SUCCESS", "ERROR", "PARTIAL_SUCCESS"];
    readonly title: "StatusEnum";
    readonly description: "Enum for representing the status of a job";
};
declare const $SupportedEvalLLMModel: {
    readonly properties: {
        readonly name: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/SupportedEvalLLMModelNames";
            }];
            readonly description: "The name of the supported eval LLM model.";
        };
        readonly details: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/EvalLLMModelData";
            }];
            readonly title: "Details";
            readonly description: "The details of the supported eval LLM model.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "details"];
    readonly title: "SupportedEvalLLMModel";
    readonly description: "Response Schema for a supported eval LLM model.";
};
declare const $SupportedEvalLLMModelNames: {
    readonly type: "string";
    readonly enum: readonly ["GPT_3_5_TURBO", "GPT_4", "GPT_4_TURBO"];
    readonly title: "SupportedEvalLLMModelNames";
    readonly description: "An enumeration.";
};
declare const $TextNode: {
    readonly properties: {
        readonly id_: {
            readonly type: "string";
            readonly title: "Id ";
            readonly description: "Unique ID of the node.";
        };
        readonly embedding: {
            readonly items: {
                readonly type: "number";
            };
            readonly type: "array";
            readonly title: "Embedding";
            readonly description: "Embedding of the node.";
        };
        readonly extra_info: {
            readonly type: "object";
            readonly title: "Extra Info";
            readonly description: "A flat dictionary of metadata fields";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly description: "Metadata keys that are excluded from text for the embed model.";
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly description: "Metadata keys that are excluded from text for the LLM.";
        };
        readonly relationships: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/RelatedNodeInfo";
                }, {
                    readonly items: {
                        readonly $ref: "#/components/schemas/RelatedNodeInfo";
                    };
                    readonly type: "array";
                }];
            };
            readonly type: "object";
            readonly title: "Relationships";
            readonly description: "A mapping of relationships to other node information.";
        };
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
            readonly description: "Text content of the node.";
            readonly default: "";
        };
        readonly mimetype: {
            readonly type: "string";
            readonly title: "Mimetype";
            readonly description: "MIME type of the node content.";
            readonly default: "text/plain";
        };
        readonly start_char_idx: {
            readonly type: "integer";
            readonly title: "Start Char Idx";
            readonly description: "Start char index of the node.";
        };
        readonly end_char_idx: {
            readonly type: "integer";
            readonly title: "End Char Idx";
            readonly description: "End char index of the node.";
        };
        readonly text_template: {
            readonly type: "string";
            readonly title: "Text Template";
            readonly description: "Template for how text is formatted, with {content} and {metadata_str} placeholders.";
            readonly default: "{metadata_str}\n\n{content}";
        };
        readonly metadata_template: {
            readonly type: "string";
            readonly title: "Metadata Template";
            readonly description: "Template for how metadata is formatted, with {key} and {value} placeholders.";
            readonly default: "{key}: {value}";
        };
        readonly metadata_seperator: {
            readonly type: "string";
            readonly title: "Metadata Seperator";
            readonly description: "Separator between metadata fields when converting to string.";
            readonly default: "\n";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "TextNode";
        };
    };
    readonly type: "object";
    readonly title: "TextNode";
    readonly description: "Base node Object.\n\nGeneric abstract interface for retrievable nodes";
};
declare const $TextNodeWithScore: {
    readonly properties: {
        readonly node: {
            readonly $ref: "#/components/schemas/TextNode";
        };
        readonly score: {
            readonly type: "number";
            readonly title: "Score";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "NodeWithScore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["node"];
    readonly title: "TextNodeWithScore";
    readonly description: "Same as NodeWithScore but type for node is a TextNode instead of BaseNode.\nFastAPI doesn't accept abstract classes like BaseNode.";
};
declare const $TokenTextSplitter: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly type: "object";
            readonly title: "Callback Manager";
            readonly default: {};
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "The token chunk size for each chunk.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly description: "The token overlap of each chunk when splitting.";
            readonly default: 20;
            readonly gte: 0;
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly description: "Default separator for splitting into words";
            readonly default: " ";
        };
        readonly backup_separators: {
            readonly items: {};
            readonly type: "array";
            readonly title: "Backup Separators";
            readonly description: "Additional separators for splitting.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "TokenTextSplitter";
        };
    };
    readonly type: "object";
    readonly title: "TokenTextSplitter";
    readonly description: "Implementation of splitting text that looks at word tokens.";
};
declare const $TransformConfig: {
    readonly properties: {
        readonly mode: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/TransformConfigMode";
            }];
            readonly description: "Mode for the transformation configuration.";
            readonly default: "AUTO";
        };
        readonly config: {
            readonly allOf: readonly [{
                readonly $ref: "#/components/schemas/AutoTransformConfig";
            }];
            readonly title: "Config";
            readonly description: "Configuration for the transformation.";
        };
    };
    readonly type: "object";
    readonly title: "TransformConfig";
};
declare const $TransformConfigMode: {
    readonly type: "string";
    readonly enum: readonly ["AUTO", "ADVANCED"];
    readonly title: "TransformConfigMode";
    readonly description: "An enumeration.";
};
declare const $TransformationCategoryNames: {
    readonly type: "string";
    readonly enum: readonly ["NODE_PARSER", "EMBEDDING"];
    readonly title: "TransformationCategoryNames";
    readonly description: "An enumeration.";
};
declare const $UserOrganization: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly email: {
            readonly type: "string";
            readonly format: "email";
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
        readonly pending: {
            readonly type: "boolean";
            readonly title: "Pending";
            readonly description: "Whether the user's membership is pending account signup.";
            readonly default: true;
        };
        readonly invited_by_user_id: {
            readonly type: "string";
            readonly title: "Invited By User Id";
            readonly description: "The user ID of the user who added the user to the organization.";
        };
        readonly invited_by_user_email: {
            readonly type: "string";
            readonly format: "email";
            readonly title: "Invited By User Email";
            readonly description: "The email address of the user who added the user to the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "email", "organization_id"];
    readonly title: "UserOrganization";
    readonly description: "Schema for a user's membership to an organization.";
};
declare const $UserOrganizationCreate: {
    readonly properties: {
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly email: {
            readonly type: "string";
            readonly format: "email";
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
    };
    readonly type: "object";
    readonly title: "UserOrganizationCreate";
    readonly description: "Schema for creating a user's membership to an organization.";
};
declare const $UserOrganizationDelete: {
    readonly properties: {
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly email: {
            readonly type: "string";
            readonly format: "email";
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
    };
    readonly type: "object";
    readonly title: "UserOrganizationDelete";
    readonly description: "Schema for deleting a user's membership to an organization.";
};
declare const $ValidationError: {
    readonly properties: {
        readonly loc: {
            readonly items: {
                readonly anyOf: readonly [{
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }];
            };
            readonly type: "array";
            readonly title: "Location";
        };
        readonly msg: {
            readonly type: "string";
            readonly title: "Message";
        };
        readonly type: {
            readonly type: "string";
            readonly title: "Error Type";
        };
    };
    readonly type: "object";
    readonly required: readonly ["loc", "msg", "type"];
    readonly title: "ValidationError";
};

/**
 * Schema for an API Key.
 */
type APIKey = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    name?: string;
    user_id: string;
    redacted_api_key: string;
};
/**
 * Schema for creating an API key.
 */
type APIKeyCreate = {
    name?: string;
};
/**
 * Schema for updating an API key.
 */
type APIKeyUpdate = {
    name?: string;
};
type AutoTransformConfig = {
    /**
     * Chunk size for the transformation.
     */
    chunk_size?: number;
    /**
     * Chunk overlap for the transformation.
     */
    chunk_overlap?: number;
};
/**
 * OpenAI class for embeddings.
 *
 * Args:
 * mode (str): Mode for embedding.
 * Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.
 * Options are:
 *
 * - OpenAIEmbeddingMode.SIMILARITY_MODE
 * - OpenAIEmbeddingMode.TEXT_SEARCH_MODE
 *
 * model (str): Model for embedding.
 * Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.
 * Options are:
 *
 * - OpenAIEmbeddingModelType.DAVINCI
 * - OpenAIEmbeddingModelType.CURIE
 * - OpenAIEmbeddingModelType.BABBAGE
 * - OpenAIEmbeddingModelType.ADA
 * - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002
 */
type AzureOpenAIEmbedding = {
    /**
     * The name of the embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * Additional kwargs for the OpenAI API.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    /**
     * The OpenAI API key.
     */
    api_key: string;
    /**
     * The base URL for Azure deployment.
     */
    api_base?: string;
    /**
     * The version for Azure OpenAI API.
     */
    api_version?: string;
    /**
     * Maximum number of retries.
     */
    max_retries?: number;
    /**
     * Timeout for each request.
     */
    timeout?: number;
    /**
     * The default headers for API requests.
     */
    default_headers?: {
        [key: string]: string;
    };
    /**
     * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
     */
    reuse_client?: boolean;
    /**
     * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
     */
    dimensions?: number;
    /**
     * The Azure endpoint to use.
     */
    azure_endpoint?: string;
    /**
     * The Azure deployment to use.
     */
    azure_deployment?: string;
    /**
     * Indicates if Microsoft Entra ID (former Azure AD) is used for token authentication
     */
    use_azure_ad: boolean;
    class_name?: string;
};
type Base = {
    [key: string]: unknown;
};
/**
 * Chainable mixin.
 *
 * A module that can produce a `QueryComponent` from a set of inputs through
 * `as_query_component`.
 *
 * If plugged in directly into a `QueryPipeline`, the `ChainableMixin` will be
 * converted into a `QueryComponent` with default parameters.
 */
type BasePromptTemplate = {
    metadata: {
        [key: string]: unknown;
    };
    template_vars: Array<string>;
    kwargs: {
        [key: string]: string;
    };
    output_parser?: {
        [key: string]: unknown;
    };
    /**
     * Template variable mappings (Optional).
     */
    template_var_mappings?: {
        [key: string]: unknown;
    };
};
/**
 * Base class for embeddings.
 */
type BedrockEmbedding = {
    /**
     * The modelId of the Bedrock model to use.
     */
    model_name: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * The name of aws profile to use. If not given, then the default profile is used.
     */
    profile_name?: string;
    /**
     * AWS Access Key ID to use
     */
    aws_access_key_id?: string;
    /**
     * AWS Secret Access Key to use
     */
    aws_secret_access_key?: string;
    /**
     * AWS Session Token to use
     */
    aws_session_token?: string;
    /**
     * AWS region name to use. Uses region configured in AWS CLI if not passed
     */
    region_name?: string;
    /**
     * Use this Botocore session instead of creating a new default one.
     */
    botocore_session?: unknown;
    /**
     * Custom configuration object to use instead of the default generated one.
     */
    botocore_config?: unknown;
    /**
     * The maximum number of API retries.
     */
    max_retries?: number;
    /**
     * The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.
     */
    timeout?: number;
    /**
     * Additional kwargs for the bedrock client.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
type Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put = {
    upload_file: Blob | File;
};
type Body_upload_file_api_parsing_upload_post = {
    language?: Array<ParserLanguages>;
    parsing_instruction?: string;
    skip_diagonal_text?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    gpt4o_mode?: boolean;
    fast_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: boolean;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
    file: Blob | File;
};
type Body_upload_file_api_v1_files_post = {
    upload_file: Blob | File;
};
type Body_upload_file_api_v1_parsing_upload_post = {
    language?: Array<ParserLanguages>;
    parsing_instruction?: string;
    skip_diagonal_text?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    gpt4o_mode?: boolean;
    fast_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: boolean;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
    file: Blob | File;
};
/**
 * Base schema model for BaseComponent classes used in the platform.
 * Comes with special serialization logic for types used commonly in platform codebase.
 */
type ChatData = {
    retrieval_parameters: PresetRetrievalParams;
    class_name?: string;
};
/**
 * Chat message.
 */
type ChatMessage = {
    role?: MessageRole;
    content?: unknown;
    additional_kwargs?: {
        [key: string]: unknown;
    };
};
/**
 * Base schema model for BaseComponent classes used in the platform.
 * Comes with special serialization logic for types used commonly in platform codebase.
 */
type ChatParams = {
    messages: Array<ChatMessage>;
    data: ChatData;
    class_name?: string;
};
type CheckoutSessionCreatePayload = {
    success_url: string;
    cancel_url: string;
};
/**
 * Base component object to capture class names.
 */
type CloudAzStorageBlobDataSource = {
    /**
     * The name of the Azure Storage Blob container to read from.
     */
    container_name: string;
    /**
     * The Azure Storage Blob account URL to use for authentication.
     */
    account_url: string;
    /**
     * The blob name to read from.
     */
    blob?: string;
    /**
     * The prefix of the Azure Storage Blob objects to read from.
     */
    prefix?: string;
    /**
     * The Azure Storage Blob account name to use for authentication.
     */
    account_name: string;
    /**
     * The Azure Storage Blob account key to use for authentication.
     */
    account_key: string;
    class_name?: string;
};
/**
 * Cloud Azure AI Search Vector Store.
 */
type CloudAzureAISearchVectorStore = {
    supports_nested_metadata_filters?: true;
    search_service_api_key: string;
    search_service_endpoint: string;
    search_service_api_version?: string;
    index_name?: string;
    filterable_metadata_field_keys?: {
        [key: string]: unknown;
    };
    embedding_dimension?: number;
    class_name?: string;
};
/**
 * Base class for cloud vector stores.
 */
type CloudChromaVectorStore = {
    supports_nested_metadata_filters?: false;
    collection_name?: string;
    host?: string;
    port?: string;
    ssl: boolean;
    headers?: {
        [key: string]: string;
    };
    persist_dir?: string;
    collection_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudConfluenceDataSource = {
    /**
     * The server URL of the Confluence instance.
     */
    server_url: string;
    /**
     * Type of Authentication for connecting to Confluence APIs.
     */
    authentication_mechanism: string;
    /**
     * The username to use for authentication.
     */
    user_name?: string;
    /**
     * The API token to use for authentication.
     */
    api_token?: string;
    /**
     * The space key to read from.
     */
    space_key?: string;
    /**
     * The page IDs of the Confluence to read from.
     */
    page_ids?: string;
    /**
     * The CQL query to use for fetching pages.
     */
    cql?: string;
    /**
     * The label to use for fetching pages.
     */
    label?: string;
    class_name?: string;
};
/**
 * Cloud document stored in S3.
 */
type CloudDocument = {
    text: string;
    metadata: {
        [key: string]: unknown;
    };
    excluded_embed_metadata_keys?: Array<string>;
    excluded_llm_metadata_keys?: Array<string>;
    id: string;
};
/**
 * Create a new cloud document.
 */
type CloudDocumentCreate = {
    text: string;
    metadata: {
        [key: string]: unknown;
    };
    excluded_embed_metadata_keys?: Array<string>;
    excluded_llm_metadata_keys?: Array<string>;
    id?: string;
};
/**
 * Cloud Jira Data Source integrating JiraReader.
 */
type CloudJiraDataSource = {
    /**
     * The email address to use for authentication.
     */
    email?: string;
    /**
     * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
     */
    api_token?: string;
    /**
     * The server url for Jira Cloud.
     */
    server_url?: string;
    /**
     * The cloud ID, used in case of OAuth2.
     */
    cloud_id?: string;
    /**
     * Type of Authentication for connecting to Jira APIs.
     */
    authentication_mechanism: string;
    /**
     * JQL (Jira Query Language) query to search.
     */
    query: string;
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudNotionPageDataSource = {
    /**
     * The integration token to use for authentication.
     */
    integration_token: string;
    /**
     * The Notion Database Id to read content from.
     */
    database_ids?: string;
    /**
     * The Page ID's of the Notion to read from.
     */
    page_ids?: string;
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudOneDriveDataSource = {
    /**
     * The user principal name to use for authentication.
     */
    user_principal_name: string;
    /**
     * The path of the OneDrive folder to read from.
     */
    folder_path?: string;
    /**
     * The ID of the OneDrive folder to read from.
     */
    folder_id?: string;
    /**
     * The client ID to use for authentication.
     */
    client_id: string;
    /**
     * The client secret to use for authentication.
     */
    client_secret: string;
    /**
     * The tenant ID to use for authentication.
     */
    tenant_id: string;
    class_name?: string;
};
/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
type CloudPineconeVectorStore = {
    supports_nested_metadata_filters?: true;
    api_key: string;
    index_name: string;
    namespace?: string;
    insert_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Base class for cloud vector stores.
 */
type CloudPostgresVectorStore = {
    supports_nested_metadata_filters?: false;
    connection_string: string;
    async_connection_string: string;
    table_name: string;
    schema_name: string;
    embed_dim: number;
    hybrid_search: boolean;
    text_search_config: string;
    cache_ok: boolean;
    perform_setup: boolean;
    debug: boolean;
    use_jsonb: boolean;
    class_name?: string;
};
/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
type CloudQdrantVectorStore = {
    supports_nested_metadata_filters?: true;
    collection_name: string;
    url: string;
    api_key: string;
    max_retries?: number;
    client_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudS3DataSource = {
    /**
     * The name of the S3 bucket to read from.
     */
    bucket: string;
    /**
     * The prefix of the S3 objects to read from.
     */
    prefix?: string;
    /**
     * The AWS access ID to use for authentication.
     */
    aws_access_id?: string;
    /**
     * The AWS access secret to use for authentication.
     */
    aws_access_secret?: string;
    /**
     * The S3 endpoint URL to use for authentication.
     */
    s3_endpoint_url?: string;
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudSharepointDataSource = {
    /**
     * The name of the SharePoint site to download from.
     */
    site_name: string;
    /**
     * The path of the Sharepoint folder to read from.
     */
    folder_path?: string;
    /**
     * The ID of the Sharepoint folder to read from.
     */
    folder_id?: string;
    /**
     * The name of the Sharepoint drive to read from.
     */
    drive_name?: string;
    /**
     * The client ID to use for authentication.
     */
    client_id: string;
    /**
     * The client secret to use for authentication.
     */
    client_secret: string;
    /**
     * The tenant ID to use for authentication.
     */
    tenant_id: string;
    class_name?: string;
};
/**
 * Base component object to capture class names.
 */
type CloudSlackDataSource = {
    /**
     * Slack Bot Token.
     */
    slack_token: string;
    /**
     * Slack Channel.
     */
    channel_ids?: string;
    /**
     * Latest date.
     */
    latest_date?: string;
    /**
     * Earliest date.
     */
    earliest_date?: string;
    /**
     * Earliest date timestamp.
     */
    earliest_date_timestamp?: number;
    /**
     * Latest date timestamp.
     */
    latest_date_timestamp?: number;
    /**
     * Slack Channel name pattern.
     */
    channel_patterns?: string;
    class_name?: string;
};
/**
 * Base class for cloud vector stores.
 */
type CloudWeaviateVectorStore = {
    supports_nested_metadata_filters?: false;
    index_name: string;
    url?: string;
    text_key: string;
    auth_config?: {
        [key: string]: unknown;
    };
    client_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Split code using a AST parser.
 *
 * Thank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.
 * https://docs.sweep.dev/blogs/chunking-2m-files
 */
type CodeSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The programming language of the code being split.
     */
    language: string;
    /**
     * The number of lines to include in each chunk.
     */
    chunk_lines?: number;
    /**
     * How many lines of code each chunk overlaps with.
     */
    chunk_lines_overlap?: number;
    /**
     * Maximum number of characters per chunk.
     */
    max_chars?: number;
    class_name?: string;
};
/**
 * CohereEmbedding uses the Cohere API to generate embeddings for text.
 */
type CohereEmbedding = {
    /**
     * The name of the embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * The Cohere API key.
     */
    api_key: string;
    /**
     * Truncation type - START/ END/ NONE
     */
    truncate: string;
    /**
     * Model Input type. If not provided, search_document and search_query are used when needed.
     */
    input_type?: string;
    /**
     * Embedding type. If not provided float embedding_type is used when needed.
     */
    embedding_type: string;
    class_name?: string;
};
/**
 * An enumeration.
 */
type ConfigurableDataSinkNames = "CHROMA" | "PINECONE" | "POSTGRES" | "QDRANT" | "WEAVIATE" | "AZUREAI_SEARCH";
/**
 * An enumeration.
 */
declare const ConfigurableDataSinkNames: {
    readonly CHROMA: "CHROMA";
    readonly PINECONE: "PINECONE";
    readonly POSTGRES: "POSTGRES";
    readonly QDRANT: "QDRANT";
    readonly WEAVIATE: "WEAVIATE";
    readonly AZUREAI_SEARCH: "AZUREAI_SEARCH";
};
/**
 * An enumeration.
 */
type ConfigurableDataSourceNames = "S3" | "AZURE_STORAGE_BLOB" | "MICROSOFT_ONEDRIVE" | "MICROSOFT_SHAREPOINT" | "SLACK" | "NOTION_PAGE" | "CONFLUENCE" | "JIRA";
/**
 * An enumeration.
 */
declare const ConfigurableDataSourceNames: {
    readonly S3: "S3";
    readonly AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB";
    readonly MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE";
    readonly MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT";
    readonly SLACK: "SLACK";
    readonly NOTION_PAGE: "NOTION_PAGE";
    readonly CONFLUENCE: "CONFLUENCE";
    readonly JIRA: "JIRA";
};
/**
 * Schema for a transformation definition.
 */
type ConfigurableTransformationDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of TransformationDefinition objects
     */
    configurable_transformation_type: ConfigurableTransformationNames;
    /**
     * The transformation_category field will be used to group transformations in the UI
     */
    transformation_category: TransformationCategoryNames;
};
/**
 * An enumeration.
 */
type ConfigurableTransformationNames = "CODE_NODE_PARSER" | "SENTENCE_AWARE_NODE_PARSER" | "TOKEN_AWARE_NODE_PARSER" | "HTML_NODE_PARSER" | "MARKDOWN_NODE_PARSER" | "JSON_NODE_PARSER" | "SIMPLE_FILE_NODE_PARSER" | "MARKDOWN_ELEMENT_NODE_PARSER" | "OPENAI_EMBEDDING" | "AZURE_EMBEDDING" | "COHERE_EMBEDDING" | "BEDROCK_EMBEDDING" | "HUGGINGFACE_API_EMBEDDING" | "GEMINI_EMBEDDING";
/**
 * An enumeration.
 */
declare const ConfigurableTransformationNames: {
    readonly CODE_NODE_PARSER: "CODE_NODE_PARSER";
    readonly SENTENCE_AWARE_NODE_PARSER: "SENTENCE_AWARE_NODE_PARSER";
    readonly TOKEN_AWARE_NODE_PARSER: "TOKEN_AWARE_NODE_PARSER";
    readonly HTML_NODE_PARSER: "HTML_NODE_PARSER";
    readonly MARKDOWN_NODE_PARSER: "MARKDOWN_NODE_PARSER";
    readonly JSON_NODE_PARSER: "JSON_NODE_PARSER";
    readonly SIMPLE_FILE_NODE_PARSER: "SIMPLE_FILE_NODE_PARSER";
    readonly MARKDOWN_ELEMENT_NODE_PARSER: "MARKDOWN_ELEMENT_NODE_PARSER";
    readonly OPENAI_EMBEDDING: "OPENAI_EMBEDDING";
    readonly AZURE_EMBEDDING: "AZURE_EMBEDDING";
    readonly COHERE_EMBEDDING: "COHERE_EMBEDDING";
    readonly BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING";
    readonly HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING";
    readonly GEMINI_EMBEDDING: "GEMINI_EMBEDDING";
};
/**
 * Configured transformations for pipelines.
 *
 * Similar to ConfigurableTransformation but includes a few
 * more fields that are useful to the platform.
 */
type ConfiguredTransformationItem = {
    id?: string;
    /**
     * Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames.
     */
    configurable_transformation_type: ConfigurableTransformationNames;
    /**
     * Component that implements the transformation
     */
    component: {
        [key: string]: unknown;
    } | CodeSplitter | SentenceSplitter | TokenTextSplitter | HTMLNodeParser | MarkdownNodeParser | JSONNodeParser | SimpleFileNodeParser | MarkdownElementNodeParser | OpenAIEmbedding | AzureOpenAIEmbedding | CohereEmbedding | BedrockEmbedding | HuggingFaceInferenceAPIEmbedding | GeminiEmbedding;
};
type CustomerPortalSessionCreatePayload = {
    return_url: string;
};
/**
 * Schema for a data sink.
 */
type DataSink = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The name of the data sink.
     */
    name: string;
    sink_type: ConfigurableDataSinkNames;
    component: {
        [key: string]: unknown;
    } | CloudChromaVectorStore | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudWeaviateVectorStore | CloudAzureAISearchVectorStore;
    project_id: string;
};
/**
 * Schema for creating a data sink.
 */
type DataSinkCreate = {
    /**
     * The name of the data sink.
     */
    name: string;
    sink_type: ConfigurableDataSinkNames;
    component: {
        [key: string]: unknown;
    } | CloudChromaVectorStore | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudWeaviateVectorStore | CloudAzureAISearchVectorStore;
};
/**
 * Schema for a data sink definition.
 */
type DataSinkDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of DataSinkDefinition objects
     */
    sink_type: ConfigurableDataSinkNames;
};
/**
 * Schema for updating a data sink.
 */
type DataSinkUpdate = {
    /**
     * The name of the data sink.
     */
    name?: string;
    sink_type: ConfigurableDataSinkNames;
    component?: {
        [key: string]: unknown;
    } | CloudChromaVectorStore | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudWeaviateVectorStore | CloudAzureAISearchVectorStore;
};
/**
 * Schema for a data source.
 */
type DataSource = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource;
    project_id: string;
};
/**
 * Schema for creating a data source.
 */
type DataSourceCreate = {
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource;
};
/**
 * Schema for a data source definition.
 */
type DataSourceDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of DataSourceDefinition objects
     */
    source_type: ConfigurableDataSourceNames;
};
/**
 * Schema for updating a data source.
 */
type DataSourceUpdate = {
    /**
     * The name of the data source.
     */
    name?: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    component?: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource;
};
/**
 * Schema for updating the default organization for a user.
 */
type DefaultOrganizationUpdate = {
    /**
     * The organization's ID.
     */
    organization_id: string;
};
type EmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: EmbeddingConfigType;
    /**
     * Configuration for the transformation.
     */
    component?: OpenAIEmbedding | AzureOpenAIEmbedding | BedrockEmbedding | CohereEmbedding | GeminiEmbedding | HuggingFaceInferenceAPIEmbedding;
};
/**
 * An enumeration.
 */
type EmbeddingConfigType = "OPENAI_EMBEDDING" | "AZURE_EMBEDDING" | "BEDROCK_EMBEDDING" | "COHERE_EMBEDDING" | "GEMINI_EMBEDDING" | "HUGGINGFACE_API_EMBEDDING";
/**
 * An enumeration.
 */
declare const EmbeddingConfigType: {
    readonly OPENAI_EMBEDDING: "OPENAI_EMBEDDING";
    readonly AZURE_EMBEDDING: "AZURE_EMBEDDING";
    readonly BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING";
    readonly COHERE_EMBEDDING: "COHERE_EMBEDDING";
    readonly GEMINI_EMBEDDING: "GEMINI_EMBEDDING";
    readonly HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING";
};
/**
 * Schema for an eval dataset.
 * Includes the other DB fields like id, created_at, & updated_at.
 */
type EvalDataset = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The name of the EvalDataset.
     */
    name: string;
    project_id: string;
};
/**
 * Schema for creating an eval dataset.
 */
type EvalDatasetCreate = {
    /**
     * The name of the EvalDataset.
     */
    name: string;
};
/**
 * Schema for the parameters of an eval dataset job.
 */
type EvalDatasetJobParams = {
    /**
     * The IDs for the EvalQuestions this execution ran against.
     */
    eval_question_ids: Array<string>;
    /**
     * The parameters for the eval execution.
     */
    eval_execution_params: EvalExecutionParams;
};
/**
 * Schema for job that evaluates an EvalDataset against a pipeline.
 */
type EvalDatasetJobRecord = {
    job_name: "eval_dataset_job";
    /**
     * The partitions for this execution. Used for determining where to save job output.
     */
    partitions: {
        [key: string]: string;
    };
    /**
     * Additional input parameters for the eval execution.
     */
    parameters?: EvalDatasetJobParams;
    /**
     * The upstream request ID that created this job. Used for tracking the job across services.
     */
    session_id?: string;
    /**
     * The correlation ID for this job. Used for tracking the job across services.
     */
    correlation_id?: string;
    /**
     * The ID of the parent job execution.
     */
    parent_job_execution_id?: string;
    /**
     * The ID of the user that created this job
     */
    user_id?: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Unique identifier
     */
    id?: string;
    status: StatusEnum;
    error_message?: string;
    /**
     * The number of times this job has been attempted
     */
    attempts?: number;
    started_at?: string;
    ended_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * Additional metadata for the job execution.
     */
    data?: Base;
};
type job_name = "eval_dataset_job";
declare const job_name: {
    readonly EVAL_DATASET_JOB: "eval_dataset_job";
};
/**
 * Schema for updating an eval dataset.
 * Only the name can be updated.
 */
type EvalDatasetUpdate = {
    /**
     * The name of the EvalDataset.
     */
    name: string;
};
/**
 * Schema for creating an eval execution for a given set of questions on a pipeline.
 */
type EvalExecutionCreate = {
    eval_question_ids: Array<string>;
    /**
     * The parameters for the eval execution that will override the ones set in the pipeline.
     */
    params?: EvalExecutionParamsOverride;
};
/**
 * Schema for the params for an eval execution.
 */
type EvalExecutionParams = {
    /**
     * The LLM model to use within eval execution.
     */
    llm_model?: SupportedEvalLLMModelNames;
    /**
     * The template to use for the question answering prompt.
     */
    qa_prompt_tmpl?: string;
};
/**
 * Schema for the params override for an eval execution.
 */
type EvalExecutionParamsOverride = {
    /**
     * The LLM model to use within eval execution.
     */
    llm_model?: SupportedEvalLLMModelNames;
    /**
     * The template to use for the question answering prompt.
     */
    qa_prompt_tmpl?: string;
};
/**
 * Schema for an eval LLM model.
 */
type EvalLLMModelData = {
    /**
     * The name of the LLM model.
     */
    name: string;
    /**
     * The description of the LLM model.
     */
    description: string;
};
/**
 * Base schema model containing common database fields.
 */
type EvalQuestion = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The content of the question.
     */
    content: string;
    eval_dataset_id: string;
    /**
     * The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.
     */
    eval_dataset_index: number;
};
type EvalQuestionCreate = {
    /**
     * The content of the question.
     */
    content: string;
};
/**
 * Schema for the result of an eval question job.
 */
type EvalQuestionResult = {
    /**
     * The ID of the question that was executed.
     */
    eval_question_id: string;
    /**
     * The ID of the pipeline that the question was executed against.
     */
    pipeline_id: string;
    /**
     * The nodes retrieved by the pipeline for the given question.
     */
    source_nodes: Array<TextNode>;
    /**
     * The answer to the question.
     */
    answer: string;
    /**
     * The eval metrics for the question.
     */
    eval_metrics: {
        [key: string]: MetricResult;
    };
    /**
     * The ID of the EvalDatasetJobRecord that this result was generated from.
     */
    eval_dataset_execution_id: string;
    /**
     * The EvalExecutionParams that were used when this result was generated.
     */
    eval_dataset_execution_params: EvalExecutionParams;
    /**
     * The timestamp when the eval finished.
     */
    eval_finished_at: string;
    class_name?: string;
};
type ExtractionJob = {
    /**
     * The id of the extraction job
     */
    id: string;
    /**
     * The status of the extraction job
     */
    status: StatusEnum;
    /**
     * The file that the extract was extracted from
     */
    file: File;
};
/**
 * Schema for creating an extraction job.
 */
type ExtractionJobCreate = {
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The id of the file
     */
    file_id: string;
};
/**
 * Schema for creating extraction jobs in batch.
 */
type ExtractionJobCreateBatch = {
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The ids of the files
     */
    file_ids: Array<string>;
};
/**
 * Schema for an extraction result.
 */
type ExtractionResult = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The data extracted from the file
     */
    data: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    /**
     * The file that the extract was extracted from
     */
    file: File;
};
/**
 * Schema for extraction schema.
 */
type ExtractionSchema = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id: string;
    /**
     * The schema of the data
     */
    data_schema?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Schema for creating an extraction schema.
 */
type ExtractionSchemaCreate = {
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id?: string;
    /**
     * The schema of the data
     */
    data_schema: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Schema for inferring an extraction schema.
 */
type ExtractionSchemaInfer = {
    /**
     * The ID of a schema to update with the new schema
     */
    schema_id?: string;
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id?: string;
    /**
     * The IDs of the files that the extraction schema contains
     */
    file_ids: Array<string>;
    /**
     * Whether to stream the results of the extraction schema
     */
    stream?: boolean;
};
/**
 * Schema for updating an extraction schema.
 */
type ExtractionSchemaUpdate = {
    /**
     * The schema of the data
     */
    data_schema?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Schema for a file.
 */
type File = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    name: string;
    /**
     * Size of the file in bytes
     */
    file_size?: number;
    /**
     * File type (e.g. pdf, docx, etc.)
     */
    file_type?: string;
    /**
     * The ID of the project that the file belongs to
     */
    project_id: string;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string;
};
type FileCreate = {
    name: string;
    /**
     * Size of the file in bytes
     */
    file_size?: number;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string;
};
/**
 * Vector store filter conditions to combine different filters.
 */
type FilterCondition = "and" | "or";
/**
 * Vector store filter conditions to combine different filters.
 */
declare const FilterCondition: {
    readonly AND: "and";
    readonly OR: "or";
};
/**
 * Vector store filter operator.
 */
type FilterOperator = "==" | ">" | "<" | "!=" | ">=" | "<=" | "in" | "nin" | "any" | "all" | "text_match" | "contains";
/**
 * Vector store filter operator.
 */
declare const FilterOperator: {
    readonly __: "<=";
    readonly _: "<";
    readonly IN: "in";
    readonly NIN: "nin";
    readonly ANY: "any";
    readonly ALL: "all";
    readonly TEXT_MATCH: "text_match";
    readonly CONTAINS: "contains";
};
/**
 * Google Gemini embeddings.
 *
 * Args:
 * model_name (str): Model for embedding.
 * Defaults to "models/embedding-001".
 *
 * api_key (Optional[str]): API key to access the model. Defaults to None.
 * api_base (Optional[str]): API base to access the model. Defaults to Official Base.
 * transport (Optional[str]): Transport to access the model.
 */
type GeminiEmbedding = {
    /**
     * The name of the embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.
     */
    title?: string;
    /**
     * The task for embedding model.
     */
    task_type?: string;
    /**
     * API key to access the model. Defaults to None.
     */
    api_key?: string;
    class_name?: string;
};
/**
 * HTML node parser.
 *
 * Splits a document into Nodes using custom HTML splitting logic.
 *
 * Args:
 * include_metadata (bool): whether to include metadata in nodes
 * include_prev_next_rel (bool): whether to include prev/next relationships
 */
type HTMLNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * HTML tags to extract text from.
     */
    tags?: Array<string>;
    class_name?: string;
};
type HTTPValidationError = {
    detail?: Array<ValidationError>;
};
/**
 * Wrapper on the Hugging Face's Inference API for embeddings.
 *
 * Overview of the design:
 * - Uses the feature extraction task: https://huggingface.co/tasks/feature-extraction
 */
type HuggingFaceInferenceAPIEmbedding = {
    /**
     * Hugging Face model name. If None, the task will be used.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * Pooling strategy. If None, the model's default pooling is used.
     */
    pooling?: Pooling;
    /**
     * Instruction to prepend during query embedding.
     */
    query_instruction?: string;
    /**
     * Instruction to prepend during text embedding.
     */
    text_instruction?: string;
    /**
     * Hugging Face token. Will default to the locally saved token. Pass token=False if you dont want to send your token to the server.
     */
    token?: string | boolean;
    /**
     * The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.
     */
    timeout?: number;
    /**
     * Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Additional cookies to send to the server.
     */
    cookies?: {
        [key: string]: string;
    };
    /**
     * Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.
     */
    task?: string;
    class_name?: string;
};
/**
 * JSON node parser.
 *
 * Splits a document into Nodes using custom JSON splitting logic.
 *
 * Args:
 * include_metadata (bool): whether to include metadata in nodes
 * include_prev_next_rel (bool): whether to include prev/next relationships
 */
type JSONNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * The LLM class is the main class for interacting with language models.
 *
 * Attributes:
 * system_prompt (Optional[str]):
 * System prompt for LLM calls.
 * messages_to_prompt (Callable):
 * Function to convert a list of messages to an LLM prompt.
 * completion_to_prompt (Callable):
 * Function to convert a completion to an LLM prompt.
 * output_parser (Optional[BaseOutputParser]):
 * Output parser to parse, validate, and correct errors programmatically.
 * pydantic_program_mode (PydanticProgramMode):
 * Pydantic program mode to use for structured prediction.
 */
type LLM = {
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * System prompt for LLM calls.
     */
    system_prompt?: string;
    /**
     * Output parser to parse, validate, and correct errors programmatically.
     */
    output_parser?: {
        [key: string]: unknown;
    };
    pydantic_program_mode?: PydanticProgramMode;
    /**
     * Query wrapper prompt for LLM calls.
     */
    query_wrapper_prompt?: BasePromptTemplate;
    class_name?: string;
};
/**
 * Settings that can be configured for how to use LlamaParse to parse files witin a LlamaCloud pipeline.
 */
type LlamaParseParameters = {
    languages?: Array<ParserLanguages>;
    parsing_instruction?: string;
    disable_ocr?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    fast_mode?: boolean;
    skip_diagonal_text?: boolean;
    gpt4o_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: string;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
};
/**
 * An enumeration.
 */
type LlamaParseSupportedFileExtensions = ".pdf" | ".doc" | ".docx" | ".docm" | ".dot" | ".dotx" | ".dotm" | ".rtf" | ".wps" | ".wpd" | ".sxw" | ".stw" | ".sxg" | ".pages" | ".mw" | ".mcw" | ".uot" | ".uof" | ".uos" | ".uop" | ".ppt" | ".pptx" | ".pot" | ".pptm" | ".potx" | ".potm" | ".key" | ".odp" | ".odg" | ".otp" | ".fopd" | ".sxi" | ".sti" | ".epub" | ".html" | ".htm" | ".xls" | ".xlsx" | ".xlsm" | ".xlsb" | ".xlw" | ".csv" | ".dif" | ".sylk" | ".slk" | ".prn" | ".numbers" | ".et" | ".ods" | ".fods" | ".uos1" | ".uos2" | ".dbf" | ".wk1" | ".wk2" | ".wk3" | ".wk4" | ".wks" | ".wq1" | ".wq2" | ".wb1" | ".wb2" | ".wb3" | ".qpw" | ".xlr" | ".eth" | ".tsv";
/**
 * An enumeration.
 */
declare const LlamaParseSupportedFileExtensions: {
    readonly _PDF: ".pdf";
    readonly _DOC: ".doc";
    readonly _DOCX: ".docx";
    readonly _DOCM: ".docm";
    readonly _DOT: ".dot";
    readonly _DOTX: ".dotx";
    readonly _DOTM: ".dotm";
    readonly _RTF: ".rtf";
    readonly _WPS: ".wps";
    readonly _WPD: ".wpd";
    readonly _SXW: ".sxw";
    readonly _STW: ".stw";
    readonly _SXG: ".sxg";
    readonly _PAGES: ".pages";
    readonly _MW: ".mw";
    readonly _MCW: ".mcw";
    readonly _UOT: ".uot";
    readonly _UOF: ".uof";
    readonly _UOS: ".uos";
    readonly _UOP: ".uop";
    readonly _PPT: ".ppt";
    readonly _PPTX: ".pptx";
    readonly _POT: ".pot";
    readonly _PPTM: ".pptm";
    readonly _POTX: ".potx";
    readonly _POTM: ".potm";
    readonly _KEY: ".key";
    readonly _ODP: ".odp";
    readonly _ODG: ".odg";
    readonly _OTP: ".otp";
    readonly _FOPD: ".fopd";
    readonly _SXI: ".sxi";
    readonly _STI: ".sti";
    readonly _EPUB: ".epub";
    readonly _HTML: ".html";
    readonly _HTM: ".htm";
    readonly _XLS: ".xls";
    readonly _XLSX: ".xlsx";
    readonly _XLSM: ".xlsm";
    readonly _XLSB: ".xlsb";
    readonly _XLW: ".xlw";
    readonly _CSV: ".csv";
    readonly _DIF: ".dif";
    readonly _SYLK: ".sylk";
    readonly _SLK: ".slk";
    readonly _PRN: ".prn";
    readonly _NUMBERS: ".numbers";
    readonly _ET: ".et";
    readonly _ODS: ".ods";
    readonly _FODS: ".fods";
    readonly _UOS1: ".uos1";
    readonly _UOS2: ".uos2";
    readonly _DBF: ".dbf";
    readonly _WK1: ".wk1";
    readonly _WK2: ".wk2";
    readonly _WK3: ".wk3";
    readonly _WK4: ".wk4";
    readonly _WKS: ".wks";
    readonly _WQ1: ".wq1";
    readonly _WQ2: ".wq2";
    readonly _WB1: ".wb1";
    readonly _WB2: ".wb2";
    readonly _WB3: ".wb3";
    readonly _QPW: ".qpw";
    readonly _XLR: ".xlr";
    readonly _ETH: ".eth";
    readonly _TSV: ".tsv";
};
/**
 * Evaluation result, EvaluationResult from llama_index.
 *
 * Output of an BaseEvaluator.
 */
type LocalEval = {
    /**
     * Query string
     */
    query?: string;
    /**
     * Context strings
     */
    contexts?: Array<string>;
    /**
     * Response string
     */
    response?: string;
    /**
     * Binary evaluation result (passing or not)
     */
    passing?: boolean;
    /**
     * Feedback or reasoning for the response
     */
    feedback?: string;
    /**
     * Score for the response
     */
    score?: number;
    /**
     * Used only for pairwise and specifies whether it is from original order of presented answers or flipped order
     */
    pairwise_source?: string;
    /**
     * Whether the evaluation result is an invalid one.
     */
    invalid_result?: boolean;
    /**
     * Reason for invalid evaluation.
     */
    invalid_reason?: string;
};
/**
 * Schema for the result of a local evaluation.
 */
type LocalEvalResults = {
    /**
     * The ID of the project.
     */
    project_id: string;
    /**
     * The ID of the local eval result set.
     */
    eval_set_id?: string;
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The name of the eval.
     */
    eval_name: string;
    /**
     * The eval results.
     */
    result: LocalEval;
};
/**
 * Schema for creating a local eval set.
 */
type LocalEvalSetCreate = {
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The eval results.
     */
    results: {
        [key: string]: Array<LocalEval>;
    };
};
type LocalEvalSets = {
    /**
     * The ID of the eval set.
     */
    eval_set_id: string;
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The time of the upload.
     */
    upload_time: string;
};
/**
 * Status of managed ingestion with partial Updates.
 */
type ManagedIngestionStatus = "NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "PARTIAL_SUCCESS";
/**
 * Status of managed ingestion with partial Updates.
 */
declare const ManagedIngestionStatus: {
    readonly NOT_STARTED: "NOT_STARTED";
    readonly IN_PROGRESS: "IN_PROGRESS";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
    readonly PARTIAL_SUCCESS: "PARTIAL_SUCCESS";
};
type ManagedIngestionStatusResponse = {
    /**
     * Status of the ingestion.
     */
    status: ManagedIngestionStatus;
};
/**
 * Markdown element node parser.
 *
 * Splits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects
 * (e.g. tables).
 */
type MarkdownElementNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * LLM model to use for summarization.
     */
    llm?: LLM;
    /**
     * Query string to use for summarization.
     */
    summary_query_str?: string;
    /**
     * Num of workers for async jobs.
     */
    num_workers?: number;
    /**
     * Whether to show progress.
     */
    show_progress?: boolean;
    /**
     * Other types of node parsers to handle some types of nodes.
     */
    nested_node_parser?: NodeParser;
    class_name?: string;
};
/**
 * Markdown node parser.
 *
 * Splits a document into Nodes using custom Markdown splitting logic.
 *
 * Args:
 * include_metadata (bool): whether to include metadata in nodes
 * include_prev_next_rel (bool): whether to include prev/next relationships
 */
type MarkdownNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Message role.
 */
type MessageRole = "system" | "user" | "assistant" | "function" | "tool" | "chatbot" | "model";
/**
 * Message role.
 */
declare const MessageRole: {
    readonly SYSTEM: "system";
    readonly USER: "user";
    readonly ASSISTANT: "assistant";
    readonly FUNCTION: "function";
    readonly TOOL: "tool";
    readonly CHATBOT: "chatbot";
    readonly MODEL: "model";
};
/**
 * Comprehensive metadata filter for vector stores to support more operators.
 *
 * Value uses Strict* types, as int, float and str are compatible types and were all
 * converted to string before.
 *
 * See: https://docs.pydantic.dev/latest/usage/types/#strict-types
 */
type MetadataFilter = {
    key: string;
    value: number | string | Array<string> | Array<number>;
    operator?: FilterOperator;
};
/**
 * Metadata filters for vector stores.
 */
type MetadataFilters = {
    filters: Array<MetadataFilter | MetadataFilters>;
    condition?: FilterCondition;
};
type MetricResult = {
    /**
     * Whether the metric passed or not.
     */
    passing?: boolean;
    /**
     * The score for the metric.
     */
    score?: number;
    /**
     * The reasoning for the metric.
     */
    feedback?: string;
};
/**
 * Base interface for node parser.
 */
type NodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * An enumeration.
 */
type ObjectType = "1" | "2" | "3" | "4";
/**
 * An enumeration.
 */
declare const ObjectType: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
    readonly _4: "4";
};
/**
 * OpenAI class for embeddings.
 *
 * Args:
 * mode (str): Mode for embedding.
 * Defaults to OpenAIEmbeddingMode.TEXT_SEARCH_MODE.
 * Options are:
 *
 * - OpenAIEmbeddingMode.SIMILARITY_MODE
 * - OpenAIEmbeddingMode.TEXT_SEARCH_MODE
 *
 * model (str): Model for embedding.
 * Defaults to OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002.
 * Options are:
 *
 * - OpenAIEmbeddingModelType.DAVINCI
 * - OpenAIEmbeddingModelType.CURIE
 * - OpenAIEmbeddingModelType.BABBAGE
 * - OpenAIEmbeddingModelType.ADA
 * - OpenAIEmbeddingModelType.TEXT_EMBED_ADA_002
 */
type OpenAIEmbedding = {
    /**
     * The name of the embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number;
    /**
     * Additional kwargs for the OpenAI API.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    /**
     * The OpenAI API key.
     */
    api_key: string;
    /**
     * The base URL for OpenAI API.
     */
    api_base?: string;
    /**
     * The version for OpenAI API.
     */
    api_version?: string;
    /**
     * Maximum number of retries.
     */
    max_retries?: number;
    /**
     * Timeout for each request.
     */
    timeout?: number;
    /**
     * The default headers for API requests.
     */
    default_headers?: {
        [key: string]: string;
    };
    /**
     * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
     */
    reuse_client?: boolean;
    /**
     * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
     */
    dimensions?: number;
    class_name?: string;
};
/**
 * Schema for an organization.
 */
type Organization = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * A name for the organization.
     */
    name: string;
};
/**
 * Schema for creating an organization.
 */
type OrganizationCreate = {
    /**
     * A name for the organization.
     */
    name: string;
};
/**
 * Schema for updating an organization.
 */
type OrganizationUpdate = {
    /**
     * A name for the organization.
     */
    name?: string;
};
/**
 * Enum for representing the languages supported by the parser
 */
type ParserLanguages = "af" | "az" | "bs" | "cs" | "cy" | "da" | "de" | "en" | "es" | "et" | "fr" | "ga" | "hr" | "hu" | "id" | "is" | "it" | "ku" | "la" | "lt" | "lv" | "mi" | "ms" | "mt" | "nl" | "no" | "oc" | "pi" | "pl" | "pt" | "ro" | "rs_latin" | "sk" | "sl" | "sq" | "sv" | "sw" | "tl" | "tr" | "uz" | "vi" | "ar" | "fa" | "ug" | "ur" | "bn" | "as" | "mni" | "ru" | "rs_cyrillic" | "be" | "bg" | "uk" | "mn" | "abq" | "ady" | "kbd" | "ava" | "dar" | "inh" | "che" | "lbe" | "lez" | "tab" | "tjk" | "hi" | "mr" | "ne" | "bh" | "mai" | "ang" | "bho" | "mah" | "sck" | "new" | "gom" | "sa" | "bgc" | "th" | "ch_sim" | "ch_tra" | "ja" | "ko" | "ta" | "te" | "kn";
/**
 * Enum for representing the languages supported by the parser
 */
declare const ParserLanguages: {
    readonly AF: "af";
    readonly AZ: "az";
    readonly BS: "bs";
    readonly CS: "cs";
    readonly CY: "cy";
    readonly DA: "da";
    readonly DE: "de";
    readonly EN: "en";
    readonly ES: "es";
    readonly ET: "et";
    readonly FR: "fr";
    readonly GA: "ga";
    readonly HR: "hr";
    readonly HU: "hu";
    readonly ID: "id";
    readonly IS: "is";
    readonly IT: "it";
    readonly KU: "ku";
    readonly LA: "la";
    readonly LT: "lt";
    readonly LV: "lv";
    readonly MI: "mi";
    readonly MS: "ms";
    readonly MT: "mt";
    readonly NL: "nl";
    readonly NO: "no";
    readonly OC: "oc";
    readonly PI: "pi";
    readonly PL: "pl";
    readonly PT: "pt";
    readonly RO: "ro";
    readonly RS_LATIN: "rs_latin";
    readonly SK: "sk";
    readonly SL: "sl";
    readonly SQ: "sq";
    readonly SV: "sv";
    readonly SW: "sw";
    readonly TL: "tl";
    readonly TR: "tr";
    readonly UZ: "uz";
    readonly VI: "vi";
    readonly AR: "ar";
    readonly FA: "fa";
    readonly UG: "ug";
    readonly UR: "ur";
    readonly BN: "bn";
    readonly AS: "as";
    readonly MNI: "mni";
    readonly RU: "ru";
    readonly RS_CYRILLIC: "rs_cyrillic";
    readonly BE: "be";
    readonly BG: "bg";
    readonly UK: "uk";
    readonly MN: "mn";
    readonly ABQ: "abq";
    readonly ADY: "ady";
    readonly KBD: "kbd";
    readonly AVA: "ava";
    readonly DAR: "dar";
    readonly INH: "inh";
    readonly CHE: "che";
    readonly LBE: "lbe";
    readonly LEZ: "lez";
    readonly TAB: "tab";
    readonly TJK: "tjk";
    readonly HI: "hi";
    readonly MR: "mr";
    readonly NE: "ne";
    readonly BH: "bh";
    readonly MAI: "mai";
    readonly ANG: "ang";
    readonly BHO: "bho";
    readonly MAH: "mah";
    readonly SCK: "sck";
    readonly NEW: "new";
    readonly GOM: "gom";
    readonly SA: "sa";
    readonly BGC: "bgc";
    readonly TH: "th";
    readonly CH_SIM: "ch_sim";
    readonly CH_TRA: "ch_tra";
    readonly JA: "ja";
    readonly KO: "ko";
    readonly TA: "ta";
    readonly TE: "te";
    readonly KN: "kn";
};
type ParsingHistoryItem = {
    user_id: string;
    day: string;
    job_id: string;
    file_name: string;
    original_file_name: string;
    expired?: boolean;
    pages?: number;
    images?: number;
    time?: number;
};
type ParsingJob = {
    id: string;
    status: StatusEnum;
};
type ParsingJobJsonResult = {
    /**
     * The json result of the parsing job
     */
    pages?: unknown;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata?: unknown;
};
type ParsingJobMarkdownResult = {
    /**
     * The markdown result of the parsing job
     */
    markdown: string;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata?: unknown;
};
type ParsingJobTextResult = {
    /**
     * The text result of the parsing job
     */
    text: string;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata?: unknown;
};
type ParsingUsage = {
    usage_pdf_pages: number;
    max_pdf_pages: number;
};
/**
 * Schema for a pipeline.
 */
type Pipeline = {
    configured_transformations: Array<ConfiguredTransformationItem>;
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    name: string;
    project_id: string;
    /**
     * Type of pipeline. Either PLAYGROUND or MANAGED.
     */
    pipeline_type?: PipelineType;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams;
    /**
     * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
     */
    llama_parse_parameters?: LlamaParseParameters;
    /**
     * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
     */
    data_sink?: DataSink;
};
/**
 * Schema for creating a pipeline.
 */
type PipelineCreate = {
    /**
     * Configuration for the embedding model.
     */
    embedding_config?: EmbeddingConfig;
    /**
     * Configuration for the transformation.
     */
    transform_config?: TransformConfig;
    /**
     * List of configured transformations.
     */
    configured_transformations?: Array<ConfiguredTransformationItem>;
    /**
     * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
     */
    data_sink_id?: string;
    /**
     * Data sink. When provided instead of data_sink_id, the data sink will be created.
     */
    data_sink?: DataSinkCreate;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams;
    /**
     * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
     */
    llama_parse_parameters?: LlamaParseParameters;
    name: string;
    /**
     * Type of pipeline. Either PLAYGROUND or MANAGED.
     */
    pipeline_type?: PipelineType;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string;
};
/**
 * Schema for a data source in a pipeline.
 */
type PipelineDataSource = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource;
    project_id: string;
    /**
     * The ID of the data source.
     */
    data_source_id: string;
    /**
     * The ID of the pipeline.
     */
    pipeline_id: string;
};
/**
 * Schema for creating an association between a data source and a pipeline.
 */
type PipelineDataSourceCreate = {
    /**
     * The ID of the data source.
     */
    data_source_id: string;
};
/**
 * Base schema model containing common database fields.
 */
type PipelineDeployment = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * Status of the pipeline deployment.
     */
    status: ManagedIngestionStatus;
    /**
     * Time the pipeline deployment started.
     */
    started_at?: string;
    /**
     * Time the pipeline deployment finished.
     */
    ended_at?: string;
};
/**
 * Schema for a file that is associated with a pipeline.
 */
type PipelineFile = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    name?: string;
    /**
     * Size of the file in bytes
     */
    file_size?: number;
    /**
     * File type (e.g. pdf, docx, etc.)
     */
    file_type?: string;
    /**
     * The ID of the project that the file belongs to
     */
    project_id: string;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string;
    /**
     * The ID of the file
     */
    file_id?: string;
    /**
     * The ID of the pipeline that the file is associated with
     */
    pipeline_id: string;
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Schema for creating a file that is associated with a pipeline.
 */
type PipelineFileCreate = {
    /**
     * The ID of the file
     */
    file_id: string;
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Schema for updating a file that is associated with a pipeline.
 */
type PipelineFileUpdate = {
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean;
    };
};
/**
 * Enum for representing the type of a pipeline
 */
type PipelineType = "PLAYGROUND" | "MANAGED";
/**
 * Enum for representing the type of a pipeline
 */
declare const PipelineType: {
    readonly PLAYGROUND: "PLAYGROUND";
    readonly MANAGED: "MANAGED";
};
/**
 * Schema for updating a pipeline.
 */
type PipelineUpdate = {
    /**
     * Configuration for the embedding model.
     */
    embedding_config?: EmbeddingConfig;
    /**
     * Configuration for the transformation.
     */
    transform_config?: TransformConfig;
    /**
     * List of configured transformations.
     */
    configured_transformations?: Array<ConfiguredTransformationItem>;
    /**
     * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
     */
    data_sink_id?: string;
    /**
     * Data sink. When provided instead of data_sink_id, the data sink will be created.
     */
    data_sink?: DataSinkCreate;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams;
    /**
     * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
     */
    llama_parse_parameters?: LlamaParseParameters;
    name?: string;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string;
};
/**
 * Enum of possible pooling choices with pooling behaviors.
 */
type Pooling = "cls" | "mean" | "last";
/**
 * Enum of possible pooling choices with pooling behaviors.
 */
declare const Pooling: {
    readonly CLS: "cls";
    readonly MEAN: "mean";
    readonly LAST: "last";
};
/**
 * Schema for the search params for an retrieval execution that can be preset for a pipeline.
 */
type PresetRetrievalParams = {
    /**
     * Number of nodes for dense retrieval.
     */
    dense_similarity_top_k?: number;
    /**
     * Number of nodes for sparse retrieval.
     */
    sparse_similarity_top_k?: number;
    /**
     * Enable reranking for retrieval
     */
    enable_reranking?: boolean;
    /**
     * Number of reranked nodes for returning.
     */
    rerank_top_n?: number;
    /**
     * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
     */
    alpha?: number;
    /**
     * Search filters for retrieval.
     */
    search_filters?: MetadataFilters;
    /**
     * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
     */
    files_top_k?: number;
    /**
     * The retrieval mode for the query.
     */
    retrieval_mode?: RetrievalMode;
};
/**
 * Schema for a presigned URL.
 */
type PresignedUrl = {
    /**
     * A presigned URL for IO operations against a private file
     */
    url: string;
    /**
     * The time at which the presigned URL expires
     */
    expires_at: string;
    /**
     * Form fields for a presigned POST request
     */
    form_fields?: {
        [key: string]: string;
    };
};
/**
 * Schema for a project.
 */
type Project = {
    name: string;
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    ad_hoc_eval_dataset_id?: string;
    /**
     * The Organization ID the project is under.
     */
    organization_id: string;
    /**
     * Whether this project is the default project for the user.
     */
    is_default?: boolean;
};
/**
 * Schema for creating a project.
 */
type ProjectCreate = {
    name: string;
};
/**
 * Schema for updating a project.
 */
type ProjectUpdate = {
    name: string;
};
/**
 * Schema for the prompts derived from the PromptMixin.
 */
type PromptMixinPrompts = {
    /**
     * The ID of the project.
     */
    project_id: string;
    /**
     * The ID of the prompt set.
     */
    id?: string;
    /**
     * The name of the prompt set.
     */
    name: string;
    /**
     * The prompts.
     */
    prompts: Array<PromptSpec>;
};
type PromptSpec = {
    /**
     * The key of the prompt in the PromptMixin.
     */
    prompt_key: string;
    /**
     * The class of the prompt (PromptTemplate or ChatPromptTemplate).
     */
    prompt_class: string;
    /**
     * The type of prompt.
     */
    prompt_type: string;
    /**
     * The template of the prompt.
     */
    template?: string;
    /**
     * The chat message templates of the prompt.
     */
    message_templates?: Array<ChatMessage>;
};
/**
 * Pydantic program mode.
 */
type PydanticProgramMode = "default" | "openai" | "llm" | "function" | "guidance" | "lm-format-enforcer";
/**
 * Pydantic program mode.
 */
declare const PydanticProgramMode: {
    readonly DEFAULT: "default";
    readonly OPENAI: "openai";
    readonly LLM: "llm";
    readonly FUNCTION: "function";
    readonly GUIDANCE: "guidance";
    readonly LM_FORMAT_ENFORCER: "lm-format-enforcer";
};
/**
 * Base component object to capture class names.
 */
type RelatedNodeInfo = {
    node_id: string;
    node_type?: ObjectType;
    metadata?: {
        [key: string]: unknown;
    };
    hash?: string;
    class_name?: string;
};
/**
 * An enumeration.
 */
type RetrievalMode = "chunks" | "files_via_metadata" | "files_via_content";
/**
 * An enumeration.
 */
declare const RetrievalMode: {
    readonly CHUNKS: "chunks";
    readonly FILES_VIA_METADATA: "files_via_metadata";
    readonly FILES_VIA_CONTENT: "files_via_content";
};
/**
 * Schema for the search params for an retrieval execution.
 */
type RetrievalParams = {
    /**
     * Number of nodes for dense retrieval.
     */
    dense_similarity_top_k?: number;
    /**
     * Number of nodes for sparse retrieval.
     */
    sparse_similarity_top_k?: number;
    /**
     * Enable reranking for retrieval
     */
    enable_reranking?: boolean;
    /**
     * Number of reranked nodes for returning.
     */
    rerank_top_n?: number;
    /**
     * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
     */
    alpha?: number;
    /**
     * Search filters for retrieval.
     */
    search_filters?: MetadataFilters;
    /**
     * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
     */
    files_top_k?: number;
    /**
     * The retrieval mode for the query.
     */
    retrieval_mode?: RetrievalMode;
    /**
     * The query to retrieve against.
     */
    query: string;
};
/**
 * Schema for the result of an retrieval execution.
 */
type RetrieveResults = {
    /**
     * The ID of the pipeline that the query was retrieved against.
     */
    pipeline_id: string;
    /**
     * The nodes retrieved by the pipeline for the given query.
     */
    retrieval_nodes: Array<TextNodeWithScore>;
    /**
     * The end-to-end latency for retrieval and reranking.
     */
    retrieval_latency: {
        [key: string]: number;
    };
    class_name?: string;
};
/**
 * Parse text with a preference for complete sentences.
 *
 * In general, this class tries to keep sentences and paragraphs together. Therefore
 * compared to the original TokenTextSplitter, there are less likely to be
 * hanging sentences or parts of sentences at the end of the node chunk.
 */
type SentenceSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The token chunk size for each chunk.
     */
    chunk_size?: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunk_overlap?: number;
    /**
     * Default separator for splitting into words
     */
    separator?: string;
    /**
     * Separator between paragraphs.
     */
    paragraph_separator?: string;
    /**
     * Backup regex for splitting into sentences.
     */
    secondary_chunking_regex?: string;
    class_name?: string;
};
/**
 * Simple file node parser.
 *
 * Splits a document loaded from a file into Nodes using logic based on the file type
 * automatically detects the NodeParser to use based on file type
 *
 * Args:
 * include_metadata (bool): whether to include metadata in nodes
 * include_prev_next_rel (bool): whether to include prev/next relationships
 */
type SimpleFileNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Enum for representing the status of a job
 */
type StatusEnum = "PENDING" | "SUCCESS" | "ERROR" | "PARTIAL_SUCCESS";
/**
 * Enum for representing the status of a job
 */
declare const StatusEnum: {
    readonly PENDING: "PENDING";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
    readonly PARTIAL_SUCCESS: "PARTIAL_SUCCESS";
};
/**
 * Response Schema for a supported eval LLM model.
 */
type SupportedEvalLLMModel = {
    /**
     * The name of the supported eval LLM model.
     */
    name: SupportedEvalLLMModelNames;
    /**
     * The details of the supported eval LLM model.
     */
    details: EvalLLMModelData;
};
/**
 * An enumeration.
 */
type SupportedEvalLLMModelNames = "GPT_3_5_TURBO" | "GPT_4" | "GPT_4_TURBO";
/**
 * An enumeration.
 */
declare const SupportedEvalLLMModelNames: {
    readonly GPT_3_5_TURBO: "GPT_3_5_TURBO";
    readonly GPT_4: "GPT_4";
    readonly GPT_4_TURBO: "GPT_4_TURBO";
};
/**
 * Base node Object.
 *
 * Generic abstract interface for retrievable nodes
 */
type TextNode = {
    /**
     * Unique ID of the node.
     */
    id_?: string;
    /**
     * Embedding of the node.
     */
    embedding?: Array<number>;
    /**
     * A flat dictionary of metadata fields
     */
    extra_info?: {
        [key: string]: unknown;
    };
    /**
     * Metadata keys that are excluded from text for the embed model.
     */
    excluded_embed_metadata_keys?: Array<string>;
    /**
     * Metadata keys that are excluded from text for the LLM.
     */
    excluded_llm_metadata_keys?: Array<string>;
    /**
     * A mapping of relationships to other node information.
     */
    relationships?: {
        [key: string]: RelatedNodeInfo | Array<RelatedNodeInfo>;
    };
    /**
     * Text content of the node.
     */
    text?: string;
    /**
     * MIME type of the node content.
     */
    mimetype?: string;
    /**
     * Start char index of the node.
     */
    start_char_idx?: number;
    /**
     * End char index of the node.
     */
    end_char_idx?: number;
    /**
     * Template for how text is formatted, with {content} and {metadata_str} placeholders.
     */
    text_template?: string;
    /**
     * Template for how metadata is formatted, with {key} and {value} placeholders.
     */
    metadata_template?: string;
    /**
     * Separator between metadata fields when converting to string.
     */
    metadata_seperator?: string;
    class_name?: string;
};
/**
 * Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
 * FastAPI doesn't accept abstract classes like BaseNode.
 */
type TextNodeWithScore = {
    node: TextNode;
    score?: number;
    class_name?: string;
};
/**
 * Implementation of splitting text that looks at word tokens.
 */
type TokenTextSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: {
        [key: string]: unknown;
    };
    /**
     * The token chunk size for each chunk.
     */
    chunk_size?: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunk_overlap?: number;
    /**
     * Default separator for splitting into words
     */
    separator?: string;
    /**
     * Additional separators for splitting.
     */
    backup_separators?: Array<unknown>;
    class_name?: string;
};
type TransformConfig = {
    /**
     * Mode for the transformation configuration.
     */
    mode?: TransformConfigMode;
    /**
     * Configuration for the transformation.
     */
    config?: AutoTransformConfig;
};
/**
 * An enumeration.
 */
type TransformConfigMode = "AUTO" | "ADVANCED";
/**
 * An enumeration.
 */
declare const TransformConfigMode: {
    readonly AUTO: "AUTO";
    readonly ADVANCED: "ADVANCED";
};
/**
 * An enumeration.
 */
type TransformationCategoryNames = "NODE_PARSER" | "EMBEDDING";
/**
 * An enumeration.
 */
declare const TransformationCategoryNames: {
    readonly NODE_PARSER: "NODE_PARSER";
    readonly EMBEDDING: "EMBEDDING";
};
/**
 * Schema for a user's membership to an organization.
 */
type UserOrganization = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * The user's email address.
     */
    email: string;
    /**
     * The user's ID.
     */
    user_id?: string;
    /**
     * The organization's ID.
     */
    organization_id: string;
    /**
     * Whether the user's membership is pending account signup.
     */
    pending?: boolean;
    /**
     * The user ID of the user who added the user to the organization.
     */
    invited_by_user_id?: string;
    /**
     * The email address of the user who added the user to the organization.
     */
    invited_by_user_email?: string;
};
/**
 * Schema for creating a user's membership to an organization.
 */
type UserOrganizationCreate = {
    /**
     * The user's ID.
     */
    user_id?: string;
    /**
     * The user's email address.
     */
    email?: string;
};
/**
 * Schema for deleting a user's membership to an organization.
 */
type UserOrganizationDelete = {
    /**
     * The user's ID.
     */
    user_id?: string;
    /**
     * The user's email address.
     */
    email?: string;
};
type ValidationError = {
    loc: Array<string | number>;
    msg: string;
    type: string;
};
type ListKeysApiV1ApiKeysGetData = {
    session?: string;
};
type ListKeysApiV1ApiKeysGetResponse = Array<APIKey>;
type GenerateKeyApiV1ApiKeysPostData = {
    requestBody: APIKeyCreate;
    session?: string;
};
type GenerateKeyApiV1ApiKeysPostResponse = APIKey;
type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData = {
    apiKeyId: string;
    requestBody: APIKeyUpdate;
    session?: string;
};
type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutResponse = APIKey;
type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData = {
    apiKeyId: string;
    session?: string;
};
type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse = void;
type ListDataSinksApiV1DataSinksGetData = {
    projectId?: string;
    session?: string;
};
type ListDataSinksApiV1DataSinksGetResponse = Array<DataSink>;
type UpsertDataSinkApiV1DataSinksPutData = {
    organizationId?: string;
    projectId?: string;
    requestBody: DataSinkCreate;
    session?: string;
};
type UpsertDataSinkApiV1DataSinksPutResponse = DataSink;
type CreateDataSinkApiV1DataSinksPostData = {
    organizationId?: string;
    projectId?: string;
    requestBody: DataSinkCreate;
    session?: string;
};
type CreateDataSinkApiV1DataSinksPostResponse = DataSink;
type GetDataSinkApiV1DataSinksDataSinkIdGetData = {
    dataSinkId: string;
    session?: string;
};
type GetDataSinkApiV1DataSinksDataSinkIdGetResponse = DataSink;
type UpdateDataSinkApiV1DataSinksDataSinkIdPutData = {
    dataSinkId: string;
    requestBody: DataSinkUpdate;
    session?: string;
};
type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse = DataSink;
type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData = {
    dataSinkId: string;
    session?: string;
};
type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse = void;
type ListDataSourcesApiV1DataSourcesGetData = {
    organizationId?: string;
    projectId?: string;
    session?: string;
};
type ListDataSourcesApiV1DataSourcesGetResponse = Array<DataSource>;
type UpsertDataSourceApiV1DataSourcesPutData = {
    organizationId?: string;
    projectId?: string;
    requestBody: DataSourceCreate;
    session?: string;
};
type UpsertDataSourceApiV1DataSourcesPutResponse = DataSource;
type CreateDataSourceApiV1DataSourcesPostData = {
    organizationId?: string;
    projectId?: string;
    requestBody: DataSourceCreate;
    session?: string;
};
type CreateDataSourceApiV1DataSourcesPostResponse = DataSource;
type GetDataSourceApiV1DataSourcesDataSourceIdGetData = {
    dataSourceId: string;
    session?: string;
};
type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse = DataSource;
type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData = {
    dataSourceId: string;
    requestBody: DataSourceUpdate;
    session?: string;
};
type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse = DataSource;
type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData = {
    dataSourceId: string;
    session?: string;
};
type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse = void;
type ListOrganizationsApiV1OrganizationsGetData = {
    session?: string;
};
type ListOrganizationsApiV1OrganizationsGetResponse = Array<Organization>;
type UpsertOrganizationApiV1OrganizationsPutData = {
    requestBody: OrganizationCreate;
    session?: string;
};
type UpsertOrganizationApiV1OrganizationsPutResponse = Organization;
type CreateOrganizationApiV1OrganizationsPostData = {
    requestBody: OrganizationCreate;
    session?: string;
};
type CreateOrganizationApiV1OrganizationsPostResponse = Organization;
type GetDefaultOrganizationApiV1OrganizationsDefaultGetData = {
    session?: string;
};
type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse = Organization;
type SetDefaultOrganizationApiV1OrganizationsDefaultPutData = {
    requestBody: DefaultOrganizationUpdate;
    session?: string;
};
type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse = Organization;
type GetOrganizationApiV1OrganizationsOrganizationIdGetData = {
    organizationId: string;
    session?: string;
};
type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse = Organization;
type UpdateOrganizationApiV1OrganizationsOrganizationIdPutData = {
    organizationId: string;
    requestBody: OrganizationUpdate;
    session?: string;
};
type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse = Organization;
type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData = {
    organizationId: string;
    session?: string;
};
type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse = void;
type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData = {
    organizationId: string;
    session?: string;
};
type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse = Array<UserOrganization>;
type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData = {
    organizationId: string;
    requestBody: Array<UserOrganizationCreate>;
    session?: string;
};
type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse = Array<UserOrganization>;
type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData = {
    memberUserId: string;
    organizationId: string;
    session?: string;
};
type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse = void;
type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData = {
    organizationId: string;
    requestBody: Array<UserOrganizationDelete>;
    session?: string;
};
type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse = void;
type ListProjectsApiV1ProjectsGetData = {
    organizationId?: string;
    projectName?: string;
    session?: string;
};
type ListProjectsApiV1ProjectsGetResponse = Array<Project>;
type UpsertProjectApiV1ProjectsPutData = {
    organizationId?: string;
    requestBody: ProjectCreate;
    session?: string;
};
type UpsertProjectApiV1ProjectsPutResponse = Project;
type CreateProjectApiV1ProjectsPostData = {
    organizationId?: string;
    requestBody: ProjectCreate;
    session?: string;
};
type CreateProjectApiV1ProjectsPostResponse = Project;
type GetProjectApiV1ProjectsProjectIdGetData = {
    projectId: string;
    session?: string;
};
type GetProjectApiV1ProjectsProjectIdGetResponse = Project;
type UpdateExistingProjectApiV1ProjectsProjectIdPutData = {
    projectId: string;
    requestBody: ProjectUpdate;
    session?: string;
};
type UpdateExistingProjectApiV1ProjectsProjectIdPutResponse = Project;
type DeleteProjectApiV1ProjectsProjectIdDeleteData = {
    projectId: string;
    session?: string;
};
type DeleteProjectApiV1ProjectsProjectIdDeleteResponse = void;
type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData = {
    projectId: string;
    session?: string;
};
type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse = Array<EvalDataset>;
type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData = {
    projectId: string;
    requestBody: EvalDatasetCreate;
    session?: string;
};
type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostResponse = EvalDataset;
type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData = {
    projectId: string;
    requestBody: LocalEvalSetCreate;
    session?: string;
};
type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse = Array<LocalEvalResults>;
type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData = {
    projectId: string;
    session?: string;
};
type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse = Array<LocalEvalResults>;
type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData = {
    projectId: string;
    session?: string;
};
type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse = Array<LocalEvalSets>;
type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData = {
    localEvalSetId: string;
    projectId: string;
    session?: string;
};
type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteResponse = unknown;
type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData = {
    projectId: string;
    session?: string;
};
type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse = Array<PromptMixinPrompts>;
type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData = {
    projectId: string;
    requestBody: PromptMixinPrompts;
    session?: string;
};
type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostResponse = PromptMixinPrompts;
type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData = {
    projectId: string;
    promptSetId: string;
    requestBody: PromptMixinPrompts;
    session?: string;
};
type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutResponse = PromptMixinPrompts;
type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData = {
    projectId: string;
    promptSetId: string;
    session?: string;
};
type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteResponse = unknown;
type GetFileApiV1FilesIdGetData = {
    id: string;
    projectId?: string;
    session?: string;
};
type GetFileApiV1FilesIdGetResponse = File;
type DeleteFileApiV1FilesIdDeleteData = {
    id: string;
    projectId?: string;
    session?: string;
};
type DeleteFileApiV1FilesIdDeleteResponse = void;
type ListFilesApiV1FilesGetData = {
    projectId?: string;
    session?: string;
};
type ListFilesApiV1FilesGetResponse = Array<File>;
type GeneratePresignedUrlApiV1FilesPutData = {
    projectId?: string;
    requestBody: FileCreate;
    session?: string;
};
type GeneratePresignedUrlApiV1FilesPutResponse = PresignedUrl;
type UploadFileApiV1FilesPostData = {
    formData: Body_upload_file_api_v1_files_post;
    projectId?: string;
    session?: string;
};
type UploadFileApiV1FilesPostResponse = File;
type SyncFilesApiV1FilesSyncPutData = {
    projectId?: string;
    session?: string;
};
type SyncFilesApiV1FilesSyncPutResponse = Array<File>;
type ReadFileContentApiV1FilesIdContentGetData = {
    id: string;
    projectId?: string;
    session?: string;
};
type ReadFileContentApiV1FilesIdContentGetResponse = PresignedUrl;
type SearchPipelinesApiV1PipelinesGetData = {
    pipelineName?: string;
    pipelineType?: PipelineType;
    projectId?: string;
    projectName?: string;
    session?: string;
};
type SearchPipelinesApiV1PipelinesGetResponse = Array<Pipeline>;
type UpsertPipelineApiV1PipelinesPutData = {
    projectId?: string;
    requestBody: PipelineCreate;
    session?: string;
};
type UpsertPipelineApiV1PipelinesPutResponse = Pipeline;
type CreatePipelineApiV1PipelinesPostData = {
    projectId?: string;
    requestBody: PipelineCreate;
    session?: string;
};
type CreatePipelineApiV1PipelinesPostResponse = Pipeline;
type GetPipelineApiV1PipelinesPipelineIdGetData = {
    pipelineId: string;
    session?: string;
};
type GetPipelineApiV1PipelinesPipelineIdGetResponse = Pipeline;
type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData = {
    pipelineId: string;
    requestBody: PipelineUpdate;
    session?: string;
};
type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse = Pipeline;
type DeletePipelineApiV1PipelinesPipelineIdDeleteData = {
    pipelineId: string;
    session?: string;
};
type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse = void;
type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData = {
    pipelineId: string;
    session?: string;
};
type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse = ManagedIngestionStatusResponse;
type SyncPipelineApiV1PipelinesPipelineIdSyncPostData = {
    pipelineId: string;
    session?: string;
};
type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse = Pipeline;
type CopyPipelineApiV1PipelinesPipelineIdCopyPostData = {
    pipelineId: string;
    session?: string;
};
type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse = Pipeline;
type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData = {
    evalDatasetId: string;
    pipelineId: string;
    session?: string;
};
type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse = Array<EvalDatasetJobRecord>;
type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData = {
    evalDatasetId: string;
    pipelineId: string;
    requestBody: EvalExecutionCreate;
    session?: string;
};
type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostResponse = EvalDatasetJobRecord;
type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData = {
    evalDatasetId: string;
    pipelineId: string;
    session?: string;
};
type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse = Array<EvalQuestionResult>;
type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData = {
    evalDatasetExecutionId: string;
    evalDatasetId: string;
    pipelineId: string;
    session?: string;
};
type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetResponse = EvalDatasetJobRecord;
type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData = {
    dataSourceId?: string;
    onlyManuallyUploaded?: boolean;
    pipelineId: string;
    session?: string;
};
type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse = Array<PipelineFile>;
type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData = {
    pipelineId: string;
    requestBody: Array<PipelineFileCreate>;
    session?: string;
};
type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse = Array<PipelineFile>;
type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData = {
    fileId: string;
    pipelineId: string;
    session?: string;
};
type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse = ManagedIngestionStatusResponse;
type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData = {
    fileId: string;
    pipelineId: string;
    requestBody: PipelineFileUpdate;
    session?: string;
};
type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse = PipelineFile;
type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData = {
    fileId: string;
    pipelineId: string;
    session?: string;
};
type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse = void;
type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData = {
    formData: Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put;
    pipelineId: string;
    session?: string;
};
type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse = {
    [key: string]: string;
};
type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData = {
    pipelineId: string;
    session?: string;
};
type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse = void;
type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData = {
    pipelineId: string;
    session?: string;
};
type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse = Array<PipelineDataSource>;
type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData = {
    pipelineId: string;
    requestBody: Array<PipelineDataSourceCreate>;
    session?: string;
};
type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse = Array<PipelineDataSource>;
type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData = {
    dataSourceId: string;
    pipelineId: string;
    session?: string;
};
type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse = void;
type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData = {
    dataSourceId: string;
    pipelineId: string;
    session?: string;
};
type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse = Pipeline;
type RunSearchApiV1PipelinesPipelineIdRetrievePostData = {
    pipelineId: string;
    requestBody: RetrievalParams;
    session?: string;
};
type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse = RetrieveResults;
type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData = {
    pipelineId: string;
    session?: string;
};
type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse = Array<PipelineDeployment>;
type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData = {
    jobId: string;
    pipelineId: string;
    session?: string;
};
type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse = PipelineDeployment;
type ChatApiV1PipelinesPipelineIdChatPostData = {
    pipelineId: string;
    requestBody: ChatParams;
    session?: string;
};
type ChatApiV1PipelinesPipelineIdChatPostResponse = unknown;
type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData = {
    fileId?: string;
    limit?: number;
    onlyDirectUpload?: boolean;
    pipelineId: string;
    session?: string;
    skip?: number;
};
type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse = Array<CloudDocument>;
type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData = {
    pipelineId: string;
    requestBody: Array<CloudDocumentCreate>;
    session?: string;
};
type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse = Array<CloudDocument>;
type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData = {
    pipelineId: string;
    requestBody: Array<CloudDocumentCreate>;
    session?: string;
};
type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse = Array<CloudDocument>;
type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData = {
    documentId: string;
    pipelineId: string;
    session?: string;
};
type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse = CloudDocument;
type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData = {
    documentId: string;
    pipelineId: string;
    session?: string;
};
type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse = void;
type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData = {
    documentId: string;
    pipelineId: string;
    session?: string;
};
type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse = ManagedIngestionStatusResponse;
type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData = {
    documentId: string;
    pipelineId: string;
    session?: string;
};
type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse = Array<TextNode>;
type GetDatasetApiV1EvalsDatasetsDatasetIdGetData = {
    datasetId: string;
    session?: string;
};
type GetDatasetApiV1EvalsDatasetsDatasetIdGetResponse = EvalDataset;
type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData = {
    datasetId: string;
    requestBody: EvalDatasetUpdate;
    session?: string;
};
type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutResponse = EvalDataset;
type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData = {
    datasetId: string;
    session?: string;
};
type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteResponse = void;
type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData = {
    datasetId: string;
    session?: string;
};
type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse = Array<EvalQuestion>;
type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData = {
    datasetId: string;
    requestBody: EvalQuestionCreate;
    session?: string;
};
type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostResponse = EvalQuestion;
type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData = {
    datasetId: string;
    requestBody: Array<EvalQuestionCreate>;
    session?: string;
};
type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse = Array<EvalQuestion>;
type GetQuestionApiV1EvalsQuestionsQuestionIdGetData = {
    questionId: string;
    session?: string;
};
type GetQuestionApiV1EvalsQuestionsQuestionIdGetResponse = EvalQuestion;
type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData = {
    questionId: string;
    requestBody: EvalQuestionCreate;
    session?: string;
};
type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutResponse = EvalQuestion;
type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData = {
    questionId: string;
    session?: string;
};
type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteResponse = void;
type ListSupportedModelsApiV1EvalsModelsGetData = {
    session?: string;
};
type ListSupportedModelsApiV1EvalsModelsGetResponse = Array<SupportedEvalLLMModel>;
type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData = {
    jobId: string;
    name: string;
    session?: string;
};
type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponse = unknown;
type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse = Array<LlamaParseSupportedFileExtensions>;
type UploadFileApiV1ParsingUploadPostData = {
    formData: Body_upload_file_api_v1_parsing_upload_post;
    session?: string;
};
type UploadFileApiV1ParsingUploadPostResponse = ParsingJob;
type UsageApiV1ParsingUsageGetData = {
    session?: string;
};
type UsageApiV1ParsingUsageGetResponse = ParsingUsage;
type GetJobApiV1ParsingJobJobIdGetData = {
    jobId: string;
    session?: string;
};
type GetJobApiV1ParsingJobJobIdGetResponse = ParsingJob;
type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData = {
    jobId: string;
    session?: string;
};
type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponse = unknown;
type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData = {
    jobId: string;
    session?: string;
};
type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse = ParsingJobTextResult;
type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData = {
    jobId: string;
    session?: string;
};
type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetResponse = unknown;
type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData = {
    jobId: string;
    session?: string;
};
type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse = ParsingJobMarkdownResult;
type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData = {
    jobId: string;
    session?: string;
};
type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponse = unknown;
type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData = {
    jobId: string;
    session?: string;
};
type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse = ParsingJobJsonResult;
type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData = {
    jobId: string;
    session?: string;
};
type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponse = unknown;
type GetParsingHistoryResultApiV1ParsingHistoryGetData = {
    session?: string;
};
type GetParsingHistoryResultApiV1ParsingHistoryGetResponse = Array<ParsingHistoryItem>;
type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData = {
    filename: string;
    jobId: string;
    session?: string;
};
type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse = PresignedUrl;
type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse = Array<ConfigurableTransformationDefinition>;
type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse = Array<DataSourceDefinition>;
type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse = Array<DataSinkDefinition>;
type CreateCheckoutSessionApiV1BillingCheckoutSessionPostData = {
    requestBody: CheckoutSessionCreatePayload;
    session?: string;
};
type CreateCheckoutSessionApiV1BillingCheckoutSessionPostResponse = string;
type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData = {
    requestBody: CustomerPortalSessionCreatePayload;
    session?: string;
};
type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse = string;
type StripeWebhookApiV1BillingWebhookPostData = {
    stripeSignature?: string;
};
type StripeWebhookApiV1BillingWebhookPostResponse = unknown;
type ListSchemasApiV1ExtractionSchemasGetData = {
    projectId?: string;
    session?: string;
};
type ListSchemasApiV1ExtractionSchemasGetResponse = Array<ExtractionSchema>;
type CreateSchemaApiV1ExtractionSchemasPostData = {
    requestBody: ExtractionSchemaCreate;
    session?: string;
};
type CreateSchemaApiV1ExtractionSchemasPostResponse = ExtractionSchema;
type InferSchemaApiV1ExtractionSchemasInferPostData = {
    requestBody: ExtractionSchemaInfer;
    session?: string;
};
type InferSchemaApiV1ExtractionSchemasInferPostResponse = ExtractionSchema;
type GetSchemaApiV1ExtractionSchemasSchemaIdGetData = {
    schemaId: string;
    session?: string;
};
type GetSchemaApiV1ExtractionSchemasSchemaIdGetResponse = ExtractionSchema;
type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData = {
    requestBody: ExtractionSchemaUpdate;
    schemaId: string;
    session?: string;
};
type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutResponse = ExtractionSchema;
type ListJobsApiV1ExtractionJobsGetData = {
    schemaId: string;
    session?: string;
};
type ListJobsApiV1ExtractionJobsGetResponse = Array<ExtractionJob>;
type RunJobApiV1ExtractionJobsPostData = {
    requestBody: ExtractionJobCreate;
    session?: string;
};
type RunJobApiV1ExtractionJobsPostResponse = ExtractionJob;
type GetJobApiV1ExtractionJobsJobIdGetData = {
    jobId: string;
    session?: string;
};
type GetJobApiV1ExtractionJobsJobIdGetResponse = ExtractionJob;
type RunJobsInBatchApiV1ExtractionJobsBatchPostData = {
    requestBody: ExtractionJobCreateBatch;
    session?: string;
};
type RunJobsInBatchApiV1ExtractionJobsBatchPostResponse = Array<ExtractionJob>;
type GetJobResultApiV1ExtractionJobsJobIdResultGetData = {
    jobId: string;
    session?: string;
};
type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse = ExtractionResult;
type GetJobImageResultApiParsingJobJobIdResultImageNameGetData = {
    jobId: string;
    name: string;
    session?: string;
};
type GetJobImageResultApiParsingJobJobIdResultImageNameGetResponse = unknown;
type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse = Array<LlamaParseSupportedFileExtensions>;
type UploadFileApiParsingUploadPostData = {
    formData: Body_upload_file_api_parsing_upload_post;
    session?: string;
};
type UploadFileApiParsingUploadPostResponse = ParsingJob;
type UsageApiParsingUsageGetData = {
    session?: string;
};
type UsageApiParsingUsageGetResponse = ParsingUsage;
type GetJobApiParsingJobJobIdGetData = {
    jobId: string;
    session?: string;
};
type GetJobApiParsingJobJobIdGetResponse = ParsingJob;
type GetParsingJobDetailsApiParsingJobJobIdDetailsGetData = {
    jobId: string;
    session?: string;
};
type GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponse = unknown;
type GetJobTextResultApiParsingJobJobIdResultTextGetData = {
    jobId: string;
    session?: string;
};
type GetJobTextResultApiParsingJobJobIdResultTextGetResponse = ParsingJobTextResult;
type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData = {
    jobId: string;
    session?: string;
};
type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetResponse = unknown;
type GetJobResultApiParsingJobJobIdResultMarkdownGetData = {
    jobId: string;
    session?: string;
};
type GetJobResultApiParsingJobJobIdResultMarkdownGetResponse = ParsingJobMarkdownResult;
type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData = {
    jobId: string;
    session?: string;
};
type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponse = unknown;
type GetJobJsonResultApiParsingJobJobIdResultJsonGetData = {
    jobId: string;
    session?: string;
};
type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse = ParsingJobJsonResult;
type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData = {
    jobId: string;
    session?: string;
};
type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponse = unknown;
type GetParsingHistoryResultApiParsingHistoryGetData = {
    session?: string;
};
type GetParsingHistoryResultApiParsingHistoryGetResponse = Array<ParsingHistoryItem>;
type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData = {
    filename: string;
    jobId: string;
    session?: string;
};
type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse = PresignedUrl;
type $OpenApiTs = {
    "/api/v1/api-keys": {
        get: {
            req: ListKeysApiV1ApiKeysGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<APIKey>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: GenerateKeyApiV1ApiKeysPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: APIKey;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/api-keys/{api_key_id}": {
        put: {
            req: UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: APIKey;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/data-sinks": {
        get: {
            req: ListDataSinksApiV1DataSinksGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DataSink>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertDataSinkApiV1DataSinksPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSink;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateDataSinkApiV1DataSinksPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSink;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/data-sinks/{data_sink_id}": {
        get: {
            req: GetDataSinkApiV1DataSinksDataSinkIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSink;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateDataSinkApiV1DataSinksDataSinkIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSink;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/data-sources": {
        get: {
            req: ListDataSourcesApiV1DataSourcesGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DataSource>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertDataSourceApiV1DataSourcesPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSource;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateDataSourceApiV1DataSourcesPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSource;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/data-sources/{data_source_id}": {
        get: {
            req: GetDataSourceApiV1DataSourcesDataSourceIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSource;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateDataSourceApiV1DataSourcesDataSourceIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: DataSource;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations": {
        get: {
            req: ListOrganizationsApiV1OrganizationsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Organization>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertOrganizationApiV1OrganizationsPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateOrganizationApiV1OrganizationsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations/default": {
        get: {
            req: GetDefaultOrganizationApiV1OrganizationsDefaultGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: SetDefaultOrganizationApiV1OrganizationsDefaultPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations/{organization_id}": {
        get: {
            req: GetOrganizationApiV1OrganizationsOrganizationIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateOrganizationApiV1OrganizationsOrganizationIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Organization;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations/{organization_id}/users": {
        get: {
            req: ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<UserOrganization>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<UserOrganization>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations/{organization_id}/users/{member_user_id}": {
        delete: {
            req: RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/organizations/{organization_id}/users/remove": {
        put: {
            req: BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects": {
        get: {
            req: ListProjectsApiV1ProjectsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Project>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertProjectApiV1ProjectsPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Project;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateProjectApiV1ProjectsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Project;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}": {
        get: {
            req: GetProjectApiV1ProjectsProjectIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Project;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateExistingProjectApiV1ProjectsProjectIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Project;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteProjectApiV1ProjectsProjectIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/eval/dataset": {
        get: {
            req: ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EvalDataset>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalDataset;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/localevalset": {
        post: {
            req: CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<LocalEvalResults>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/localeval": {
        get: {
            req: ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<LocalEvalResults>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/localevalsets": {
        get: {
            req: ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<LocalEvalSets>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/localevalset/{local_eval_set_id}": {
        delete: {
            req: DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/prompts": {
        get: {
            req: ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PromptMixinPrompts>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: PromptMixinPrompts;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/projects/{project_id}/prompts/{prompt_set_id}": {
        put: {
            req: UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: PromptMixinPrompts;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/files/{id}": {
        get: {
            req: GetFileApiV1FilesIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: File;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteFileApiV1FilesIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/files": {
        get: {
            req: ListFilesApiV1FilesGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<File>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: GeneratePresignedUrlApiV1FilesPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: PresignedUrl;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: UploadFileApiV1FilesPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: File;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/files/sync": {
        put: {
            req: SyncFilesApiV1FilesSyncPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<File>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/files/{id}/content": {
        get: {
            req: ReadFileContentApiV1FilesIdContentGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: PresignedUrl;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines": {
        get: {
            req: SearchPipelinesApiV1PipelinesGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Pipeline>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertPipelineApiV1PipelinesPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreatePipelineApiV1PipelinesPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}": {
        get: {
            req: GetPipelineApiV1PipelinesPipelineIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateExistingPipelineApiV1PipelinesPipelineIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeletePipelineApiV1PipelinesPipelineIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/status": {
        get: {
            req: GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ManagedIngestionStatusResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/sync": {
        post: {
            req: SyncPipelineApiV1PipelinesPipelineIdSyncPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/copy": {
        post: {
            req: CopyPipelineApiV1PipelinesPipelineIdCopyPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute": {
        get: {
            req: GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EvalDatasetJobRecord>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalDatasetJobRecord;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/result": {
        get: {
            req: GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EvalQuestionResult>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/{eval_dataset_execution_id}": {
        get: {
            req: GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalDatasetJobRecord;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/files": {
        get: {
            req: ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PipelineFile>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PipelineFile>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status": {
        get: {
            req: GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ManagedIngestionStatusResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/files/{file_id}": {
        put: {
            req: UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: PipelineFile;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/metadata": {
        put: {
            req: ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: string;
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/data-sources": {
        get: {
            req: ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PipelineDataSource>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PipelineDataSource>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}": {
        delete: {
            req: DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync": {
        post: {
            req: SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Pipeline;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/retrieve": {
        post: {
            req: RunSearchApiV1PipelinesPipelineIdRetrievePostData;
            res: {
                /**
                 * Successful Response
                 */
                200: RetrieveResults;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/jobs": {
        get: {
            req: ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<PipelineDeployment>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/jobs/{job_id}": {
        get: {
            req: GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: PipelineDeployment;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/chat": {
        post: {
            req: ChatApiV1PipelinesPipelineIdChatPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/documents": {
        get: {
            req: ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<CloudDocument>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<CloudDocument>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<CloudDocument>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/documents/{document_id}": {
        get: {
            req: GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: CloudDocument;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status": {
        get: {
            req: GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ManagedIngestionStatusResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks": {
        get: {
            req: ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TextNode>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/evals/datasets/{dataset_id}": {
        get: {
            req: GetDatasetApiV1EvalsDatasetsDatasetIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalDataset;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalDataset;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/evals/datasets/{dataset_id}/question": {
        get: {
            req: ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EvalQuestion>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalQuestion;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/evals/datasets/{dataset_id}/questions": {
        post: {
            req: CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EvalQuestion>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/evals/questions/{question_id}": {
        get: {
            req: GetQuestionApiV1EvalsQuestionsQuestionIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalQuestion;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: EvalQuestion;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/evals/models": {
        get: {
            req: ListSupportedModelsApiV1EvalsModelsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<SupportedEvalLLMModel>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/image/{name}": {
        get: {
            req: GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/supported_file_extensions": {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<LlamaParseSupportedFileExtensions>;
            };
        };
    };
    "/api/v1/parsing/upload": {
        post: {
            req: UploadFileApiV1ParsingUploadPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/usage": {
        get: {
            req: UsageApiV1ParsingUsageGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingUsage;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}": {
        get: {
            req: GetJobApiV1ParsingJobJobIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/details": {
        get: {
            req: GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/text": {
        get: {
            req: GetJobTextResultApiV1ParsingJobJobIdResultTextGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobTextResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/raw/text": {
        get: {
            req: GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/markdown": {
        get: {
            req: GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobMarkdownResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/raw/markdown": {
        get: {
            req: GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/json": {
        get: {
            req: GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobJsonResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/result/raw/json": {
        get: {
            req: GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/history": {
        get: {
            req: GetParsingHistoryResultApiV1ParsingHistoryGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ParsingHistoryItem>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/parsing/job/{job_id}/read/{filename}": {
        get: {
            req: GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: PresignedUrl;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/component-definition/configurable-transformations": {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ConfigurableTransformationDefinition>;
            };
        };
    };
    "/api/v1/component-definition/data-sources": {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DataSourceDefinition>;
            };
        };
    };
    "/api/v1/component-definition/data-sinks": {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DataSinkDefinition>;
            };
        };
    };
    "/api/v1/billing/checkout-session": {
        post: {
            req: CreateCheckoutSessionApiV1BillingCheckoutSessionPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: string;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/billing/customer-portal-session": {
        post: {
            req: CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: string;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/billing/webhook": {
        post: {
            req: StripeWebhookApiV1BillingWebhookPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/schemas": {
        get: {
            req: ListSchemasApiV1ExtractionSchemasGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ExtractionSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateSchemaApiV1ExtractionSchemasPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/schemas/infer": {
        post: {
            req: InferSchemaApiV1ExtractionSchemasInferPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/schemas/{schema_id}": {
        get: {
            req: GetSchemaApiV1ExtractionSchemasSchemaIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/jobs": {
        get: {
            req: ListJobsApiV1ExtractionJobsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ExtractionJob>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: RunJobApiV1ExtractionJobsPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/jobs/{job_id}": {
        get: {
            req: GetJobApiV1ExtractionJobsJobIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/jobs/batch": {
        post: {
            req: RunJobsInBatchApiV1ExtractionJobsBatchPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ExtractionJob>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/v1/extraction/jobs/{job_id}/result": {
        get: {
            req: GetJobResultApiV1ExtractionJobsJobIdResultGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ExtractionResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/image/{name}": {
        get: {
            req: GetJobImageResultApiParsingJobJobIdResultImageNameGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/supported_file_extensions": {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<LlamaParseSupportedFileExtensions>;
            };
        };
    };
    "/api/parsing/upload": {
        post: {
            req: UploadFileApiParsingUploadPostData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/usage": {
        get: {
            req: UsageApiParsingUsageGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingUsage;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}": {
        get: {
            req: GetJobApiParsingJobJobIdGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJob;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/details": {
        get: {
            req: GetParsingJobDetailsApiParsingJobJobIdDetailsGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/text": {
        get: {
            req: GetJobTextResultApiParsingJobJobIdResultTextGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobTextResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/raw/text": {
        get: {
            req: GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/markdown": {
        get: {
            req: GetJobResultApiParsingJobJobIdResultMarkdownGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobMarkdownResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/raw/markdown": {
        get: {
            req: GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/json": {
        get: {
            req: GetJobJsonResultApiParsingJobJobIdResultJsonGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: ParsingJobJsonResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/result/raw/json": {
        get: {
            req: GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/history": {
        get: {
            req: GetParsingHistoryResultApiParsingHistoryGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ParsingHistoryItem>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    "/api/parsing/job/{job_id}/read/{filename}": {
        get: {
            req: GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData;
            res: {
                /**
                 * Successful Response
                 */
                200: PresignedUrl;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
};

declare class ApiKeysService {
    /**
     * List Keys
     * List API Keys for a user.
     * @param data The data for the request.
     * @param data.session
     * @returns APIKey Successful Response
     * @throws ApiError
     */
    static listKeysApiV1ApiKeysGet(data?: ListKeysApiV1ApiKeysGetData): CancelablePromise<ListKeysApiV1ApiKeysGetResponse>;
    /**
     * Generate Key
     * Generate a new API Key.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns APIKey Successful Response
     * @throws ApiError
     */
    static generateKeyApiV1ApiKeysPost(data: GenerateKeyApiV1ApiKeysPostData): CancelablePromise<GenerateKeyApiV1ApiKeysPostResponse>;
    /**
     * Update Existing Api Key
     * Update name of an existing API Key.
     * @param data The data for the request.
     * @param data.apiKeyId
     * @param data.requestBody
     * @param data.session
     * @returns APIKey Successful Response
     * @throws ApiError
     */
    static updateExistingApiKeyApiV1ApiKeysApiKeyIdPut(data: UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData): CancelablePromise<UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutResponse>;
    /**
     * Delete Api Key
     * Delete an API Key by ID.
     * @param data The data for the request.
     * @param data.apiKeyId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteApiKeyApiV1ApiKeysApiKeyIdDelete(data: DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData): CancelablePromise<DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse>;
}
declare class DataSinksService {
    /**
     * List Data Sinks
     * List data sinks for a given project.
     * If project_id is not provided, uses the default project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns DataSink Successful Response
     * @throws ApiError
     */
    static listDataSinksApiV1DataSinksGet(data?: ListDataSinksApiV1DataSinksGetData): CancelablePromise<ListDataSinksApiV1DataSinksGetResponse>;
    /**
     * Upsert Data Sink
     * Upserts a data sink.
     * Updates if a data sink with the same name and project_id already exists. Otherwise, creates a new data sink.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.organizationId
     * @param data.session
     * @returns DataSink Successful Response
     * @throws ApiError
     */
    static upsertDataSinkApiV1DataSinksPut(data: UpsertDataSinkApiV1DataSinksPutData): CancelablePromise<UpsertDataSinkApiV1DataSinksPutResponse>;
    /**
     * Create Data Sink
     * Create a new data sink.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.organizationId
     * @param data.session
     * @returns DataSink Successful Response
     * @throws ApiError
     */
    static createDataSinkApiV1DataSinksPost(data: CreateDataSinkApiV1DataSinksPostData): CancelablePromise<CreateDataSinkApiV1DataSinksPostResponse>;
    /**
     * Get Data Sink
     * Get a data sink by ID.
     * @param data The data for the request.
     * @param data.dataSinkId
     * @param data.session
     * @returns DataSink Successful Response
     * @throws ApiError
     */
    static getDataSinkApiV1DataSinksDataSinkIdGet(data: GetDataSinkApiV1DataSinksDataSinkIdGetData): CancelablePromise<GetDataSinkApiV1DataSinksDataSinkIdGetResponse>;
    /**
     * Update Data Sink
     * Update a data sink by ID.
     * @param data The data for the request.
     * @param data.dataSinkId
     * @param data.requestBody
     * @param data.session
     * @returns DataSink Successful Response
     * @throws ApiError
     */
    static updateDataSinkApiV1DataSinksDataSinkIdPut(data: UpdateDataSinkApiV1DataSinksDataSinkIdPutData): CancelablePromise<UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse>;
    /**
     * Delete Data Sink
     * Delete a data sink by ID.
     * @param data The data for the request.
     * @param data.dataSinkId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteDataSinkApiV1DataSinksDataSinkIdDelete(data: DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData): CancelablePromise<DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse>;
}
declare class DataSourcesService {
    /**
     * List Data Sources
     * List data sources for a given project.
     * If project_id is not provided, uses the default project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.organizationId
     * @param data.session
     * @returns DataSource Successful Response
     * @throws ApiError
     */
    static listDataSourcesApiV1DataSourcesGet(data?: ListDataSourcesApiV1DataSourcesGetData): CancelablePromise<ListDataSourcesApiV1DataSourcesGetResponse>;
    /**
     * Upsert Data Source
     * Upserts a data source.
     * Updates if a data source with the same name and project_id already exists. Otherwise, creates a new data source.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.organizationId
     * @param data.session
     * @returns DataSource Successful Response
     * @throws ApiError
     */
    static upsertDataSourceApiV1DataSourcesPut(data: UpsertDataSourceApiV1DataSourcesPutData): CancelablePromise<UpsertDataSourceApiV1DataSourcesPutResponse>;
    /**
     * Create Data Source
     * Create a new data source.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.organizationId
     * @param data.session
     * @returns DataSource Successful Response
     * @throws ApiError
     */
    static createDataSourceApiV1DataSourcesPost(data: CreateDataSourceApiV1DataSourcesPostData): CancelablePromise<CreateDataSourceApiV1DataSourcesPostResponse>;
    /**
     * Get Data Source
     * Get a data source by ID.
     * @param data The data for the request.
     * @param data.dataSourceId
     * @param data.session
     * @returns DataSource Successful Response
     * @throws ApiError
     */
    static getDataSourceApiV1DataSourcesDataSourceIdGet(data: GetDataSourceApiV1DataSourcesDataSourceIdGetData): CancelablePromise<GetDataSourceApiV1DataSourcesDataSourceIdGetResponse>;
    /**
     * Update Data Source
     * Update a data source by ID.
     * @param data The data for the request.
     * @param data.dataSourceId
     * @param data.requestBody
     * @param data.session
     * @returns DataSource Successful Response
     * @throws ApiError
     */
    static updateDataSourceApiV1DataSourcesDataSourceIdPut(data: UpdateDataSourceApiV1DataSourcesDataSourceIdPutData): CancelablePromise<UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse>;
    /**
     * Delete Data Source
     * Delete a data source by ID.
     * @param data The data for the request.
     * @param data.dataSourceId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteDataSourceApiV1DataSourcesDataSourceIdDelete(data: DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData): CancelablePromise<DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse>;
}
declare class OrganizationsService {
    /**
     * List Organizations
     * List organizations for a user.
     * @param data The data for the request.
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static listOrganizationsApiV1OrganizationsGet(data?: ListOrganizationsApiV1OrganizationsGetData): CancelablePromise<ListOrganizationsApiV1OrganizationsGetResponse>;
    /**
     * Upsert Organization
     * Upsert a new organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static upsertOrganizationApiV1OrganizationsPut(data: UpsertOrganizationApiV1OrganizationsPutData): CancelablePromise<UpsertOrganizationApiV1OrganizationsPutResponse>;
    /**
     * Create Organization
     * Create a new organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static createOrganizationApiV1OrganizationsPost(data: CreateOrganizationApiV1OrganizationsPostData): CancelablePromise<CreateOrganizationApiV1OrganizationsPostResponse>;
    /**
     * Get Default Organization
     * Get the default organization for the user.
     * @param data The data for the request.
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static getDefaultOrganizationApiV1OrganizationsDefaultGet(data?: GetDefaultOrganizationApiV1OrganizationsDefaultGetData): CancelablePromise<GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse>;
    /**
     * Set Default Organization
     * Set the default organization for the user.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static setDefaultOrganizationApiV1OrganizationsDefaultPut(data: SetDefaultOrganizationApiV1OrganizationsDefaultPutData): CancelablePromise<SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse>;
    /**
     * Get Organization
     * Get an organization by ID.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static getOrganizationApiV1OrganizationsOrganizationIdGet(data: GetOrganizationApiV1OrganizationsOrganizationIdGetData): CancelablePromise<GetOrganizationApiV1OrganizationsOrganizationIdGetResponse>;
    /**
     * Update Organization
     * Update an existing organization.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.requestBody
     * @param data.session
     * @returns Organization Successful Response
     * @throws ApiError
     */
    static updateOrganizationApiV1OrganizationsOrganizationIdPut(data: UpdateOrganizationApiV1OrganizationsOrganizationIdPutData): CancelablePromise<UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse>;
    /**
     * Delete Organization
     * Delete an organization by ID.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteOrganizationApiV1OrganizationsOrganizationIdDelete(data: DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData): CancelablePromise<DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse>;
    /**
     * List Organization Users
     * Get all users in an organization.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.session
     * @returns UserOrganization Successful Response
     * @throws ApiError
     */
    static listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet(data: ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData): CancelablePromise<ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse>;
    /**
     * Add Users To Organization
     * Add a user to an organization.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.requestBody
     * @param data.session
     * @returns UserOrganization Successful Response
     * @throws ApiError
     */
    static addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut(data: AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData): CancelablePromise<AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse>;
    /**
     * Remove Users From Organization
     * Remove users from an organization by email.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.memberUserId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete(data: RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData): CancelablePromise<RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse>;
    /**
     * Batch Remove Users From Organization
     * Remove a batch of users from an organization.
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.requestBody
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut(data: BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData): CancelablePromise<BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse>;
}
declare class ProjectsService {
    /**
     * List Projects
     * List projects or get one by name
     * @param data The data for the request.
     * @param data.organizationId
     * @param data.projectName
     * @param data.session
     * @returns Project Successful Response
     * @throws ApiError
     */
    static listProjectsApiV1ProjectsGet(data?: ListProjectsApiV1ProjectsGetData): CancelablePromise<ListProjectsApiV1ProjectsGetResponse>;
    /**
     * Upsert Project
     * Upsert a project.
     * Updates if a project with the same name already exists. Otherwise, creates a new project.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.organizationId
     * @param data.session
     * @returns Project Successful Response
     * @throws ApiError
     */
    static upsertProjectApiV1ProjectsPut(data: UpsertProjectApiV1ProjectsPutData): CancelablePromise<UpsertProjectApiV1ProjectsPutResponse>;
    /**
     * Create Project
     * Create a new project.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.organizationId
     * @param data.session
     * @returns Project Successful Response
     * @throws ApiError
     */
    static createProjectApiV1ProjectsPost(data: CreateProjectApiV1ProjectsPostData): CancelablePromise<CreateProjectApiV1ProjectsPostResponse>;
    /**
     * Get Project
     * Get a project by ID.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns Project Successful Response
     * @throws ApiError
     */
    static getProjectApiV1ProjectsProjectIdGet(data: GetProjectApiV1ProjectsProjectIdGetData): CancelablePromise<GetProjectApiV1ProjectsProjectIdGetResponse>;
    /**
     * Update Existing Project
     * Update an existing project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.requestBody
     * @param data.session
     * @returns Project Successful Response
     * @throws ApiError
     */
    static updateExistingProjectApiV1ProjectsProjectIdPut(data: UpdateExistingProjectApiV1ProjectsProjectIdPutData): CancelablePromise<UpdateExistingProjectApiV1ProjectsProjectIdPutResponse>;
    /**
     * Delete Project
     * Delete a project by ID.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteProjectApiV1ProjectsProjectIdDelete(data: DeleteProjectApiV1ProjectsProjectIdDeleteData): CancelablePromise<DeleteProjectApiV1ProjectsProjectIdDeleteResponse>;
    /**
     * List Datasets For Project
     * List eval datasets for a project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns EvalDataset Successful Response
     * @throws ApiError
     */
    static listDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGet(data: ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData): CancelablePromise<ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse>;
    /**
     * Create Eval Dataset For Project
     * Create a new eval dataset for a project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.requestBody
     * @param data.session
     * @returns EvalDataset Successful Response
     * @throws ApiError
     */
    static createEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPost(data: CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData): CancelablePromise<CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostResponse>;
    /**
     * Create Local Eval Set For Project
     * Create a new local eval set.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.requestBody
     * @param data.session
     * @returns LocalEvalResults Successful Response
     * @throws ApiError
     */
    static createLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPost(data: CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData): CancelablePromise<CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse>;
    /**
     * List Local Evals For Project
     * List local eval results for a project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns LocalEvalResults Successful Response
     * @throws ApiError
     */
    static listLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGet(data: ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData): CancelablePromise<ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse>;
    /**
     * List Local Eval Sets For Project
     * List local eval sets for a project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns LocalEvalSets Successful Response
     * @throws ApiError
     */
    static listLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGet(data: ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData): CancelablePromise<ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse>;
    /**
     * Delete Local Eval Set
     * Delete a local eval set.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.localEvalSetId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static deleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDelete(data: DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData): CancelablePromise<DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteResponse>;
    /**
     * List Promptmixin Prompts
     * List PromptMixin prompt sets for a project.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns PromptMixinPrompts Successful Response
     * @throws ApiError
     */
    static listPromptmixinPromptsApiV1ProjectsProjectIdPromptsGet(data: ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData): CancelablePromise<ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse>;
    /**
     * Create Prompt Mixin Prompts
     * Create a new PromptMixin prompt set.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.requestBody
     * @param data.session
     * @returns PromptMixinPrompts Successful Response
     * @throws ApiError
     */
    static createPromptMixinPromptsApiV1ProjectsProjectIdPromptsPost(data: CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData): CancelablePromise<CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostResponse>;
    /**
     * Update Promptmixin Prompts
     * Update a PromptMixin prompt set.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.promptSetId
     * @param data.requestBody
     * @param data.session
     * @returns PromptMixinPrompts Successful Response
     * @throws ApiError
     */
    static updatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPut(data: UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData): CancelablePromise<UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutResponse>;
    /**
     * Delete Prompt Mixin Prompts
     * Delete a PromptMixin prompt set.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.promptSetId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static deletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDelete(data: DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData): CancelablePromise<DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteResponse>;
}
declare class FilesService {
    /**
     * Get File
     * Read File metadata objects.
     * @param data The data for the request.
     * @param data.id
     * @param data.projectId
     * @param data.session
     * @returns File Successful Response
     * @throws ApiError
     */
    static getFileApiV1FilesIdGet(data: GetFileApiV1FilesIdGetData): CancelablePromise<GetFileApiV1FilesIdGetResponse>;
    /**
     * Delete File
     * Delete the file from S3.
     * @param data The data for the request.
     * @param data.id
     * @param data.projectId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteFileApiV1FilesIdDelete(data: DeleteFileApiV1FilesIdDeleteData): CancelablePromise<DeleteFileApiV1FilesIdDeleteResponse>;
    /**
     * List Files
     * Read File metadata objects.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns File Successful Response
     * @throws ApiError
     */
    static listFilesApiV1FilesGet(data?: ListFilesApiV1FilesGetData): CancelablePromise<ListFilesApiV1FilesGetResponse>;
    /**
     * Generate Presigned Url
     * Create a presigned url for uploading a file.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.session
     * @returns PresignedUrl Successful Response
     * @throws ApiError
     */
    static generatePresignedUrlApiV1FilesPut(data: GeneratePresignedUrlApiV1FilesPutData): CancelablePromise<GeneratePresignedUrlApiV1FilesPutResponse>;
    /**
     * Upload File
     * Upload a file to S3.
     * @param data The data for the request.
     * @param data.formData
     * @param data.projectId
     * @param data.session
     * @returns File Successful Response
     * @throws ApiError
     */
    static uploadFileApiV1FilesPost(data: UploadFileApiV1FilesPostData): CancelablePromise<UploadFileApiV1FilesPostResponse>;
    /**
     * Sync Files
     * Sync Files API against file contents uploaded via S3 presigned urls.
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns File Successful Response
     * @throws ApiError
     */
    static syncFilesApiV1FilesSyncPut(data?: SyncFilesApiV1FilesSyncPutData): CancelablePromise<SyncFilesApiV1FilesSyncPutResponse>;
    /**
     * Read File Content
     * Returns a presigned url to read the file content.
     * @param data The data for the request.
     * @param data.id
     * @param data.projectId
     * @param data.session
     * @returns PresignedUrl Successful Response
     * @throws ApiError
     */
    static readFileContentApiV1FilesIdContentGet(data: ReadFileContentApiV1FilesIdContentGetData): CancelablePromise<ReadFileContentApiV1FilesIdContentGetResponse>;
}
declare class PipelinesService {
    /**
     * Search Pipelines
     * Search for pipelines by various parameters.
     * @param data The data for the request.
     * @param data.projectName
     * @param data.pipelineName
     * @param data.pipelineType
     * @param data.projectId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static searchPipelinesApiV1PipelinesGet(data?: SearchPipelinesApiV1PipelinesGetData): CancelablePromise<SearchPipelinesApiV1PipelinesGetResponse>;
    /**
     * Upsert Pipeline
     * Upsert a pipeline for a project.
     * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static upsertPipelineApiV1PipelinesPut(data: UpsertPipelineApiV1PipelinesPutData): CancelablePromise<UpsertPipelineApiV1PipelinesPutResponse>;
    /**
     * Create Pipeline
     * Create a new pipeline for a project.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.projectId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static createPipelineApiV1PipelinesPost(data: CreatePipelineApiV1PipelinesPostData): CancelablePromise<CreatePipelineApiV1PipelinesPostResponse>;
    /**
     * Get Pipeline
     * Get a pipeline by ID for a given project.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static getPipelineApiV1PipelinesPipelineIdGet(data: GetPipelineApiV1PipelinesPipelineIdGetData): CancelablePromise<GetPipelineApiV1PipelinesPipelineIdGetResponse>;
    /**
     * Update Existing Pipeline
     * Update an existing pipeline for a project.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static updateExistingPipelineApiV1PipelinesPipelineIdPut(data: UpdateExistingPipelineApiV1PipelinesPipelineIdPutData): CancelablePromise<UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse>;
    /**
     * Delete Pipeline
     * Delete a pipeline by ID.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deletePipelineApiV1PipelinesPipelineIdDelete(data: DeletePipelineApiV1PipelinesPipelineIdDeleteData): CancelablePromise<DeletePipelineApiV1PipelinesPipelineIdDeleteResponse>;
    /**
     * Get Pipeline Status
     * Get the status of a pipeline by ID.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns ManagedIngestionStatusResponse Successful Response
     * @throws ApiError
     */
    static getPipelineStatusApiV1PipelinesPipelineIdStatusGet(data: GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData): CancelablePromise<GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse>;
    /**
     * Sync Pipeline
     * Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static syncPipelineApiV1PipelinesPipelineIdSyncPost(data: SyncPipelineApiV1PipelinesPipelineIdSyncPostData): CancelablePromise<SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse>;
    /**
     * Copy Pipeline
     * Copy a pipeline by ID.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static copyPipelineApiV1PipelinesPipelineIdCopyPost(data: CopyPipelineApiV1PipelinesPipelineIdCopyPostData): CancelablePromise<CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse>;
    /**
     * Get Eval Dataset Executions
     * Get the status of an EvalDatasetExecution.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.evalDatasetId
     * @param data.session
     * @returns EvalDatasetJobRecord Successful Response
     * @throws ApiError
     */
    static getEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGet(data: GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData): CancelablePromise<GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse>;
    /**
     * Execute Eval Dataset
     * Execute a dataset.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.evalDatasetId
     * @param data.requestBody
     * @param data.session
     * @returns EvalDatasetJobRecord Successful Response
     * @throws ApiError
     */
    static executeEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePost(data: ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData): CancelablePromise<ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostResponse>;
    /**
     * Get Eval Dataset Execution Result
     * Get the result of an EvalDatasetExecution.
     * If eval_question_ids is specified, only the results for the specified
     * questions will be returned.
     * If any of the specified questions do not have a result, they will be ignored.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.evalDatasetId
     * @param data.session
     * @returns EvalQuestionResult Successful Response
     * @throws ApiError
     */
    static getEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGet(data: GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData): CancelablePromise<GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse>;
    /**
     * Get Eval Dataset Execution
     * Get the status of an EvalDatasetExecution.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.evalDatasetId
     * @param data.evalDatasetExecutionId
     * @param data.session
     * @returns EvalDatasetJobRecord Successful Response
     * @throws ApiError
     */
    static getEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGet(data: GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData): CancelablePromise<GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetResponse>;
    /**
     * List Pipeline Files
     * Get files for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.dataSourceId
     * @param data.onlyManuallyUploaded
     * @param data.session
     * @returns PipelineFile Successful Response
     * @throws ApiError
     */
    static listPipelineFilesApiV1PipelinesPipelineIdFilesGet(data: ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData): CancelablePromise<ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse>;
    /**
     * Add Files To Pipeline
     * Add files to a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns PipelineFile Successful Response
     * @throws ApiError
     */
    static addFilesToPipelineApiV1PipelinesPipelineIdFilesPut(data: AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData): CancelablePromise<AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse>;
    /**
     * Get Pipeline File Status
     * Get status of a file for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.fileId
     * @param data.session
     * @returns ManagedIngestionStatusResponse Successful Response
     * @throws ApiError
     */
    static getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet(data: GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData): CancelablePromise<GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse>;
    /**
     * Update Pipeline File
     * Update a file for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.fileId
     * @param data.requestBody
     * @param data.session
     * @returns PipelineFile Successful Response
     * @throws ApiError
     */
    static updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut(data: UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData): CancelablePromise<UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse>;
    /**
     * Delete Pipeline File
     * Delete a file from a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.fileId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete(data: DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData): CancelablePromise<DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse>;
    /**
     * Import Pipeline Metadata
     * Import metadata for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.formData
     * @param data.session
     * @returns string Successful Response
     * @throws ApiError
     */
    static importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut(data: ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData): CancelablePromise<ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse>;
    /**
     * Delete Pipeline Files Metadata
     * Delete metadata for all files in a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete(data: DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData): CancelablePromise<DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse>;
    /**
     * List Pipeline Data Sources
     * Get data sources for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns PipelineDataSource Successful Response
     * @throws ApiError
     */
    static listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet(data: ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData): CancelablePromise<ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse>;
    /**
     * Add Data Sources To Pipeline
     * Add data sources to a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns PipelineDataSource Successful Response
     * @throws ApiError
     */
    static addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut(data: AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData): CancelablePromise<AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse>;
    /**
     * Delete Pipeline Data Source
     * Delete a data source from a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.dataSourceId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete(data: DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData): CancelablePromise<DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse>;
    /**
     * Sync Pipeline Data Source
     * Run ingestion for the pipeline data source by incrementally updating the data-sink with upstream changes from data-source.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.dataSourceId
     * @param data.session
     * @returns Pipeline Successful Response
     * @throws ApiError
     */
    static syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost(data: SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData): CancelablePromise<SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse>;
    /**
     * Run Search
     * Get retrieval results for a managed pipeline and a query
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns RetrieveResults Successful Response
     * @throws ApiError
     */
    static runSearchApiV1PipelinesPipelineIdRetrievePost(data: RunSearchApiV1PipelinesPipelineIdRetrievePostData): CancelablePromise<RunSearchApiV1PipelinesPipelineIdRetrievePostResponse>;
    /**
     * List Pipeline Jobs
     * Get jobs for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.session
     * @returns PipelineDeployment Successful Response
     * @throws ApiError
     */
    static listPipelineJobsApiV1PipelinesPipelineIdJobsGet(data: ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData): CancelablePromise<ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse>;
    /**
     * Get Pipeline Job
     * Get a job for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.jobId
     * @param data.session
     * @returns PipelineDeployment Successful Response
     * @throws ApiError
     */
    static getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet(data: GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData): CancelablePromise<GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse>;
    /**
     * Chat
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static chatApiV1PipelinesPipelineIdChatPost(data: ChatApiV1PipelinesPipelineIdChatPostData): CancelablePromise<ChatApiV1PipelinesPipelineIdChatPostResponse>;
    /**
     * List Pipeline Documents
     * Return a list of documents for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.skip
     * @param data.limit
     * @param data.fileId
     * @param data.onlyDirectUpload
     * @param data.session
     * @returns CloudDocument Successful Response
     * @throws ApiError
     */
    static listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet(data: ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData): CancelablePromise<ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse>;
    /**
     * Upsert Batch Pipeline Documents
     * Batch create or update a document for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns CloudDocument Successful Response
     * @throws ApiError
     */
    static upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut(data: UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData): CancelablePromise<UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse>;
    /**
     * Create Batch Pipeline Documents
     * Batch create documents for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.requestBody
     * @param data.session
     * @returns CloudDocument Successful Response
     * @throws ApiError
     */
    static createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost(data: CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData): CancelablePromise<CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse>;
    /**
     * Get Pipeline Document
     * Return a single document for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.documentId
     * @param data.session
     * @returns CloudDocument Successful Response
     * @throws ApiError
     */
    static getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet(data: GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData): CancelablePromise<GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse>;
    /**
     * Delete Pipeline Document
     * Delete a document for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.documentId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete(data: DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData): CancelablePromise<DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse>;
    /**
     * Get Pipeline Document Status
     * Return a single document for a pipeline.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.documentId
     * @param data.session
     * @returns ManagedIngestionStatusResponse Successful Response
     * @throws ApiError
     */
    static getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet(data: GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData): CancelablePromise<GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse>;
    /**
     * List Pipeline Document Chunks
     * Return a list of chunks for a pipeline document.
     * @param data The data for the request.
     * @param data.pipelineId
     * @param data.documentId
     * @param data.session
     * @returns TextNode Successful Response
     * @throws ApiError
     */
    static listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet(data: ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData): CancelablePromise<ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse>;
}
declare class EvalsService {
    /**
     * Get Dataset
     * Get a dataset by ID.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.session
     * @returns EvalDataset Successful Response
     * @throws ApiError
     */
    static getDatasetApiV1EvalsDatasetsDatasetIdGet(data: GetDatasetApiV1EvalsDatasetsDatasetIdGetData): CancelablePromise<GetDatasetApiV1EvalsDatasetsDatasetIdGetResponse>;
    /**
     * Update Dataset
     * Update a dataset.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.requestBody
     * @param data.session
     * @returns EvalDataset Successful Response
     * @throws ApiError
     */
    static updateDatasetApiV1EvalsDatasetsDatasetIdPut(data: UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData): CancelablePromise<UpdateDatasetApiV1EvalsDatasetsDatasetIdPutResponse>;
    /**
     * Delete Dataset
     * Delete a dataset.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteDatasetApiV1EvalsDatasetsDatasetIdDelete(data: DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData): CancelablePromise<DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteResponse>;
    /**
     * List Questions
     * List questions for a dataset.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.session
     * @returns EvalQuestion Successful Response
     * @throws ApiError
     */
    static listQuestionsApiV1EvalsDatasetsDatasetIdQuestionGet(data: ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData): CancelablePromise<ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse>;
    /**
     * Create Question
     * Create a new question.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.requestBody
     * @param data.session
     * @returns EvalQuestion Successful Response
     * @throws ApiError
     */
    static createQuestionApiV1EvalsDatasetsDatasetIdQuestionPost(data: CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData): CancelablePromise<CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostResponse>;
    /**
     * Create Questions
     * Create a new question.
     * @param data The data for the request.
     * @param data.datasetId
     * @param data.requestBody
     * @param data.session
     * @returns EvalQuestion Successful Response
     * @throws ApiError
     */
    static createQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPost(data: CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData): CancelablePromise<CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse>;
    /**
     * Get Question
     * Get a question by ID.
     * @param data The data for the request.
     * @param data.questionId
     * @param data.session
     * @returns EvalQuestion Successful Response
     * @throws ApiError
     */
    static getQuestionApiV1EvalsQuestionsQuestionIdGet(data: GetQuestionApiV1EvalsQuestionsQuestionIdGetData): CancelablePromise<GetQuestionApiV1EvalsQuestionsQuestionIdGetResponse>;
    /**
     * Replace Question
     * Replace a question.
     * @param data The data for the request.
     * @param data.questionId
     * @param data.requestBody
     * @param data.session
     * @returns EvalQuestion Successful Response
     * @throws ApiError
     */
    static replaceQuestionApiV1EvalsQuestionsQuestionIdPut(data: ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData): CancelablePromise<ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutResponse>;
    /**
     * Delete Question
     * Delete a question.
     * @param data The data for the request.
     * @param data.questionId
     * @param data.session
     * @returns void Successful Response
     * @throws ApiError
     */
    static deleteQuestionApiV1EvalsQuestionsQuestionIdDelete(data: DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData): CancelablePromise<DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteResponse>;
    /**
     * List Supported Models
     * List supported models.
     * @param data The data for the request.
     * @param data.session
     * @returns SupportedEvalLLMModel Successful Response
     * @throws ApiError
     */
    static listSupportedModelsApiV1EvalsModelsGet(data?: ListSupportedModelsApiV1EvalsModelsGetData): CancelablePromise<ListSupportedModelsApiV1EvalsModelsGetResponse>;
}
declare class ParsingService {
    /**
     * Get Job Image Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.name
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobImageResultApiV1ParsingJobJobIdResultImageNameGet(data: GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData): CancelablePromise<GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponse>;
    /**
     * Get Supported File Extensions
     * Get a list of supported file extensions
     * @returns LlamaParseSupportedFileExtensions Successful Response
     * @throws ApiError
     */
    static getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet(): CancelablePromise<GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse>;
    /**
     * Upload File
     * Upload a file to s3 and create a job. return a job id
     * @param data The data for the request.
     * @param data.formData
     * @param data.session
     * @returns ParsingJob Successful Response
     * @throws ApiError
     */
    static uploadFileApiV1ParsingUploadPost(data: UploadFileApiV1ParsingUploadPostData): CancelablePromise<UploadFileApiV1ParsingUploadPostResponse>;
    /**
     * Usage
     * Get parsing usage for user
     * @param data The data for the request.
     * @param data.session
     * @returns ParsingUsage Successful Response
     * @throws ApiError
     */
    static usageApiV1ParsingUsageGet(data?: UsageApiV1ParsingUsageGetData): CancelablePromise<UsageApiV1ParsingUsageGetResponse>;
    /**
     * Get Job
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJob Successful Response
     * @throws ApiError
     */
    static getJobApiV1ParsingJobJobIdGet(data: GetJobApiV1ParsingJobJobIdGetData): CancelablePromise<GetJobApiV1ParsingJobJobIdGetResponse>;
    /**
     * Get Parsing Job Details
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet(data: GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData): CancelablePromise<GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponse>;
    /**
     * Get Job Text Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobTextResult Successful Response
     * @throws ApiError
     */
    static getJobTextResultApiV1ParsingJobJobIdResultTextGet(data: GetJobTextResultApiV1ParsingJobJobIdResultTextGetData): CancelablePromise<GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse>;
    /**
     * Get Job Raw Text Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobRawTextResultApiV1ParsingJobJobIdResultRawTextGet(data: GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData): CancelablePromise<GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetResponse>;
    /**
     * Get Job Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobMarkdownResult Successful Response
     * @throws ApiError
     */
    static getJobResultApiV1ParsingJobJobIdResultMarkdownGet(data: GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData): CancelablePromise<GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse>;
    /**
     * Get Job Raw Md Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet(data: GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData): CancelablePromise<GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponse>;
    /**
     * Get Job Json Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobJsonResult Successful Response
     * @throws ApiError
     */
    static getJobJsonResultApiV1ParsingJobJobIdResultJsonGet(data: GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData): CancelablePromise<GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse>;
    /**
     * Get Job Json Raw Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet(data: GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData): CancelablePromise<GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponse>;
    /**
     * Get Parsing History Result
     * Get parsing history for user
     * @param data The data for the request.
     * @param data.session
     * @returns ParsingHistoryItem Successful Response
     * @throws ApiError
     */
    static getParsingHistoryResultApiV1ParsingHistoryGet(data?: GetParsingHistoryResultApiV1ParsingHistoryGetData): CancelablePromise<GetParsingHistoryResultApiV1ParsingHistoryGetResponse>;
    /**
     * Generate Presigned Url
     * Generate a presigned URL for a job
     * @param data The data for the request.
     * @param data.jobId
     * @param data.filename
     * @param data.session
     * @returns PresignedUrl Successful Response
     * @throws ApiError
     */
    static generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet(data: GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData): CancelablePromise<GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse>;
}
declare class ComponentDefinitionsService {
    /**
     * List Transformation Definitions
     * List transformation component definitions.
     * @returns ConfigurableTransformationDefinition Successful Response
     * @throws ApiError
     */
    static listTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGet(): CancelablePromise<ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse>;
    /**
     * List Data Source Definitions
     * List data source component definitions.
     * @returns DataSourceDefinition Successful Response
     * @throws ApiError
     */
    static listDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGet(): CancelablePromise<ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse>;
    /**
     * List Data Sink Definitions
     * List data sink component definitions.
     * @returns DataSinkDefinition Successful Response
     * @throws ApiError
     */
    static listDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGet(): CancelablePromise<ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse>;
}
declare class BillingService {
    /**
     * Create Checkout Session
     * Create a new checkout session.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns string Successful Response
     * @throws ApiError
     */
    static createCheckoutSessionApiV1BillingCheckoutSessionPost(data: CreateCheckoutSessionApiV1BillingCheckoutSessionPostData): CancelablePromise<CreateCheckoutSessionApiV1BillingCheckoutSessionPostResponse>;
    /**
     * Create Customer Portal Session
     * Create a new customer portal session.
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns string Successful Response
     * @throws ApiError
     */
    static createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost(data: CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData): CancelablePromise<CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse>;
    /**
     * Stripe Webhook
     * Stripe webhook endpoint.
     * @param data The data for the request.
     * @param data.stripeSignature
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static stripeWebhookApiV1BillingWebhookPost(data?: StripeWebhookApiV1BillingWebhookPostData): CancelablePromise<StripeWebhookApiV1BillingWebhookPostResponse>;
}
declare class ExtractionService {
    /**
     * List Schemas
     * @param data The data for the request.
     * @param data.projectId
     * @param data.session
     * @returns ExtractionSchema Successful Response
     * @throws ApiError
     */
    static listSchemasApiV1ExtractionSchemasGet(data?: ListSchemasApiV1ExtractionSchemasGetData): CancelablePromise<ListSchemasApiV1ExtractionSchemasGetResponse>;
    /**
     * Create Schema
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns ExtractionSchema Successful Response
     * @throws ApiError
     */
    static createSchemaApiV1ExtractionSchemasPost(data: CreateSchemaApiV1ExtractionSchemasPostData): CancelablePromise<CreateSchemaApiV1ExtractionSchemasPostResponse>;
    /**
     * Infer Schema
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns ExtractionSchema Successful Response
     * @throws ApiError
     */
    static inferSchemaApiV1ExtractionSchemasInferPost(data: InferSchemaApiV1ExtractionSchemasInferPostData): CancelablePromise<InferSchemaApiV1ExtractionSchemasInferPostResponse>;
    /**
     * Get Schema
     * @param data The data for the request.
     * @param data.schemaId
     * @param data.session
     * @returns ExtractionSchema Successful Response
     * @throws ApiError
     */
    static getSchemaApiV1ExtractionSchemasSchemaIdGet(data: GetSchemaApiV1ExtractionSchemasSchemaIdGetData): CancelablePromise<GetSchemaApiV1ExtractionSchemasSchemaIdGetResponse>;
    /**
     * Update Schema
     * @param data The data for the request.
     * @param data.schemaId
     * @param data.requestBody
     * @param data.session
     * @returns ExtractionSchema Successful Response
     * @throws ApiError
     */
    static updateSchemaApiV1ExtractionSchemasSchemaIdPut(data: UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData): CancelablePromise<UpdateSchemaApiV1ExtractionSchemasSchemaIdPutResponse>;
    /**
     * List Jobs
     * @param data The data for the request.
     * @param data.schemaId
     * @param data.session
     * @returns ExtractionJob Successful Response
     * @throws ApiError
     */
    static listJobsApiV1ExtractionJobsGet(data: ListJobsApiV1ExtractionJobsGetData): CancelablePromise<ListJobsApiV1ExtractionJobsGetResponse>;
    /**
     * Run Job
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns ExtractionJob Successful Response
     * @throws ApiError
     */
    static runJobApiV1ExtractionJobsPost(data: RunJobApiV1ExtractionJobsPostData): CancelablePromise<RunJobApiV1ExtractionJobsPostResponse>;
    /**
     * Get Job
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ExtractionJob Successful Response
     * @throws ApiError
     */
    static getJobApiV1ExtractionJobsJobIdGet(data: GetJobApiV1ExtractionJobsJobIdGetData): CancelablePromise<GetJobApiV1ExtractionJobsJobIdGetResponse>;
    /**
     * Run Jobs In Batch
     * @param data The data for the request.
     * @param data.requestBody
     * @param data.session
     * @returns ExtractionJob Successful Response
     * @throws ApiError
     */
    static runJobsInBatchApiV1ExtractionJobsBatchPost(data: RunJobsInBatchApiV1ExtractionJobsBatchPostData): CancelablePromise<RunJobsInBatchApiV1ExtractionJobsBatchPostResponse>;
    /**
     * Get Job Result
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ExtractionResult Successful Response
     * @throws ApiError
     */
    static getJobResultApiV1ExtractionJobsJobIdResultGet(data: GetJobResultApiV1ExtractionJobsJobIdResultGetData): CancelablePromise<GetJobResultApiV1ExtractionJobsJobIdResultGetResponse>;
}
declare class DeprecatedService {
    /**
     * Get Job Image Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.name
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobImageResultApiParsingJobJobIdResultImageNameGet(data: GetJobImageResultApiParsingJobJobIdResultImageNameGetData): CancelablePromise<GetJobImageResultApiParsingJobJobIdResultImageNameGetResponse>;
    /**
     * Get Supported File Extensions
     * Get a list of supported file extensions
     * @returns LlamaParseSupportedFileExtensions Successful Response
     * @throws ApiError
     */
    static getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet(): CancelablePromise<GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse>;
    /**
     * Upload File
     * Upload a file to s3 and create a job. return a job id
     * @param data The data for the request.
     * @param data.formData
     * @param data.session
     * @returns ParsingJob Successful Response
     * @throws ApiError
     */
    static uploadFileApiParsingUploadPost(data: UploadFileApiParsingUploadPostData): CancelablePromise<UploadFileApiParsingUploadPostResponse>;
    /**
     * Usage
     * Get parsing usage for user
     * @param data The data for the request.
     * @param data.session
     * @returns ParsingUsage Successful Response
     * @throws ApiError
     */
    static usageApiParsingUsageGet(data?: UsageApiParsingUsageGetData): CancelablePromise<UsageApiParsingUsageGetResponse>;
    /**
     * Get Job
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJob Successful Response
     * @throws ApiError
     */
    static getJobApiParsingJobJobIdGet(data: GetJobApiParsingJobJobIdGetData): CancelablePromise<GetJobApiParsingJobJobIdGetResponse>;
    /**
     * Get Parsing Job Details
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getParsingJobDetailsApiParsingJobJobIdDetailsGet(data: GetParsingJobDetailsApiParsingJobJobIdDetailsGetData): CancelablePromise<GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponse>;
    /**
     * Get Job Text Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobTextResult Successful Response
     * @throws ApiError
     */
    static getJobTextResultApiParsingJobJobIdResultTextGet(data: GetJobTextResultApiParsingJobJobIdResultTextGetData): CancelablePromise<GetJobTextResultApiParsingJobJobIdResultTextGetResponse>;
    /**
     * Get Job Raw Text Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobRawTextResultApiParsingJobJobIdResultRawTextGet(data: GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData): CancelablePromise<GetJobRawTextResultApiParsingJobJobIdResultRawTextGetResponse>;
    /**
     * Get Job Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobMarkdownResult Successful Response
     * @throws ApiError
     */
    static getJobResultApiParsingJobJobIdResultMarkdownGet(data: GetJobResultApiParsingJobJobIdResultMarkdownGetData): CancelablePromise<GetJobResultApiParsingJobJobIdResultMarkdownGetResponse>;
    /**
     * Get Job Raw Md Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet(data: GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData): CancelablePromise<GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponse>;
    /**
     * Get Job Json Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns ParsingJobJsonResult Successful Response
     * @throws ApiError
     */
    static getJobJsonResultApiParsingJobJobIdResultJsonGet(data: GetJobJsonResultApiParsingJobJobIdResultJsonGetData): CancelablePromise<GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse>;
    /**
     * Get Job Json Raw Result
     * Get a job by id
     * @param data The data for the request.
     * @param data.jobId
     * @param data.session
     * @returns unknown Successful Response
     * @throws ApiError
     */
    static getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet(data: GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData): CancelablePromise<GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponse>;
    /**
     * Get Parsing History Result
     * Get parsing history for user
     * @param data The data for the request.
     * @param data.session
     * @returns ParsingHistoryItem Successful Response
     * @throws ApiError
     */
    static getParsingHistoryResultApiParsingHistoryGet(data?: GetParsingHistoryResultApiParsingHistoryGetData): CancelablePromise<GetParsingHistoryResultApiParsingHistoryGetResponse>;
    /**
     * Generate Presigned Url
     * Generate a presigned URL for a job
     * @param data The data for the request.
     * @param data.jobId
     * @param data.filename
     * @param data.session
     * @returns PresignedUrl Successful Response
     * @throws ApiError
     */
    static generatePresignedUrlApiParsingJobJobIdReadFilenameGet(data: GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData): CancelablePromise<GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse>;
}

export { $APIKey, $APIKeyCreate, $APIKeyUpdate, $AutoTransformConfig, $AzureOpenAIEmbedding, $Base, $BasePromptTemplate, $BedrockEmbedding, $Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put, $Body_upload_file_api_parsing_upload_post, $Body_upload_file_api_v1_files_post, $Body_upload_file_api_v1_parsing_upload_post, $ChatData, $ChatMessage, $ChatParams, $CheckoutSessionCreatePayload, $CloudAzStorageBlobDataSource, $CloudAzureAISearchVectorStore, $CloudChromaVectorStore, $CloudConfluenceDataSource, $CloudDocument, $CloudDocumentCreate, $CloudJiraDataSource, $CloudNotionPageDataSource, $CloudOneDriveDataSource, $CloudPineconeVectorStore, $CloudPostgresVectorStore, $CloudQdrantVectorStore, $CloudS3DataSource, $CloudSharepointDataSource, $CloudSlackDataSource, $CloudWeaviateVectorStore, $CodeSplitter, $CohereEmbedding, $ConfigurableDataSinkNames, $ConfigurableDataSourceNames, $ConfigurableTransformationDefinition, $ConfigurableTransformationNames, $ConfiguredTransformationItem, $CustomerPortalSessionCreatePayload, $DataSink, $DataSinkCreate, $DataSinkDefinition, $DataSinkUpdate, $DataSource, $DataSourceCreate, $DataSourceDefinition, $DataSourceUpdate, $DefaultOrganizationUpdate, $EmbeddingConfig, $EmbeddingConfigType, $EvalDataset, $EvalDatasetCreate, $EvalDatasetJobParams, $EvalDatasetJobRecord, $EvalDatasetUpdate, $EvalExecutionCreate, $EvalExecutionParams, $EvalExecutionParamsOverride, $EvalLLMModelData, $EvalQuestion, $EvalQuestionCreate, $EvalQuestionResult, $ExtractionJob, $ExtractionJobCreate, $ExtractionJobCreateBatch, $ExtractionResult, $ExtractionSchema, $ExtractionSchemaCreate, $ExtractionSchemaInfer, $ExtractionSchemaUpdate, $File, $FileCreate, $FilterCondition, $FilterOperator, $GeminiEmbedding, $HTMLNodeParser, $HTTPValidationError, $HuggingFaceInferenceAPIEmbedding, $JSONNodeParser, $LLM, $LlamaParseParameters, $LlamaParseSupportedFileExtensions, $LocalEval, $LocalEvalResults, $LocalEvalSetCreate, $LocalEvalSets, $ManagedIngestionStatus, $ManagedIngestionStatusResponse, $MarkdownElementNodeParser, $MarkdownNodeParser, $MessageRole, $MetadataFilter, $MetadataFilters, $MetricResult, $NodeParser, $ObjectType, $OpenAIEmbedding, type $OpenApiTs, $Organization, $OrganizationCreate, $OrganizationUpdate, $ParserLanguages, $ParsingHistoryItem, $ParsingJob, $ParsingJobJsonResult, $ParsingJobMarkdownResult, $ParsingJobTextResult, $ParsingUsage, $Pipeline, $PipelineCreate, $PipelineDataSource, $PipelineDataSourceCreate, $PipelineDeployment, $PipelineFile, $PipelineFileCreate, $PipelineFileUpdate, $PipelineType, $PipelineUpdate, $Pooling, $PresetRetrievalParams, $PresignedUrl, $Project, $ProjectCreate, $ProjectUpdate, $PromptMixinPrompts, $PromptSpec, $PydanticProgramMode, $RelatedNodeInfo, $RetrievalMode, $RetrievalParams, $RetrieveResults, $SentenceSplitter, $SimpleFileNodeParser, $StatusEnum, $SupportedEvalLLMModel, $SupportedEvalLLMModelNames, $TextNode, $TextNodeWithScore, $TokenTextSplitter, $TransformConfig, $TransformConfigMode, $TransformationCategoryNames, $UserOrganization, $UserOrganizationCreate, $UserOrganizationDelete, $ValidationError, type APIKey, type APIKeyCreate, type APIKeyUpdate, type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData, type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse, type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData, type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse, type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData, type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse, ApiError, ApiKeysService, type AutoTransformConfig, type AzureOpenAIEmbedding, type Base, type BasePromptTemplate, type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData, type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse, type BedrockEmbedding, BillingService, type Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put, type Body_upload_file_api_parsing_upload_post, type Body_upload_file_api_v1_files_post, type Body_upload_file_api_v1_parsing_upload_post, CancelError, CancelablePromise, type ChatApiV1PipelinesPipelineIdChatPostData, type ChatApiV1PipelinesPipelineIdChatPostResponse, type ChatData, type ChatMessage, type ChatParams, type CheckoutSessionCreatePayload, type CloudAzStorageBlobDataSource, type CloudAzureAISearchVectorStore, type CloudChromaVectorStore, type CloudConfluenceDataSource, type CloudDocument, type CloudDocumentCreate, type CloudJiraDataSource, type CloudNotionPageDataSource, type CloudOneDriveDataSource, type CloudPineconeVectorStore, type CloudPostgresVectorStore, type CloudQdrantVectorStore, type CloudS3DataSource, type CloudSharepointDataSource, type CloudSlackDataSource, type CloudWeaviateVectorStore, type CodeSplitter, type CohereEmbedding, ComponentDefinitionsService, ConfigurableDataSinkNames, ConfigurableDataSourceNames, type ConfigurableTransformationDefinition, ConfigurableTransformationNames, type ConfiguredTransformationItem, type CopyPipelineApiV1PipelinesPipelineIdCopyPostData, type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse, type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData, type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse, type CreateCheckoutSessionApiV1BillingCheckoutSessionPostData, type CreateCheckoutSessionApiV1BillingCheckoutSessionPostResponse, type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData, type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse, type CreateDataSinkApiV1DataSinksPostData, type CreateDataSinkApiV1DataSinksPostResponse, type CreateDataSourceApiV1DataSourcesPostData, type CreateDataSourceApiV1DataSourcesPostResponse, type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData, type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostResponse, type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData, type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse, type CreateOrganizationApiV1OrganizationsPostData, type CreateOrganizationApiV1OrganizationsPostResponse, type CreatePipelineApiV1PipelinesPostData, type CreatePipelineApiV1PipelinesPostResponse, type CreateProjectApiV1ProjectsPostData, type CreateProjectApiV1ProjectsPostResponse, type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData, type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostResponse, type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData, type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostResponse, type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData, type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse, type CreateSchemaApiV1ExtractionSchemasPostData, type CreateSchemaApiV1ExtractionSchemasPostResponse, type CustomerPortalSessionCreatePayload, type DataSink, type DataSinkCreate, type DataSinkDefinition, type DataSinkUpdate, DataSinksService, type DataSource, type DataSourceCreate, type DataSourceDefinition, type DataSourceUpdate, DataSourcesService, type DefaultOrganizationUpdate, type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData, type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse, type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData, type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse, type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData, type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse, type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData, type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteResponse, type DeleteFileApiV1FilesIdDeleteData, type DeleteFileApiV1FilesIdDeleteResponse, type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData, type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteResponse, type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData, type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse, type DeletePipelineApiV1PipelinesPipelineIdDeleteData, type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse, type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData, type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse, type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData, type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse, type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData, type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse, type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData, type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse, type DeleteProjectApiV1ProjectsProjectIdDeleteData, type DeleteProjectApiV1ProjectsProjectIdDeleteResponse, type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData, type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteResponse, type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData, type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteResponse, DeprecatedService, type EmbeddingConfig, EmbeddingConfigType, type EvalDataset, type EvalDatasetCreate, type EvalDatasetJobParams, type EvalDatasetJobRecord, type EvalDatasetUpdate, type EvalExecutionCreate, type EvalExecutionParams, type EvalExecutionParamsOverride, type EvalLLMModelData, type EvalQuestion, type EvalQuestionCreate, type EvalQuestionResult, EvalsService, type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData, type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostResponse, type ExtractionJob, type ExtractionJobCreate, type ExtractionJobCreateBatch, type ExtractionResult, type ExtractionSchema, type ExtractionSchemaCreate, type ExtractionSchemaInfer, type ExtractionSchemaUpdate, ExtractionService, type File, type FileCreate, FilesService, FilterCondition, FilterOperator, type GeminiEmbedding, type GenerateKeyApiV1ApiKeysPostData, type GenerateKeyApiV1ApiKeysPostResponse, type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData, type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse, type GeneratePresignedUrlApiV1FilesPutData, type GeneratePresignedUrlApiV1FilesPutResponse, type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData, type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse, type GetDataSinkApiV1DataSinksDataSinkIdGetData, type GetDataSinkApiV1DataSinksDataSinkIdGetResponse, type GetDataSourceApiV1DataSourcesDataSourceIdGetData, type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse, type GetDatasetApiV1EvalsDatasetsDatasetIdGetData, type GetDatasetApiV1EvalsDatasetsDatasetIdGetResponse, type GetDefaultOrganizationApiV1OrganizationsDefaultGetData, type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse, type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData, type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetResponse, type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData, type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse, type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData, type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse, type GetFileApiV1FilesIdGetData, type GetFileApiV1FilesIdGetResponse, type GetJobApiParsingJobJobIdGetData, type GetJobApiParsingJobJobIdGetResponse, type GetJobApiV1ExtractionJobsJobIdGetData, type GetJobApiV1ExtractionJobsJobIdGetResponse, type GetJobApiV1ParsingJobJobIdGetData, type GetJobApiV1ParsingJobJobIdGetResponse, type GetJobImageResultApiParsingJobJobIdResultImageNameGetData, type GetJobImageResultApiParsingJobJobIdResultImageNameGetResponse, type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData, type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponse, type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData, type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponse, type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData, type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponse, type GetJobJsonResultApiParsingJobJobIdResultJsonGetData, type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse, type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData, type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse, type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData, type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponse, type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData, type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponse, type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData, type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetResponse, type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData, type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetResponse, type GetJobResultApiParsingJobJobIdResultMarkdownGetData, type GetJobResultApiParsingJobJobIdResultMarkdownGetResponse, type GetJobResultApiV1ExtractionJobsJobIdResultGetData, type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse, type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData, type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse, type GetJobTextResultApiParsingJobJobIdResultTextGetData, type GetJobTextResultApiParsingJobJobIdResultTextGetResponse, type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData, type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse, type GetOrganizationApiV1OrganizationsOrganizationIdGetData, type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse, type GetParsingHistoryResultApiParsingHistoryGetData, type GetParsingHistoryResultApiParsingHistoryGetResponse, type GetParsingHistoryResultApiV1ParsingHistoryGetData, type GetParsingHistoryResultApiV1ParsingHistoryGetResponse, type GetParsingJobDetailsApiParsingJobJobIdDetailsGetData, type GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponse, type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData, type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponse, type GetPipelineApiV1PipelinesPipelineIdGetData, type GetPipelineApiV1PipelinesPipelineIdGetResponse, type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData, type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse, type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData, type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse, type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData, type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse, type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData, type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse, type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData, type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse, type GetProjectApiV1ProjectsProjectIdGetData, type GetProjectApiV1ProjectsProjectIdGetResponse, type GetQuestionApiV1EvalsQuestionsQuestionIdGetData, type GetQuestionApiV1EvalsQuestionsQuestionIdGetResponse, type GetSchemaApiV1ExtractionSchemasSchemaIdGetData, type GetSchemaApiV1ExtractionSchemasSchemaIdGetResponse, type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse, type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse, type HTMLNodeParser, type HTTPValidationError, type HuggingFaceInferenceAPIEmbedding, type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData, type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse, type InferSchemaApiV1ExtractionSchemasInferPostData, type InferSchemaApiV1ExtractionSchemasInferPostResponse, type JSONNodeParser, type LLM, type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse, type ListDataSinksApiV1DataSinksGetData, type ListDataSinksApiV1DataSinksGetResponse, type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse, type ListDataSourcesApiV1DataSourcesGetData, type ListDataSourcesApiV1DataSourcesGetResponse, type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData, type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse, type ListFilesApiV1FilesGetData, type ListFilesApiV1FilesGetResponse, type ListJobsApiV1ExtractionJobsGetData, type ListJobsApiV1ExtractionJobsGetResponse, type ListKeysApiV1ApiKeysGetData, type ListKeysApiV1ApiKeysGetResponse, type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData, type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse, type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData, type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse, type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData, type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse, type ListOrganizationsApiV1OrganizationsGetData, type ListOrganizationsApiV1OrganizationsGetResponse, type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData, type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse, type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData, type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse, type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData, type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse, type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData, type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse, type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData, type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse, type ListProjectsApiV1ProjectsGetData, type ListProjectsApiV1ProjectsGetResponse, type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData, type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse, type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData, type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse, type ListSchemasApiV1ExtractionSchemasGetData, type ListSchemasApiV1ExtractionSchemasGetResponse, type ListSupportedModelsApiV1EvalsModelsGetData, type ListSupportedModelsApiV1EvalsModelsGetResponse, type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse, type LlamaParseParameters, LlamaParseSupportedFileExtensions, type LocalEval, type LocalEvalResults, type LocalEvalSetCreate, type LocalEvalSets, ManagedIngestionStatus, type ManagedIngestionStatusResponse, type MarkdownElementNodeParser, type MarkdownNodeParser, MessageRole, type MetadataFilter, type MetadataFilters, type MetricResult, type NodeParser, ObjectType, type OpenAIEmbedding, OpenAPI, type OpenAPIConfig, type Organization, type OrganizationCreate, type OrganizationUpdate, OrganizationsService, ParserLanguages, type ParsingHistoryItem, type ParsingJob, type ParsingJobJsonResult, type ParsingJobMarkdownResult, type ParsingJobTextResult, ParsingService, type ParsingUsage, type Pipeline, type PipelineCreate, type PipelineDataSource, type PipelineDataSourceCreate, type PipelineDeployment, type PipelineFile, type PipelineFileCreate, type PipelineFileUpdate, PipelineType, type PipelineUpdate, PipelinesService, Pooling, type PresetRetrievalParams, type PresignedUrl, type Project, type ProjectCreate, type ProjectUpdate, ProjectsService, type PromptMixinPrompts, type PromptSpec, PydanticProgramMode, type ReadFileContentApiV1FilesIdContentGetData, type ReadFileContentApiV1FilesIdContentGetResponse, type RelatedNodeInfo, type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData, type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse, type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData, type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutResponse, RetrievalMode, type RetrievalParams, type RetrieveResults, type RunJobApiV1ExtractionJobsPostData, type RunJobApiV1ExtractionJobsPostResponse, type RunJobsInBatchApiV1ExtractionJobsBatchPostData, type RunJobsInBatchApiV1ExtractionJobsBatchPostResponse, type RunSearchApiV1PipelinesPipelineIdRetrievePostData, type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse, type SearchPipelinesApiV1PipelinesGetData, type SearchPipelinesApiV1PipelinesGetResponse, type SentenceSplitter, type SetDefaultOrganizationApiV1OrganizationsDefaultPutData, type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse, type SimpleFileNodeParser, StatusEnum, type StripeWebhookApiV1BillingWebhookPostData, type StripeWebhookApiV1BillingWebhookPostResponse, type SupportedEvalLLMModel, SupportedEvalLLMModelNames, type SyncFilesApiV1FilesSyncPutData, type SyncFilesApiV1FilesSyncPutResponse, type SyncPipelineApiV1PipelinesPipelineIdSyncPostData, type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse, type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData, type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse, type TextNode, type TextNodeWithScore, type TokenTextSplitter, type TransformConfig, TransformConfigMode, TransformationCategoryNames, type UpdateDataSinkApiV1DataSinksDataSinkIdPutData, type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse, type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData, type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse, type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData, type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutResponse, type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData, type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutResponse, type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData, type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse, type UpdateExistingProjectApiV1ProjectsProjectIdPutData, type UpdateExistingProjectApiV1ProjectsProjectIdPutResponse, type UpdateOrganizationApiV1OrganizationsOrganizationIdPutData, type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse, type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData, type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse, type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData, type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutResponse, type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData, type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutResponse, type UploadFileApiParsingUploadPostData, type UploadFileApiParsingUploadPostResponse, type UploadFileApiV1FilesPostData, type UploadFileApiV1FilesPostResponse, type UploadFileApiV1ParsingUploadPostData, type UploadFileApiV1ParsingUploadPostResponse, type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData, type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse, type UpsertDataSinkApiV1DataSinksPutData, type UpsertDataSinkApiV1DataSinksPutResponse, type UpsertDataSourceApiV1DataSourcesPutData, type UpsertDataSourceApiV1DataSourcesPutResponse, type UpsertOrganizationApiV1OrganizationsPutData, type UpsertOrganizationApiV1OrganizationsPutResponse, type UpsertPipelineApiV1PipelinesPutData, type UpsertPipelineApiV1PipelinesPutResponse, type UpsertProjectApiV1ProjectsPutData, type UpsertProjectApiV1ProjectsPutResponse, type UsageApiParsingUsageGetData, type UsageApiParsingUsageGetResponse, type UsageApiV1ParsingUsageGetData, type UsageApiV1ParsingUsageGetResponse, type UserOrganization, type UserOrganizationCreate, type UserOrganizationDelete, type ValidationError, job_name };
